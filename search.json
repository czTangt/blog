[{"categories":["compile"],"content":"这里记录词法分析，正则表达式，自动机的相关知识。 ","date":"2024.10.31","objectID":"/blog/categories/compile/lexer-re-automata/:0:0","tags":["compile"],"title":"Lexer Re Automata","uri":"/blog/categories/compile/lexer-re-automata/"},{"categories":["compile"],"content":"正则表达式与自动机理论\r","date":"2024.10.31","objectID":"/blog/categories/compile/lexer-re-automata/:1:0","tags":["compile"],"title":"Lexer Re Automata","uri":"/blog/categories/compile/lexer-re-automata/"},{"categories":["compile"],"content":"课程目标\r这里讲解怎么写一个自动化词法分析器生成器。根据前面的理论，我们使用 ANTLR4 来生成词法分析器，其实质上是我们使用 ANTLR4 利用正则表达式(regular expression -\u003e RE) 的规则来进行生成词法分析器。同时我们还学习了利用 java 来手写词法分析器，实质就是在使用 java 代码模拟状态转移图，它也就是自动机。那么我们来看 ANTLR4 原理，他就是把 .g4 文件转化为 .java 文件，也就是把正则表达式转化为了自动机，然后通过模拟自动机就可以得到词法分析器了。 因此我们的目标就是通过正则表达式来直接得到得到一个词法分析器。 由上图，我们构建词法分析器就是把 RE 转化为 DFA（有穷状态自动机 Deterministic FInite Automata），然后再转化为词法分析器，但是这个过程往往是困难的，所以我们采用简略的方法，通过先转化为 NFA（不确定的又穷状态自动机Nondeteeministic Finite Automata），再转化为 DFA，再进行后续的操作。 ","date":"2024.10.31","objectID":"/blog/categories/compile/lexer-re-automata/:1:1","tags":["compile"],"title":"Lexer Re Automata","uri":"/blog/categories/compile/lexer-re-automata/"},{"categories":["compile"],"content":"编程语言介绍\r语言是字符串构成的集合。 根据这句高度抽象的结论，我们会一层层进行解剖。 字符 字母表 $\\Sigma$ 是一个有限的符号集合，符号没有意义，它的语义是后来自己赋予的。 字符串 字符表 $\\Sigma$ 上的串(s) 是由 $\\Sigma$ 中符号构成的一个有穷序列。 其中 $\\epsilon$ 是空串，我们定义它为零，即 $|\\epsilon| = 0$ 字符串之间存在运算 连接运算， $x = day, y = houce, xy = dayhouce, \\epsilon s = s \\epsilon = s$ 指数运算，$s^{0} \\triangleq \\epsilon$，$s^{i} \\triangleq ss^{i-1}, i\u003e0$，这里存在上标就是连接的意思 语言 语言是给定字母表 $\\Sigma$ 上一个任意的可数的串集合。 $\\varnothing$，这一个是空集，什么语言都没有；${ \\epsilon }$，这个里面有一个语言，不过是个空串 举例：id：${a,b,c,d,a1}$；ws：${blank, tab, newline }$，if：${ if }$ 我们知道语言是串的集合，正因为是集合，所以我们可以通过集合操作构造新的语言 ","date":"2024.10.31","objectID":"/blog/categories/compile/lexer-re-automata/:1:2","tags":["compile"],"title":"Lexer Re Automata","uri":"/blog/categories/compile/lexer-re-automata/"},{"categories":["compile"],"content":"RE\r每个正则表达式 r 对应一个正则语言 L(r)。正则表达式是语法（ID：[a-zA-Z][a-zA-Z0-9]*），正则语言是语义（{a1,a2,ab,……}） ","date":"2024.10.31","objectID":"/blog/categories/compile/lexer-re-automata/:2:0","tags":["compile"],"title":"Lexer Re Automata","uri":"/blog/categories/compile/lexer-re-automata/"},{"categories":["compile"],"content":"语法\r给定字母表，$\\Sigma$ 上的正则表达式由且仅由以下规则定义： $\\epsilon$ 是正则表达式 $\\forall a \\in \\Sigma$，a 是正则表达式 如果 r 是正则表达式，则 (r) 是正则表达式 如果 r 与 s 是正则表达式，则 r | s，rs，r* 也是正则表达式 运算优先级：$() \\succ * \\succ 连接 \\succ |$ ，例子：$(a) \\mid ((b)^{*} (c)) \\equiv a | b^{*} c$ ","date":"2024.10.31","objectID":"/blog/categories/compile/lexer-re-automata/:2:1","tags":["compile"],"title":"Lexer Re Automata","uri":"/blog/categories/compile/lexer-re-automata/"},{"categories":["compile"],"content":"语义\r正则表达式对应的正则语言 $L(r)$ $L(\\epsilon) = { \\epsilon}$ $L(a) = a, \\forall a \\in \\Sigma$ $L((r)) = L(r)$ $L(r|s)=L(r) \\cup L(s)\\quad L(rs)=L(r)L(s)\\quad L(r^{*})=(L(r))^{*}$ ","date":"2024.10.31","objectID":"/blog/categories/compile/lexer-re-automata/:2:2","tags":["compile"],"title":"Lexer Re Automata","uri":"/blog/categories/compile/lexer-re-automata/"},{"categories":["compile"],"content":"符号\r","date":"2024.10.31","objectID":"/blog/categories/compile/lexer-re-automata/:2:3","tags":["compile"],"title":"Lexer Re Automata","uri":"/blog/categories/compile/lexer-re-automata/"},{"categories":["compile"],"content":"自动机\r","date":"2024.10.31","objectID":"/blog/categories/compile/lexer-re-automata/:3:0","tags":["compile"],"title":"Lexer Re Automata","uri":"/blog/categories/compile/lexer-re-automata/"},{"categories":["compile"],"content":"NFA\r语法\r非确定性有穷自动机 $\\mathcal{A}$ 是一个五元组 $\\mathcal{A} = (\\Sigma, S, s_0, \\delta, F)$ 字母表 $\\Sigma (\\epsilon \\notin \\Sigma)$ 有穷的状态集合 $S$ 唯一的初始状态 $s_0 \\in S$，这里的唯一不是强求，因为可以转化为唯一形态，转化方法就是前面再添加ige初始状态，然后通过 ${\\epsilon }$ 边转移到原始初始状态即可。 状态转移函数 $\\delta$，$\\delta: S \\times (\\Sigma \\cup {\\epsilon}) \\rightarrow 2^S$ 接受状态集合 $F \\subseteq S$，下图的 3 就是接受状态 这里非确定一个就是指接受统一字符的状态转移不唯一，如下图的 0 号节点，它接受字符 a 可以跑到两个状态上去；另一个就是可能存在 ${ \\epsilon }$ 边，在没有字符驱动的情况下自发的跑到另外一个状态。 上面的状态转移图没有规定如果碰到其他的字符该怎么处理，所以下图就约定所有没有对应出边的字符默认指向 空状态 $\\varnothing$，也就是 $(\\Sigma \\cup {\\epsilon})$，它表示达到自身，也意味着一个死状态。 语义\r有穷自动机是一类及其简单的计算装置，它可以识别（接收/拒绝）$\\Sigma$ 上的字符串 接收 (非确定性)有穷自动机 $\\mathcal{A}$ 接受字符串 x，当且仅当存在一条从开始状态 $s_0$ 到某个接受状态 $f \\in F$ 、标号为 x 的路径。 对于上面的状态转移图，只有 3 是接受状态，因此 $aabb \\in L(\\mathcal{a}), ababab \\notin L(\\mathcal{A})$ 因此，$\\mathcal{A}$ 定义了一种语言 $L(\\mathcal{A})$：它能接受的所有字符串构成的集合。所以根据上方状态转移图，可以得到自动机语言：$L(\\mathcal{A}) = L((a|b)^*abb)$ 由上面的语义，我们可以得到自动机的两个基本问题 Membership 问题：给定字符串 $x$，$x \\in L(\\mathcal{A})?$ $L(\\mathcal{A})$ 究竟是什么？ ","date":"2024.10.31","objectID":"/blog/categories/compile/lexer-re-automata/:3:1","tags":["compile"],"title":"Lexer Re Automata","uri":"/blog/categories/compile/lexer-re-automata/"},{"categories":["compile"],"content":"DFA\r语法\r确定性有穷自动机 $\\mathcal{A}$ 是一个五元组 $\\mathcal{A} = (\\Sigma, S, s_0, \\delta, F)$ 字母表 $\\Sigma (\\epsilon \\notin \\Sigma)$ 有穷的状态集合 $S$ 唯一的初始状态 $s_0 \\in S$，这个唯一是一定需要的 状态转移函数 $\\delta$，$\\delta: S \\times \\Sigma \\rightarrow S$ 接受状态集合 $F \\subseteq S$，下图的 3 就是接受状态 这里的约定就是：所有没有对应出边的字符串默认指向一个“死状态” 语义\r上图的自动机语言还是 $L(\\mathcal{A}) = L((a|b)^*abb)$，也就是上面的 NFA 和下面的 DFA 等价的。因此可以看出 NFA 适合去表达一个语言，容易得出语言是什么；而 DFA 则是因为状态的转移确定，适合写词法分析器。即 NFA 简介易于理解，便于描述语言 $L(\\mathcal{A})$；DFA易于判断$x \\in L(\\mathcal{A})$，适合产生词法分析器。那么转换就是 $RE \\Rightarrow NFA \\Rightarrow DFA \\Rightarrow$ 词法分析器。 ","date":"2024.10.31","objectID":"/blog/categories/compile/lexer-re-automata/:3:2","tags":["compile"],"title":"Lexer Re Automata","uri":"/blog/categories/compile/lexer-re-automata/"},{"categories":["compile"],"content":"相互转换\r这里就是根据下面这张图，使得正则表达式和自动机之间相互转换。 ","date":"2024.10.31","objectID":"/blog/categories/compile/lexer-re-automata/:4:0","tags":["compile"],"title":"Lexer Re Automata","uri":"/blog/categories/compile/lexer-re-automata/"},{"categories":["compile"],"content":"RE -\u003e NFA\r采用 Thompson 构造法，使得 $r \\Rightarrow NFA$，要求 $L(N(r)) = L(r)$，即两个语言等价。这里就是对于正则表达式语法的每个规则来定义自动机，然后最后将这些自动机按规则进行组合就得到了 NFA。 $N(r)$ 的性质以及 Thompson 构造法复杂度分析 $N(r)$ 的开始状态和接受状态均唯一 开始状态没有入边，接受状态没有出边 $N(r)$ 的状态数 $|S| \u003c 2 \\times |r|$（$|r|: r$ 中运算符和运算分量的总和） 每个状态最多有两个 $\\epsilon \\text{-}$ 入边与两个 $\\epsilon \\text{-}$ 出边 $\\forall a \\in \\Sigma$，每个状态最多有一个 $a \\text{-}$ 入边与一个 $a\\text{-}$ 出边 自动机构造如下： ","date":"2024.10.31","objectID":"/blog/categories/compile/lexer-re-automata/:4:1","tags":["compile"],"title":"Lexer Re Automata","uri":"/blog/categories/compile/lexer-re-automata/"},{"categories":["compile"],"content":"NFA -\u003e DFA\r原理\r采用子集构造法，也就是用 DFA 模拟 NFA。 下面就是从 NFA 到 DFA 的构造对应表，有了这张表就有了自动机。之所以是子集构造法，是因为构造出来的 DFA 对应于 NFA 的一个状态子集。同时这里因为在 NFA 中 10 是接受状态，所以在 DFA 中，对应的 E 也是接收状态。 形式化描述子集构造法\r这里根据上图的转化，会得到两个重要的公式： $\\epsilon$ 闭包：从状态 s 开始，只通过 $\\epsilon \\text{-}$ 转移可达的状态集合 $\\epsilon\\text{-closure}(s)={t\\in S_N|s\\xrightarrow{\\epsilon^*}t}$，这个公式的含义就是把 NFA 中的初始状态归结于 DFA 中的初始状态。上图中 NFA 的 ${0,1,2,4,7}$，它是初始状态，在 NFA 中，从 0 开始，通过 $\\epsilon$ 边进行连接的状态在 DFA 中都是初始状态。之后进行扩展操作 $\\epsilon \\text{-closure(T)} = \\bigcup_{s \\in T}\\epsilon \\text{-closure(s)}$，这个就是把上面的初始状态都添加在一起，转化为了集合形式，即状态集合，它为下面的 move 公式提供操作变量。 $\\text{move(T,a)} = \\bigcup_{s\\in T} \\delta(s,a)$，这个公式就是根据集合的当前状态，然后根据转移函数 $\\delta$，逐个查看集合中每个元素在同一个字符作用的目标元素是什么，最后将目标元素添加到新集合中，这个集合就是 DFA 中的下一个状态。 之后就可以形式化描述子集构造法：子集构造法($N \\rightarrow D$) 的原理： $$ \\begin{array}{l} N: (\\Sigma_N, S_N, n_0, \\delta_N, F_N) \\\\ D: (\\Sigma_D, S_D, d_0, \\delta_D, F_D) \\\\ \\Sigma_{D} = \\Sigma_{N} \\\\ S_{D} \\subseteq 2^{S_{N}} \\quad (\\forall s_{D} \\in S_{D} : s_{D} \\subseteq S_{N}) \\end{array} $$ 初始状态：$d_{0} = \\epsilon \\text{-closure}(n_{0})$ 状态转移：$\\forall a \\in \\Sigma_{D} : \\delta_{D}(s_{D}, a) = \\epsilon\\text{-closure}(\\operatorname{move}(s_{D}, a))$ 接受状态集：$F_{\\mathcal{D}} = { s_{D} \\in S_{\\mathcal{D}} \\mid \\exists f \\in F_N \\colon f \\in s_{D} }$ 子集构造法的复杂度分析：（$|S_N=n|$，下面的符号就是算法分析中的分析符号） $$\\left|S_{D}\\right| = \\Theta\\left(2^{n}\\right) = O\\left(2^{n}\\right) \\cap \\Omega\\left(2^{n}\\right)$$ 对于任何算法，最坏情况下，$|S_{D}| = \\Omega\\left(2^{n}\\right)$。 ","date":"2024.10.31","objectID":"/blog/categories/compile/lexer-re-automata/:4:2","tags":["compile"],"title":"Lexer Re Automata","uri":"/blog/categories/compile/lexer-re-automata/"},{"categories":["compile"],"content":"DFA最小化\r方法\r我们还是查看之前使用 NFA -\u003e DFA 的转换图来看，下面的 DFA 就是使用子集构造法将 NFA 转化而来的，毫无疑问，与上面的图相比，它不是最小的，所以这里需要探究的就是如何将 DFA 转化为最小化的形式。 这里DFA最小化算法基本思想：等价的状态可以合并。对于等价而言，如果存在某个能区分状态 s 与 t 的字符串，则称 s 与 t 是可区分的；否则，称 s 与 t 是等价的。这里的字符串 x 区分状态 s 与 t，就是指如果分别从 s 与 t 出发，沿着标号为 x 的路径到达的两个状态中只有一个是接受状态，则称区分了状态 s 与 t，也就是s 与 t 不等价。 所以状态等价就是说，对于两个状态而言，在任意同一个字符的驱动下从当前状态进行转换，转换后的状态也是等价的。它可以用下面的公式进行表示： $$ \\begin{array}{l} s \\sim t \\iff \\forall a \\in \\Sigma. \\left( (s \\xrightarrow{a} s’) \\land (t \\xrightarrow{a} t’) \\implies (s’ \\sim t’) \\right)\\\\ s \\nsim t \\iff \\exists a \\in \\Sigma. \\left( (s \\xrightarrow{a} s’) \\land (t \\xrightarrow{a} t’) \\land (s’ \\nsim t’) \\right) \\end{array} $$ 基于该定义，不断合并等价的状态，直到无法合并为止。但是我们的定义是一个递归的，不知道一开始要从什么地方入手，同时我们又得到所有的接受状态并不是等价的。所以这里采取的办法就是划分，利用反例公式 $s \\nsim t \\Longleftrightarrow \\exists a \\in \\Sigma. ( s \\xrightarrow{a} s’ ) \\land ( t \\xrightarrow{a} t’ ) \\land ( s’ \\nsim t’ )$ 进行划分，而非合并。也就是首先根据接受状态与非接受状态必定不等价先划分为两类 $\\Pi = {F, S \\setminus F}$，然后在这个基础上根据上面的反例公式进行分裂，直至再也无法划分为止，这里就到达了不动点，之后就是将同一等价类里的状态合并。 上面就是分裂的过程，在 $\\Pi_0$ 到 $\\Pi_1$ 的过程中，${A,B,C}$ 和 ${D}$ 在经过 b 进行传递的状态是不等价的，此时 D 转移到 E 上了，E 输出 $S \\setminus F$，所以不等价。之后的操作也是这样挑选字符看转移后的状态处于哪一个集合中，如果不在本身的集合，那么就是不等价，需要进行分裂。 上图就是最后的分裂之后再合并得到最小化 DFA 的转换。 注意\r需要注意处理\"死状态\"，也就是指向 ${ \\varnothing}$ 的一些没有画出来的边，在进行分裂时需要添加上，即${F, S \\setminus F, { \\varnothing }}$ 刚刚的算法不适用于 NFA 最小化，NFA最小化问题是 PSPACE-complete 的，复杂度很高。 ","date":"2024.10.31","objectID":"/blog/categories/compile/lexer-re-automata/:4:3","tags":["compile"],"title":"Lexer Re Automata","uri":"/blog/categories/compile/lexer-re-automata/"},{"categories":["compile"],"content":"DFA -\u003e 词法分析器\r这里对于词法分析器的构造，需要注意一下几个要求，然后按照之前使用 java 模拟的方法进行构造即可： 需要满足最前优先匹配和最长优先匹配，与此同时，因为需要生成词法分析器的特定目的，所以要保留各个 NFA 的接受状态的信息，表明匹配的是什么正则表达式 需要消除 “死状态”，避免词法分析器徒劳消耗输入流。如果加上死状态，那么词法分析器就有可能走这条路径，然后会进行一直匹配，最后匹配出的也是死状态，妨碍正确匹配。 进行模拟的过程如下图所示，和之前 java 模拟的过程一样。 最后需要注意初始划分需要考虑不同的词法单元。之前的划分按照接受状态和非接受状态进行划分，但是这里需要写词法分析器，所以最后的接收状态对应了不同的词法单元，所以也需要进一步划分为不同的集合。 ","date":"2024.10.31","objectID":"/blog/categories/compile/lexer-re-automata/:4:4","tags":["compile"],"title":"Lexer Re Automata","uri":"/blog/categories/compile/lexer-re-automata/"},{"categories":["programming"],"content":"这里是 python 使用技巧的记录，包括日常使用和数据之间的转换。 ","date":"2024.10.31","objectID":"/blog/categories/programming/python/:0:0","tags":["programming"],"title":"Some about Python","uri":"/blog/categories/programming/python/"},{"categories":["programming"],"content":"基础知识\r","date":"2024.10.31","objectID":"/blog/categories/programming/python/:1:0","tags":["programming"],"title":"Some about Python","uri":"/blog/categories/programming/python/"},{"categories":["programming"],"content":"字符串\r\"\"\" \"\"\" 可以存储数行字符串 str = \"\"\"learn python the smart way 2nd edition hello word\"\"\" 使用 enumerate() 可以获得元素的序号 for idx, c in enumerate(str): print(idx, c) str.split 会把字符串划分为一个列表，依照空格进行划分 for word in str.split(): print(word) str.splitlines 会把字符串划分为一个列表，依照\"\\n\"进行划分 for line in str.splitlines(): if(line.startswith(\"hello\")): # startswith print(line) ","date":"2024.10.31","objectID":"/blog/categories/programming/python/:1:1","tags":["programming"],"title":"Some about Python","uri":"/blog/categories/programming/python/"},{"categories":["programming"],"content":"函数\r接收不定长参数，*args 表示参数数目不定，可以看成一个元组，把第一个参数后面的参数当作元组中的元素 def add(x, *args): total = x for arg in args: total += arg return total 上面的函数不能使用关键词传入参数，要使用关键词 **kwargs，它表示参数数目不定，相当于一个字典，键和值对应于键值对 def add(x, **kwargs): total = x for arg, value in kwargs.items(): print(\"adding %s=%s\" % (arg,value)) total += value return total # 使用方法如下： def foo(*args, **kwargs): print(args, kwargs) add(1, 2, 3, 4) foo(2, 3, x='bar', z=10) map 方法生成序列，map(aFun, aSeq)，函数 aFun 应用到序列 aSeq 上的每一个元素上，返回一个列表，不管这个序列原来是什么类型。事实上，根据函数参数的多少，map 可以接受多组序列，将其对应的元素作为参数传入函数。 def square(a, b, c): return a**2 + b + c a = [1,2,3] b = (4, 5, 6) print(list(map(square, a, b, b))) ","date":"2024.10.31","objectID":"/blog/categories/programming/python/:1:2","tags":["programming"],"title":"Some about Python","uri":"/blog/categories/programming/python/"},{"categories":["programming"],"content":"文件读写\rpython 提供安全的 with 来进行文件读写，当 with 块的内容结束后，Python 会自动调用它的 close 方法，确保读写的安全。 模式 描述 r 只读。该文件必须已存在。 r+ 可读可写。该文件必须已存在，写为追加在文件内容末尾。 rb 表示以二进制方式读取文件。该文件必须已存在。 w 只写。打开即默认创建一个新文件，如果文件已存在，则覆盖写（即文件内原始数据会被新写入的数据清空覆盖）。 w+ 写读。打开创建新文件并写入数据，如果文件已存在，则覆盖写。 wb 表示以二进制写方式打开，只能写文件， 如果文件不存在，创建该文件；如果文件已存在，则覆盖写。 a 追加写。若打开的是已有文件则直接对已有文件操作，若打开文件不存在则创建新文件，只能执行写（追加在后面），不能读。 a+ 追加读写。打开文件方式与写入方式和a一样，但是可以读。需注意的是你若刚用a+打开一个文件，一般不能直接读取，因为此时光标已经是文件末尾，除非你把光标移动到初始位置或任意非末尾的位置。 import os os.remove('newfile.txt') with open('newfile.txt','w+') as f: for i in range(30): x = 1.0 / (i - 10) f.write('hello world: ' + str(i) + '\\n') ","date":"2024.10.31","objectID":"/blog/categories/programming/python/:1:3","tags":["programming"],"title":"Some about Python","uri":"/blog/categories/programming/python/"},{"categories":["programming"],"content":"其他\r通过 split 对 “,” 进行分割，使得一行可以输入多个值。 a, b = input().split(\",\") print(f\"a = {a}, b = {b}\") print 操作，默认每次输入后会换行，控制结尾的参数是 end，设置 end 把 “\\n” 替换成了 “//\"。同时它一次也可以输出多个内容，默认以空格分隔，这里控制分割的参数就是 sep，修改之后空格变成 “//\"。 print(\"data\", end=\"//\") print(\"Data\", \"whale\", sep=\"//\") ","date":"2024.10.31","objectID":"/blog/categories/programming/python/:1:4","tags":["programming"],"title":"Some about Python","uri":"/blog/categories/programming/python/"},{"categories":["programming"],"content":"数据转换\r这里强制自己使用byte类型，这样可以统一python的不同数据类型 ","date":"2024.10.31","objectID":"/blog/categories/programming/python/:2:0","tags":["programming"],"title":"Some about Python","uri":"/blog/categories/programming/python/"},{"categories":["programming"],"content":"AllToBytes\r字符串转化为 bytes，也可以直接在前面加 'b' 来转换 string = \"Hello World\" str_byte = bytes(string, 'utf-8') # -\u003e b'Hello World' 二进制字符串转化为 bytes hex_string = \"68 656c6c6f20776f726c64\" # 这里空格不会影响结果，但是需要是两个字符(68中间不能加空格)一组 hex_byte = bytes.fromhex(hex_string) # -\u003e b'hello world' # list(hex_byte) -\u003e [104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100] 长整型转换为 bytes，小端序方式 long_i = 6788912312 # 下面就是计算转化为16进制的字节数 int.to_bytes(long_i, (long_i.bit_length() + 7) // 8, byteorder=\"little\") # -\u003e b'\\xb8\\x94\\xa6\\x94\\x01' 十六进制数转化为 bytes，小端序方式 hex_int = 0x12345678 int_byte = int.to_bytes(hex_int, 4, byteorder='little') # -\u003e b'xV4\\x12' 整型列表转化为 bytes list_num = [0x12, 0x34, 0x56, 0x78] list_byte = bytes(list_num) # -\u003e b'\\x124Vx' 字节列表转化为 bytes，先转化为字符串，再转化 str_list = ['1', 'C', 'E', 'B', 'E', '0', '8', '9', '7', '4', 'A', '9', '6', '1', 'C', '5'] # 先转str再转byte bytes(\"\".join(str_list), encoding=\"utf-8\") # -\u003e b'1CEBE08974A961C5' ","date":"2024.10.31","objectID":"/blog/categories/programming/python/:2:1","tags":["programming"],"title":"Some about Python","uri":"/blog/categories/programming/python/"},{"categories":["programming"],"content":"AllToBytes\rbytes 转化为字符串 byte = b'Hello World' byte_str = str(byte, 'utf-8') # -\u003e 'Hello World' bytes 转化为十六进制字符串 byte = b'hello world' byte_hex = byte.hex() # -\u003e '68656c6c6f20776f726c64' bytes 转化为长整型，小端序 byte = b'\\xb8\\x94\\xa6\\x94\\x01' i = int.from_bytes(byte, byteorder='little') # -\u003e 6788912312 bytes 转化为十六进制整型 byte = b'xV4\\x12' int_num = int.from_bytes(byte, byteorder='little') # -\u003e 305419896 0x12345678 bytes 转化为整型列表 byte = b'\\x124Vx' list_num = list(byte) # -\u003e [18, 52, 86, 120] bytes 转化为字符串列表 byte = b'1CEBE08974A961C5' str_list = [str(byte[i:i + 2], 'utf-8') for i in range(0, len(byte), 2)] # -\u003e ['1C', 'EB', 'E0', '89', '74', 'A9', '61', 'C5'] ","date":"2024.10.31","objectID":"/blog/categories/programming/python/:2:2","tags":["programming"],"title":"Some about Python","uri":"/blog/categories/programming/python/"},{"categories":["programming"],"content":"其余转换处理\r转化为字符串 chr(a) # 将 int 类型的 a 根据其 ascii 码转化为 str 字符 hex(a) # 将 int 类型的 a 转化为其十六进制 str 类型 str(a) # 将所有类型的 a 按照其本身转化为 str 类型 str = a.decode() # 将 bytes 类型的 a 转化为 str 类型 转化为整型 # a 为 k 进制数，使用 int 将 k 进制数的 a 转化为十进制数 # # int(a) 直接将字符 a 转化为 int 类型，此时 a 必须为数字字符，注意：不是转化 为ascii 码，而是转化为数字类型，即值不变，类型改变 int(a,k) # 将 str 类型的十六进制数 a 转化为 int 类型(这里十六进制需要加上0x) eval(a) # 将字符类型的 a 按其 ascii 码转化为 int 类型 ord(a) ","date":"2024.10.31","objectID":"/blog/categories/programming/python/:2:3","tags":["programming"],"title":"Some about Python","uri":"/blog/categories/programming/python/"},{"categories":["programming"],"content":"数据处理\rstruct 模块可以解决 bytes 和其他二进制数据类型的转换。pack 函数把任意数据类型变成 bytes，unpack 把 bytes 变成相应的数据类型。这里的格式就是(format:str, v1, v2, …)，其中format对于后面的数据进行匹配，然后输出。 ","date":"2024.10.31","objectID":"/blog/categories/programming/python/:3:0","tags":["programming"],"title":"Some about Python","uri":"/blog/categories/programming/python/"},{"categories":["programming"],"content":"pack\rpack 函数把任意数据类型变成 bytes struct.pack('\u003cII', 10240099, 1767863401) # -\u003e b'\\x00\\x9c@ci_ti' 如果符合ascii的标准，就直接转化为字符 ","date":"2024.10.31","objectID":"/blog/categories/programming/python/:3:1","tags":["programming"],"title":"Some about Python","uri":"/blog/categories/programming/python/"},{"categories":["programming"],"content":"unpack\runpack 把 bytes 变成相应的数据类型 struct.unpack('\u003cI', b'it_i') # -\u003e (1767863401,) 这里只有一个符合 I 的规则，所以只有一个数据 ","date":"2024.10.31","objectID":"/blog/categories/programming/python/:3:2","tags":["programming"],"title":"Some about Python","uri":"/blog/categories/programming/python/"},{"categories":["programming"],"content":"数据格式\rformat 参数就是上面使用的描述符，struct 利用它可以指定使用大端序还是小端序来解析或者生成数据 Character Byte order Size Alignment @ native native native，凑足4个字节 = native standard none \u003c little-endian standard none \u003e big-endian standard none ! network(=big-endian) standard none 数据格式，用于匹配当前字符的数据 Format C Type Python type Standard size x pad byte no value c char string of length 1 1 b signed char integer 1 B unsigned char integer 1 ? _Bool bool 1 h short integer 2 H unsigned short integer 2 i int integer 4 I unsigned int integer 4 l long integer 4 L unsigned long integer 4 q long long integer 8 Q unsigned long long integer 8 f float float 4 d double float 8 s char[] string 1 p char[] string 1 P void * integer 0 ","date":"2024.10.31","objectID":"/blog/categories/programming/python/:3:3","tags":["programming"],"title":"Some about Python","uri":"/blog/categories/programming/python/"},{"categories":null,"content":"关于我\r在系统/软件安全领域学习的菜狗 有趣的事情总能吸引我，然后忘记正事 ","date":"2024.10.29","objectID":"/blog/about/:1:0","tags":null,"title":"About","uri":"/blog/about/"},{"categories":null,"content":"网址\rhttps://cztangt.github.io/blog/ https://github.com/czTangt ","date":"2024.10.29","objectID":"/blog/about/:2:0","tags":null,"title":"About","uri":"/blog/about/"},{"categories":null,"content":"联系方式\r渠道 信息 QQ Mjk3MzE3NDU5Mg== 微信 VDEzMjY0NzE4NjI5 邮箱 Y3ouVGFuZ3RAZ21haWwuY29t ","date":"2024.10.29","objectID":"/blog/about/:3:0","tags":null,"title":"About","uri":"/blog/about/"}]