[{"categories":["programming"],"content":"这里是 python 使用技巧的记录，包括日常使用和数据之间的转换。 ","date":"313120-100-319","objectID":"/blog/categories/programming/python/:0:0","tags":["programming"],"title":"Some about Python","uri":"/blog/categories/programming/python/"},{"categories":["programming"],"content":"基础知识\r","date":"313120-100-319","objectID":"/blog/categories/programming/python/:1:0","tags":["programming"],"title":"Some about Python","uri":"/blog/categories/programming/python/"},{"categories":["programming"],"content":"字符串\r\"\"\" \"\"\" 可以存储数行字符串 str = \"\"\"learn python the smart way 2nd edition hello word\"\"\" 使用 enumerate() 可以获得元素的序号 for idx, c in enumerate(str): print(idx, c) str.split 会把字符串划分为一个列表，依照空格进行划分 for word in str.split(): print(word) str.splitlines 会把字符串划分为一个列表，依照\"\\n\"进行划分 for line in str.splitlines(): if(line.startswith(\"hello\")): # startswith print(line) ","date":"313120-100-319","objectID":"/blog/categories/programming/python/:1:1","tags":["programming"],"title":"Some about Python","uri":"/blog/categories/programming/python/"},{"categories":["programming"],"content":"函数\r接收不定长参数，*args 表示参数数目不定，可以看成一个元组，把第一个参数后面的参数当作元组中的元素 def add(x, *args): total = x for arg in args: total += arg return total 上面的函数不能使用关键词传入参数，要使用关键词 **kwargs，它表示参数数目不定，相当于一个字典，键和值对应于键值对 def add(x, **kwargs): total = x for arg, value in kwargs.items(): print(\"adding %s=%s\" % (arg,value)) total += value return total # 使用方法如下： def foo(*args, **kwargs): print(args, kwargs) add(1, 2, 3, 4) foo(2, 3, x='bar', z=10) map 方法生成序列，map(aFun, aSeq)，函数 aFun 应用到序列 aSeq 上的每一个元素上，返回一个列表，不管这个序列原来是什么类型。事实上，根据函数参数的多少，map 可以接受多组序列，将其对应的元素作为参数传入函数。 def square(a, b, c): return a**2 + b + c a = [1,2,3] b = (4, 5, 6) print(list(map(square, a, b, b))) ","date":"313120-100-319","objectID":"/blog/categories/programming/python/:1:2","tags":["programming"],"title":"Some about Python","uri":"/blog/categories/programming/python/"},{"categories":["programming"],"content":"文件读写\rpython 提供安全的 with 来进行文件读写，当 with 块的内容结束后，Python 会自动调用它的 close 方法，确保读写的安全。 模式 描述 r 只读。该文件必须已存在。 r+ 可读可写。该文件必须已存在，写为追加在文件内容末尾。 rb 表示以二进制方式读取文件。该文件必须已存在。 w 只写。打开即默认创建一个新文件，如果文件已存在，则覆盖写（即文件内原始数据会被新写入的数据清空覆盖）。 w+ 写读。打开创建新文件并写入数据，如果文件已存在，则覆盖写。 wb 表示以二进制写方式打开，只能写文件， 如果文件不存在，创建该文件；如果文件已存在，则覆盖写。 a 追加写。若打开的是已有文件则直接对已有文件操作，若打开文件不存在则创建新文件，只能执行写（追加在后面），不能读。 a+ 追加读写。打开文件方式与写入方式和a一样，但是可以读。需注意的是你若刚用a+打开一个文件，一般不能直接读取，因为此时光标已经是文件末尾，除非你把光标移动到初始位置或任意非末尾的位置。 import os os.remove('newfile.txt') with open('newfile.txt','w+') as f: for i in range(30): x = 1.0 / (i - 10) f.write('hello world: ' + str(i) + '\\n') ","date":"313120-100-319","objectID":"/blog/categories/programming/python/:1:3","tags":["programming"],"title":"Some about Python","uri":"/blog/categories/programming/python/"},{"categories":["programming"],"content":"其他\r通过 split 对 “,” 进行分割，使得一行可以输入多个值。 a, b = input().split(\",\") print(f\"a = {a}, b = {b}\") print 操作，默认每次输入后会换行，控制结尾的参数是 end，设置 end 把 “\\n” 替换成了 “//\"。同时它一次也可以输出多个内容，默认以空格分隔，这里控制分割的参数就是 sep，修改之后空格变成 “//\"。 print(\"data\", end=\"//\") print(\"Data\", \"whale\", sep=\"//\") ","date":"313120-100-319","objectID":"/blog/categories/programming/python/:1:4","tags":["programming"],"title":"Some about Python","uri":"/blog/categories/programming/python/"},{"categories":["programming"],"content":"数据转换\r这里强制自己使用byte类型，这样可以统一python的不同数据类型 ","date":"313120-100-319","objectID":"/blog/categories/programming/python/:2:0","tags":["programming"],"title":"Some about Python","uri":"/blog/categories/programming/python/"},{"categories":["programming"],"content":"AllToBytes\r字符串转化为 bytes，也可以直接在前面加 'b' 来转换 string = \"Hello World\" str_byte = bytes(string, 'utf-8') # -\u003e b'Hello World' 二进制字符串转化为 bytes hex_string = \"68 656c6c6f20776f726c64\" # 这里空格不会影响结果，但是需要是两个字符(68中间不能加空格)一组 hex_byte = bytes.fromhex(hex_string) # -\u003e b'hello world' # list(hex_byte) -\u003e [104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100] 长整型转换为 bytes，小端序方式 long_i = 6788912312 # 下面就是计算转化为16进制的字节数 int.to_bytes(long_i, (long_i.bit_length() + 7) // 8, byteorder=\"little\") # -\u003e b'\\xb8\\x94\\xa6\\x94\\x01' 十六进制数转化为 bytes，小端序方式 hex_int = 0x12345678 int_byte = int.to_bytes(hex_int, 4, byteorder='little') # -\u003e b'xV4\\x12' 整型列表转化为 bytes list_num = [0x12, 0x34, 0x56, 0x78] list_byte = bytes(list_num) # -\u003e b'\\x124Vx' 字节列表转化为 bytes，先转化为字符串，再转化 str_list = ['1', 'C', 'E', 'B', 'E', '0', '8', '9', '7', '4', 'A', '9', '6', '1', 'C', '5'] # 先转str再转byte bytes(\"\".join(str_list), encoding=\"utf-8\") # -\u003e b'1CEBE08974A961C5' ","date":"313120-100-319","objectID":"/blog/categories/programming/python/:2:1","tags":["programming"],"title":"Some about Python","uri":"/blog/categories/programming/python/"},{"categories":["programming"],"content":"AllToBytes\rbytes 转化为字符串 byte = b'Hello World' byte_str = str(byte, 'utf-8') # -\u003e 'Hello World' bytes 转化为十六进制字符串 byte = b'hello world' byte_hex = byte.hex() # -\u003e '68656c6c6f20776f726c64' bytes 转化为长整型，小端序 byte = b'\\xb8\\x94\\xa6\\x94\\x01' i = int.from_bytes(byte, byteorder='little') # -\u003e 6788912312 bytes 转化为十六进制整型 byte = b'xV4\\x12' int_num = int.from_bytes(byte, byteorder='little') # -\u003e 305419896 0x12345678 bytes 转化为整型列表 byte = b'\\x124Vx' list_num = list(byte) # -\u003e [18, 52, 86, 120] bytes 转化为字符串列表 byte = b'1CEBE08974A961C5' str_list = [str(byte[i:i + 2], 'utf-8') for i in range(0, len(byte), 2)] # -\u003e ['1C', 'EB', 'E0', '89', '74', 'A9', '61', 'C5'] ","date":"313120-100-319","objectID":"/blog/categories/programming/python/:2:2","tags":["programming"],"title":"Some about Python","uri":"/blog/categories/programming/python/"},{"categories":["programming"],"content":"其余转换处理\r转化为字符串 chr(a) # 将 int 类型的 a 根据其 ascii 码转化为 str 字符 hex(a) # 将 int 类型的 a 转化为其十六进制 str 类型 str(a) # 将所有类型的 a 按照其本身转化为 str 类型 str = a.decode() # 将 bytes 类型的 a 转化为 str 类型 转化为整型 # a 为 k 进制数，使用 int 将 k 进制数的 a 转化为十进制数 # # int(a) 直接将字符 a 转化为 int 类型，此时 a 必须为数字字符，注意：不是转化 为ascii 码，而是转化为数字类型，即值不变，类型改变 int(a,k) # 将 str 类型的十六进制数 a 转化为 int 类型(这里十六进制需要加上0x) eval(a) # 将字符类型的 a 按其 ascii 码转化为 int 类型 ord(a) ","date":"313120-100-319","objectID":"/blog/categories/programming/python/:2:3","tags":["programming"],"title":"Some about Python","uri":"/blog/categories/programming/python/"},{"categories":["programming"],"content":"数据处理\rstruct 模块可以解决 bytes 和其他二进制数据类型的转换。pack 函数把任意数据类型变成 bytes，unpack 把 bytes 变成相应的数据类型。这里的格式就是(format:str, v1, v2, …)，其中format对于后面的数据进行匹配，然后输出。 ","date":"313120-100-319","objectID":"/blog/categories/programming/python/:3:0","tags":["programming"],"title":"Some about Python","uri":"/blog/categories/programming/python/"},{"categories":["programming"],"content":"pack\rpack 函数把任意数据类型变成 bytes struct.pack('\u003cII', 10240099, 1767863401) # -\u003e b'\\x00\\x9c@ci_ti' 如果符合ascii的标准，就直接转化为字符 ","date":"313120-100-319","objectID":"/blog/categories/programming/python/:3:1","tags":["programming"],"title":"Some about Python","uri":"/blog/categories/programming/python/"},{"categories":["programming"],"content":"unpack\runpack 把 bytes 变成相应的数据类型 struct.unpack('\u003cI', b'it_i') # -\u003e (1767863401,) 这里只有一个符合 I 的规则，所以只有一个数据 ","date":"313120-100-319","objectID":"/blog/categories/programming/python/:3:2","tags":["programming"],"title":"Some about Python","uri":"/blog/categories/programming/python/"},{"categories":["programming"],"content":"数据格式\rformat 参数就是上面使用的描述符，struct 利用它可以指定使用大端序还是小端序来解析或者生成数据 Character Byte order Size Alignment @ native native native，凑足4个字节 = native standard none \u003c little-endian standard none \u003e big-endian standard none ! network(=big-endian) standard none 数据格式，用于匹配当前字符的数据 Format C Type Python type Standard size x pad byte no value c char string of length 1 1 b signed char integer 1 B unsigned char integer 1 ? _Bool bool 1 h short integer 2 H unsigned short integer 2 i int integer 4 I unsigned int integer 4 l long integer 4 L unsigned long integer 4 q long long integer 8 Q unsigned long long integer 8 f float float 4 d double float 8 s char[] string 1 p char[] string 1 P void * integer 0 ","date":"313120-100-319","objectID":"/blog/categories/programming/python/:3:3","tags":["programming"],"title":"Some about Python","uri":"/blog/categories/programming/python/"},{"categories":null,"content":"关于我\r在系统/软件安全领域学习的菜狗 有趣的事情总能吸引我，然后忘记正事 ","date":"292945-100-299","objectID":"/blog/about/:1:0","tags":null,"title":"About","uri":"/blog/about/"},{"categories":null,"content":"网址\rhttps://cztangt.github.io/blog/ https://github.com/czTangt ","date":"292945-100-299","objectID":"/blog/about/:2:0","tags":null,"title":"About","uri":"/blog/about/"},{"categories":null,"content":"联系方式\r渠道 信息 QQ Mjk3MzE3NDU5Mg== 微信 VDEzMjY0NzE4NjI5 邮箱 Y3ouVGFuZ3RAZ21haWwuY29t ","date":"292945-100-299","objectID":"/blog/about/:3:0","tags":null,"title":"About","uri":"/blog/about/"}]