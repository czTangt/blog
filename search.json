[{"categories":["config"],"content":"自己对于 FixIt 主题的一些配置 ","date":"2024.11.6","objectID":"/blog/categories/config/fixit/:0:0","tags":["config"],"title":"Fixit","uri":"/blog/categories/config/fixit/"},{"categories":["config"],"content":"大致流程\r这里我使用的就是Git 子模块的安装方式，更详细的流程参照这篇快速上手。在必要的配置后，博客就可以进行本地浏览了。之后我使用 Github Action 的方式，将本地博客的所有文件上传到一个私密仓库，之后创建 Github Action 将通过 hugo --gc --minify 命令构建的 public 目录上传到另一个公开仓库 blog 中，这样就可以设置静态网站进行博客访问了，具体可以参考Huogo 主题配置。这样博客基本上就好了，可以开始额外的操作了。 ","date":"2024.11.6","objectID":"/blog/categories/config/fixit/:1:0","tags":["config"],"title":"Fixit","uri":"/blog/categories/config/fixit/"},{"categories":["config"],"content":"图片自适应\r我使用的图片都是存储在图床中的，使用的就是 Markdown 的经典语法。但是它在 FixIt 的渲染中会左对齐，有时还会在图片后面跟随文字，感官很不好，所以思考怎么进行改进。在参考FixIt主题使用lightgallery自适应显示图片之后，自己进行了调整，达到了现在的效果。 这里主要参照上述参考文章的两种尝试，采用 lightgallery 来呈现图片。我参照 FixIt配置篇 将 lightgallery 设置为 \"force\" 但是如果没有 alt 和 title 属性，我的图片不会按照画廊形式呈现，所以我只能另辟蹊径。因为我使用 PicGo 进行图床配置，刚好它支持修改本地输出图片链接的格式，因此我修改PicGo的配置，把 Custom Output Format 配置为![${uploadedName}](${url} \"${uploadedName}\")。这样它会自己填充 alt 和 title，我只需要按照自身需求修改 alt 属性即可。 另外点击图片之后会显示 alt 和 title 两个信息，所以打开 F12 进行观察，发现第一行来自标签 \u003ch2\u003e，也是 alt 属性，第二行来自标签 \u003cp\u003e，是 title 属性。这部分都是在 themes/layouts/partials/plugin/image.html 中，所以直接修改主题文件，把这里的 \u003cp\u003e 删除，然后 \u003ch2\u003e 移动到中间，这样渲染的时候只会在下面出现 alt 属性了，放大图片和鼠标移动到图片上才会看到 title 属性。 修改配置文件\r","date":"2024.11.6","objectID":"/blog/categories/config/fixit/:2:0","tags":["config"],"title":"Fixit","uri":"/blog/categories/config/fixit/"},{"categories":["config"],"content":"GitHub 提交记录贪吃蛇动画\r参照GitHub 提交记录贪食蛇动画进行配置，不过我将 Github Action 写在了同名仓库中了，这样就少创建了一个仓库，其他都是按照参考文章所述的进行配置即可。插一嘴，本来想把 github-metrics.svg 单独放在一个分支中，但是不熟悉自动化部署脚本，配置了一会儿发现总是部署失败，所以直接使用GitHub 个人主页美化教程来进行配置了。 ","date":"2024.11.6","objectID":"/blog/categories/config/fixit/:3:0","tags":["config"],"title":"Fixit","uri":"/blog/categories/config/fixit/"},{"categories":["config"],"content":"配置文章修改时间\rFixit 的 frontmatter 有一个属性 lastmod，它就是文章最后修改时间，一开始的配置不知道有没有效果，但是还是参照 loveit主题配置 之后，形成了现在的配置。 当前我的配置就是在 atchetypes/default.md 文件中，配置 lastmod: {{ .Date }}。之后 config/_default/hugo.toml 中配置 enableGitInfo = true， 同时在 config/_default/params.toml 中，找到 [gitInfo] 选项，设置 repo 为自己 public 文件夹发布的仓库地址。 ","date":"2024.11.6","objectID":"/blog/categories/config/fixit/:4:0","tags":["config"],"title":"Fixit","uri":"/blog/categories/config/fixit/"},{"categories":["config"],"content":"补充\r","date":"2024.11.6","objectID":"/blog/categories/config/fixit/:5:0","tags":["config"],"title":"Fixit","uri":"/blog/categories/config/fixit/"},{"categories":["config"],"content":"网站图标\r对于网站图标实在是束手无策，一开始采用官网配置，但是给的利用网站不能生成符合要求的一系列文件，同时把生成文件都放在/static目录下，最后会把这些文件生成在/public根目录下，很不喜，所以放弃了这种方法。后来尝试和 author 的 avatar 属性配置一样，把 svg 图片放在images目录下，但是展示不出来。最后看到别人文章，发现直接使用图床的图片可以生成，所以我现在也是利用这样的方式展示网站图标。 ","date":"2024.11.6","objectID":"/blog/categories/config/fixit/:5:1","tags":["config"],"title":"Fixit","uri":"/blog/categories/config/fixit/"},{"categories":["programming"],"content":"学习 C++ 的使用，主要区分 C++ 和 C 的区别。 ","date":"2024.11.6","objectID":"/blog/categories/programming/cpp/:0:0","tags":["programming"],"title":"C 拾遗和 C++ 学习","uri":"/blog/categories/programming/cpp/"},{"categories":["programming"],"content":"头文件\rC++ 包含标准 C 语言头文件，对于原本 C 的头文件，C++ 有两种方式进行引用，一种是原有的方式（后面跟 .h），一种就是去掉 .h，在库前面添加一个 c 标识这是原本 C 的头文件。对于自己写的头文件还是原方式进行引用，即 \"\"。 #include \u003ciostream\u003e // 基本输入输出 #include \u003ccstdio\u003e // 在原来 C 语言的库前面加一个 c，去掉 .h #include \u003cstdio.h\u003e // 采用原有方式进行引用 #include \"myFile.h\" // 自己的文件，采用原有方式引用 ","date":"2024.11.6","objectID":"/blog/categories/programming/cpp/:1:0","tags":["programming"],"title":"C 拾遗和 C++ 学习","uri":"/blog/categories/programming/cpp/"},{"categories":["programming"],"content":"命名空间\r","date":"2024.11.6","objectID":"/blog/categories/programming/cpp/:2:0","tags":["programming"],"title":"C 拾遗和 C++ 学习","uri":"/blog/categories/programming/cpp/"},{"categories":["programming"],"content":"基础知识\r命名空间增加了标识符的使用率，减少因为命名产生的冲突。对于命名空间而言，其中的变量和函数等都是属于自己这个空间的，需要通过标识空间名来指明数据的归属，这样可以使得不同命名空间可以存在同样名称的数据，它们之间不会产生冲突。 声明命名空间：namespace 空间名{}，命名空间的声明不能写在函数中 访问数据：空间名::空间中的成员名 省略前缀的方式：using namespace 空间名，表示从这个地方开始，后面都可以省略前缀。 #include \u003ciostream\u003e using namespace std; // 标准命名空间 namespace A{ int num = 1; void print(){ printf(\"A\\n\"); } } namespace B{ int num = 2; void print(){ printf(\"A\\n\"); } } namespace C{ namespace D{ int cd_num = 3; } } int g_num = 1001; int main(){ // 使用省略前缀的方式，可以直接使用其中的函数 cout \u003c\u003c \"命名空间\" \u003c\u003c endl; std::cout\u003c\u003c \"命名空间\" \u003c\u003c endl; // 不同命名空间访问数据 A::num = 2; B::print(); // 省略前缀方式访问数据 using namespace A; num = 3; // A 命名空间数据 using namespace B; B::num = 4; // B 命名空间数据，省略前缀需要注意二义性的问题，所以还需要标识命名空间 // 嵌套命名空间 C::D::cd_num = 5; using namespace C::D; cd_num = 5; // :: 为作用域分辨符，同时可以用于指明全局变量 int g_num = 11; printf(\"num %d\\n\", g_num); // 变量访问采用就近原则，这里就是访问上面的局部变量，返回 11 printf(\"num %d\\n\", ::g_num); // 使用作用域分辨符，指明访问全局变量，返回 1001 return 0; } ","date":"2024.11.6","objectID":"/blog/categories/programming/cpp/:2:1","tags":["programming"],"title":"C 拾遗和 C++ 学习","uri":"/blog/categories/programming/cpp/"},{"categories":["programming"],"content":"内联命名空间\r对于嵌套命名空间，访问需要使用多层空间名，但是可以采用内联命名空间的方式直接进行访问。 #include \u003ciostream\u003e using namespace std; namespace Version{ inline namespace v2017{ void showVersion(){ cout \u003c\u003c \"v2017\" \u003c\u003c endl; } } namespace v2020{ void showVersion(){ cout \u003c\u003c \"v2020\" \u003c\u003c endl; } } } int main(){ // 上面采用内联命名空间，即添加了 inline，设置了默认的情况，使得下面的两个语句效果等价。 // Version::v2017::showVersion(); Version::showVersion(); } ","date":"2024.11.6","objectID":"/blog/categories/programming/cpp/:2:2","tags":["programming"],"title":"C 拾遗和 C++ 学习","uri":"/blog/categories/programming/cpp/"},{"categories":["programming"],"content":"动态内存分配\rC 的动态内存采用函数 malloc calloc realloc free，具体可以从 堆基础 获取详细介绍。而 C++ 使用 new delete 操作符进行动态内存分配。 #include \u003ciostream\u003e using namespace std; void showArr(int* arr, int len){ for (int i = 0; i \u003c len; i ++){ cout \u003c\u003c arr[i] \u003c\u003c \" \"; } cout \u003c\u003c endl; } int main(){ // C 内存分配 int *p = (int*)calloc(5, sizeof(int)); showArr(p, 5); // calloc 会初始化为 0，所以可以直接打印 free(p); p = nullptr; // free 只是清除空间，还需要制空指针，不然就是一个野指针 // C++ 内存分配 int* page = new int; // 申请一个 int *page = 19; // 这里简单 new 不会初始化为 0，需要自行设置值 // int* page = new int(19); // 可以使用 c++ 的括号赋值直接进行赋值 cout \u003c\u003c *page \u003c\u003c endl; delete page; page = nullptr; page = new int[29]; // 申请一个数组，这里也不会初始化，所以可以采用下面的括号赋值，后面自动初始化为 0；或者使用 for 循环进行赋值 // page = new int[29]{1, 2, 3, 7, 12, 12}; showArr(page, 29); delete[] page; page = nullptr; return 0; } ","date":"2024.11.6","objectID":"/blog/categories/programming/cpp/:3:0","tags":["programming"],"title":"C 拾遗和 C++ 学习","uri":"/blog/categories/programming/cpp/"},{"categories":["programming"],"content":"枚举类型\rC 和 C++ 都提供了枚举类型，两者有一定的区别。这里主要就是 C++ 的枚举类型，不涉及 C 的。 ","date":"2024.11.6","objectID":"/blog/categories/programming/cpp/:4:0","tags":["programming"],"title":"C 拾遗和 C++ 学习","uri":"/blog/categories/programming/cpp/"},{"categories":["programming"],"content":"enum 枚举类型\rC++ 中的 enum 就是枚举类型的标识符，它只允许赋值枚举值；同时枚举元素会暴露在外部作用域，两个不同枚举类型若是含有相同枚举元素，会产生冲突；不同的枚举可以直接进行比较 // 定义 enum WEEK {MON, TUE, WED, THI, FIR, SAT, SUN}; enum SHAPE {CIRCLE, RECT, POINT, LINE}; // 只允许赋值枚举值，前面的 enum 不进行添加就可以使用 WEEK today = 3; // 错误 error C2440：“初始化”：无法从“int”转换为“main::WEEK” today = CIRCLE; // 错误 error C2440：“=”：无法从“main::SHAPE”转换为“main::WEEK” // 枚举元素暴露在外部作用域 enumc OTHER {RECT}; // 错误 error C2365：“RECT”：重定义；以前的定义是“枚举数” Int RECT = 12; // 错误同上，但是可以通过枚举名访问指定的枚举属性 OTHER::RECT; // 正确 // 不同类型的枚举也可以直接比较 if (CIRCLE == MON){ cout \u003c\u003c \"yes\" \u003c\u003c endl; } ","date":"2024.11.6","objectID":"/blog/categories/programming/cpp/:4:1","tags":["programming"],"title":"C 拾遗和 C++ 学习","uri":"/blog/categories/programming/cpp/"},{"categories":["programming"],"content":"enum class 强枚举类型\r这里强枚举类型不会将枚举元素暴露在外部作用域，必须通过枚举名去访问；同时不相关的两个枚举类型不能直接比较，编译报错 // 定义 enum class WEEK {MON, TUE, WED, THI, FIR, SAT, SUN}; enum class SHAPE {CIRCLE, RECT, POINT, LINE}; // 不暴露在外部作用域 cout \u003c\u003c SHAPCE::RECT \u003c\u003c endl; // 输出 1 // 不相关的两个枚举类型不能直接比较 if (SHAPCE::RECT == WEEK::MON){ // error c2676：二进制“==\"：“main::SHAPE\"不定义该运算符或到预定义运算符可接收的类型的转换 cout \u003c\u003c \"yes\" \u003c\u003c endl; } ","date":"2024.11.6","objectID":"/blog/categories/programming/cpp/:4:2","tags":["programming"],"title":"C 拾遗和 C++ 学习","uri":"/blog/categories/programming/cpp/"},{"categories":["programming"],"content":"内联函数\r函数调用时，需要跳转到函数的地址去执行，执行完成后返回到被调用函数，比较费时，因此，C++中提供了一种操作方式，允许编译时直接把函数替换到调用处，即内联函数，它没有普通函数调用时的额外开销（压栈，跳转，返回）。在函数前面加上 inline 申明为内联函数。 内联函数声明时 inline 关键字必须和函数定义结合在一起，否则编译器会直接忽略内联请求。 C++ 编译器不一定准许函数的内联请求（只是对编译器的请求，因此编译器可以拒绝） 现代C++编译器能够进行编译优化，因此一些函数即使没有 inline 声明，也可能被编译器内联编译 #include \u003ciostream\u003e using namespace std; // 宏定义，会在编译的时候（预处理）进行替换，节省空间和时间，效率高，不会类型检查 #define MAX(a, b) a \u003e b ? a : b; // 内联函数，用来替换宏定义。inline 是关键字 /* 1. 不能存在任何形式的循环语句，不能存在过多的条件判断语句 2. 函数体不能过于庞大，不能对函数进行取址操作 3. 编译器对于内联函数的限制并不是绝对的，内联函数相对于普通函数的优势只是省去了函数调用时压栈，跳转和返回的开销。因此，当函数体的执行开销远大于压栈，跳转和返回所用的开销时，那么内联将无意义。 */ inline int mmax(int a, int b){ return a \u003e b ? a : b; } ","date":"2024.11.6","objectID":"/blog/categories/programming/cpp/:5:0","tags":["programming"],"title":"C 拾遗和 C++ 学习","uri":"/blog/categories/programming/cpp/"},{"categories":["programming"],"content":"强制类型转化\rC 风格的强制类型转换很简单，据使用 Type b = (Type)a 形式进行转换。但是 C 风格的类型转换有不少缺点：万物皆可转，不容易区分，不容易查找代码。因此 C++ 提供了四种类型转换操作符来应对不同场合。 类型转换操作符 作用 static_cast 静态类型转换，编译器做类型检查，基本类型能转换，指针不能 reinterpret_cast 重新解释类型 const_cast 去const属性 dynamic_cast 动态类型转换，运行时检查类型安全（转换失败返回nullptr）如子类和父类之间的多态类型转换 #include \u003ciostream\u003e using namespace std; class Animal { public: virtual void cry() = 0; virtual ~Animal(){} }; class Dog:public Animal { public: void cry() override{ cout \u003c\u003c \"狗吠\" \u003c\u003c endl; } void seeHome(){ cout \u003c\u003c \"看家\" \u003c\u003c endl; } }; class Cat:public Animal { public: void cry() override{ cout \u003c\u003c \"猫叫\" \u003c\u003c endl; } void catchMouse(){ cout \u003c\u003c \"抓老鼠\" \u003c\u003c endl; } }; void obj(Animal* base){ base-\u003ecry(); // Dog：看家 // ((Dog*)base)-\u003eseeHome(); // 这种行为，不会根据传入参数的实际对象进行相应函数调用，而是只要转换就进行调用，也就是这样没有安全检查 Dog* dog = dynamic_cast\u003cDog*\u003e(base); // 这里运行时进行判断，如果转换成功返回子类所在地址，转换失败返回空指针 if (dog) { dog-\u003eseeHome(); } // Cat：抓老鼠 //((Cat*)base)-\u003ecatchMouse(); Cat* cat = dynamic_cast\u003cCat*\u003e(base); if (cat) { cat-\u003ecatchMouse(); } } int main(){ // 1. static_cast 类似 C 风格的强制转换，进行无条件转换，静态类型转换。 /* 基本数据类型转换，enum，struct，int，char，float 等。static_cast 不能进行无关类型（如非基类和子类）指针之间的转换。 可以用于 void* 和其他指针类型之间的转换（但是不能用于非 void 指针之间的转换） 不能用于两个不相关类型的转换，如 int 和 int* 之间的转换，虽然二者都是四个字节，但他们一个表示数据，一个表示地址，类型不相关，无法进行转换。 */ int age = 10; // double d = age; // 隐式类型转换 // double d = (double)age; // C 风格转换 double d = static_cast\u003cdouble\u003e(age); int* p = \u0026age; // double* pd = (double*)p; // 正确 // double* pd = static_cast\u003cdouble\u003e(p); // error C2440：“static cast”：无法从“int *”转换为“double *” void* pv = static_cast\u003cvoid*\u003e(p); // 正确 double* pdd = static_cast\u003cdouble*\u003e(pv); // 正确 // 2. reinterpret_cast 专门用来转换指针 double *pd = reinterpret_cast\u003cdouble*\u003e(p); // 正确 // 3. const_cast 去掉 const 属性 const int week = 7; // week = 5; // 错误，不能直接修改常量 int\u0026 rint = const_cast\u003cint\u0026\u003e(week); rint = 5; // 正确，可以去掉 const 属性，但是原先的值没有进行修改 // 4. dynamic_cast 把父类指针转为子类指针（判断父类指针指向的是哪个子类对象） Animal* pdog = new Dog; Animal* pcat = new Cat; obj(pdog); obj(pcat); } ","date":"2024.11.6","objectID":"/blog/categories/programming/cpp/:6:0","tags":["programming"],"title":"C 拾遗和 C++ 学习","uri":"/blog/categories/programming/cpp/"},{"categories":["config"],"content":"关于 Android Studio 的使用和配置。 ","date":"2024.11.5","objectID":"/blog/categories/config/android-studio/:0:0","tags":["config"],"title":"Android Studio配置","uri":"/blog/categories/config/android-studio/"},{"categories":["config"],"content":"Gradle下载配置\r直接更换国内腾讯 镜像源，打开 gradle - wrapper -gradle-weapper.properties 进行更改。然后点击 Sync Now 进行同步。参考-\u003e Android导入项目时Gradle下载速度慢_导入gradle项目特别慢 #Sun Feb 25 20:22:32 GMT+08:00 2024 distributionBase=GRADLE_USER_HOME distributionPath=wrapper/dists distributionUrl=https\\://mirrors.cloud.tencent.com/gradle/gradle-8.2-bin.zip # 这里就对应替换为腾讯的镜像地址 zipStoreBase=GRADLE_USER_HOME zipStorePath=wrapper/dists 但是这样也是很慢，还是得等，有时候还会突然跑到源地址去下载，搞不明白。(后续补充：有时候改了国内源，然后停止加载zip文件，之后重试一下就快很多了) ","date":"2024.11.5","objectID":"/blog/categories/config/android-studio/:1:0","tags":["config"],"title":"Android Studio配置","uri":"/blog/categories/config/android-studio/"},{"categories":["config"],"content":"新版 AS 添加依赖\r这里是在 settings.gradle.kts 文件中添加 maven 仓库，然后在 app 的 build.gradle.kts 文件中添加依赖。查看这里Android Studio | 2022.3.1版本解决创建项目下载gradle缓慢问题 // settings.gradle.kts 文件中 dependencyResolutionManagement { repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS) repositories { google() mavenCentral() maven { url = uri(\"https://jitpack.io\") }// as改版后的新添加方式 } } // build.gradle.kts 文件中 dependencies { implementation(\"com.github.Hitomis:CircleMenu:v1.1.0\") // as改版后的新添加方式 } ","date":"2024.11.5","objectID":"/blog/categories/config/android-studio/:2:0","tags":["config"],"title":"Android Studio配置","uri":"/blog/categories/config/android-studio/"},{"categories":["config"],"content":"SD卡读写权限\r对于低版本 sdk，只需要以下权限即可(在AndroidManifest.xml中修改)，在manifest标签中添加 \u003cuses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"\u003e\u003c/uses-permission\u003e \u003cuses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"\u003e\u003c/uses-permission\u003e 而对于高版本的 sdk，这里是34，则需要添加东西。新加入的在application标签中添加 \u003cuses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"\u003e\u003c/uses-permission\u003e \u003cuses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"\u003e\u003c/uses-permission\u003e \u003cuses-permission android:name=\"android.permission.MANAGE_EXTERNAL_STORAGE\"\u003e\u003c/uses-permission\u003e android:requestLegacyExternalStorage=\"true\" ","date":"2024.11.5","objectID":"/blog/categories/config/android-studio/:3:0","tags":["config"],"title":"Android Studio配置","uri":"/blog/categories/config/android-studio/"},{"categories":["config"],"content":"dataBinding使用\r刚开始创建的 Launch Activity 不用理会，但是对于新增加的Activity，想要使用 dataBinding 功能，就需要先在 build.gradle.kts文件中添加下面代码： android { ...... buildFeatures { dataBinding = true // 确保这里启用了数据绑定 } } 然后在相关 xml 文件中，对准 androidx.constraintlayout.widget.ConstraintLayout按下alt + enter 转化为 databinding 的模式。这样后续的 activity 才可以使用并编译apk成功。 ","date":"2024.11.5","objectID":"/blog/categories/config/android-studio/:4:0","tags":["config"],"title":"Android Studio配置","uri":"/blog/categories/config/android-studio/"},{"categories":["config"],"content":"图片导入\r资源主要就是存放在 res 目录下，如下表所示各个目录的作用。 目录 作用 drawable 存放所有的图片及图标配置（xml文件展示） layout 布局，创建一个Activity一般会同步创建一个布局。 mipmap 存放各种分辨率的图标，平常用的就是 xxhdpi values 一些固定的配置，例如值，主题等 这里 drawable 存放的东西大多就是 图标的配置，在 As 中可以利用 File → New → Android Resource File 来生成一个配置文件，例如背景之类的可以重复使用。 同时使用File → New → Image Asset 可以创建 app 应用的图标，提供 svg 图片即可自动创建。使用File → New → Vector Asset 则是创建图片，将一个 svg 格式的图片转化为 xml 文件形式，然后供 ImageView 等控件使用。 ","date":"2024.11.5","objectID":"/blog/categories/config/android-studio/:5:0","tags":["config"],"title":"Android Studio配置","uri":"/blog/categories/config/android-studio/"},{"categories":["config"],"content":"So文件生成\r","date":"2024.11.5","objectID":"/blog/categories/config/android-studio/:6:0","tags":["config"],"title":"Android Studio配置","uri":"/blog/categories/config/android-studio/"},{"categories":["config"],"content":"添加新文件\r对于头文件 .h 首先在 cpp 目录下创建相应文件，然后在 CmakeLists.txt 文件中添加下面的代码 include_directories( basic.h ) 对于文件 .cpp 在 cpp 目录下创建，然后在 CmakeLists.txt 文件中的 add_libraty 添加新创建的 .cpp文件。这样多个 .cpp 文件就会编译为一个 so 库。 add_library(${CMAKE_PROJECT_NAME} SHARED # List C/C++ source files with relative paths to this CMakeLists.txt. native-lib.cpp checkfrida.cpp) 添加文件\r","date":"2024.11.5","objectID":"/blog/categories/config/android-studio/:6:1","tags":["config"],"title":"Android Studio配置","uri":"/blog/categories/config/android-studio/"},{"categories":["config"],"content":"编译多个so文件\r这里就是再添加一个 add_library 文件，这样就可以编译为多个了。 add_library( # so 文件的名字 checkroot # 共享库 SHARED # List C/C++ source files with relative paths to this CMakeLists.txt. checkroot.cpp) 编译多个文件\r","date":"2024.11.5","objectID":"/blog/categories/config/android-studio/:6:2","tags":["config"],"title":"Android Studio配置","uri":"/blog/categories/config/android-studio/"},{"categories":["config"],"content":"引入第三方库\r使用第三方库的函数 这里就是利用 target_link_libraries 进行引用，注意对于每一个so文件，都需要进行引用操作。这里上面的是默认的，要是能在 checkroot.cpp 文件中使用 log，那么就需要自己手动进行引用了。 target_link_libraries( checkroot # List libraries link to the target library android log ) 引入库\r","date":"2024.11.5","objectID":"/blog/categories/config/android-studio/:6:3","tags":["config"],"title":"Android Studio配置","uri":"/blog/categories/config/android-studio/"},{"categories":["config"],"content":"使用不同架构\rAs 进行了改版，所以之前的方式不能使用了。这里是在 app 的 build.gradle.kts 文件中添加。下面展示了两种方式。 android { ... defaultConfig { ... ndk { // 第一种方式 abiFilters.addAll(arrayOf(\"arm64-v8a\", \"x86_64\")) // 第二种方式 //abiFilters.add(\"arm64-v8a\") //abiFilters.add(\"x86_64\") //abiFilters.add(\"armeabi-v7a\") //abiFilters.add(\"x86\") } } } ","date":"2024.11.5","objectID":"/blog/categories/config/android-studio/:6:4","tags":["config"],"title":"Android Studio配置","uri":"/blog/categories/config/android-studio/"},{"categories":["config"],"content":"相关操作\r","date":"2024.11.5","objectID":"/blog/categories/config/android-studio/:7:0","tags":["config"],"title":"Android Studio配置","uri":"/blog/categories/config/android-studio/"},{"categories":["config"],"content":"存储空间管理\r移动 .gradle 到指定位置 将 .gradle文件 从C盘移动到D盘，这里同时还需要相应修改 idea.plugins.path 和 idea.log.path 移动 .android 到指定位置 解决方案 ","date":"2024.11.5","objectID":"/blog/categories/config/android-studio/:7:1","tags":["config"],"title":"Android Studio配置","uri":"/blog/categories/config/android-studio/"},{"categories":["config"],"content":"生成apk\rbuild -\u003e Generate Signed Bundle or APK：选择APK，然后创建key（注意需要路径完整），之后再选择 release 即可 生成的 app-debug.apk 在路径 /app/build/outputs/apk/debug/ 下面，或者在 /app/build/intermediates/apk/debug/ 目录下。这里不知道是什么的变化引起的生成存放目录的变化。 build → Generate Signed Bundle or APK 可以生成签名后的 apk（release版本），它存放在和 debug类似的目录下。这里我的 vivo 手机不能使用 debug 版本，只能下载 release 版本。 ","date":"2024.11.5","objectID":"/blog/categories/config/android-studio/:7:2","tags":["config"],"title":"Android Studio配置","uri":"/blog/categories/config/android-studio/"},{"categories":["config"],"content":"报错汇总\r遇到问题 Cannot use connection to Gradle distribution 'https://mirrors.cloud.tencent.com/gradle/gradle-8.2-bin.zip' as it has been stopped. 这里直接关闭项目，再重新打开即可。 Error running 'app': Default Activity not found 这里修改 configuration，更改 Launch Options -\u003e Launch:nothing android studio怎么运行没有activity的service、broadcastReceiver、cotentProvicer等 日志不能在 As 中显示 检查算法助手有没有 hook 对应程序，如果存在，那么它好像开机自启，自动将日志捕获了。关闭应用 hook 就可以显示日志了 ","date":"2024.11.5","objectID":"/blog/categories/config/android-studio/:8:0","tags":["config"],"title":"Android Studio配置","uri":"/blog/categories/config/android-studio/"},{"categories":["config"],"content":"一些关于 git 的操作 git流程\r","date":"2024.11.1","objectID":"/blog/categories/config/git/:0:0","tags":["config"],"title":"Some about Git","uri":"/blog/categories/config/git/"},{"categories":["config"],"content":"相关命令\r# 本地仓库初始化 git init # 将文件提交到暂存区 git add [file name] git add . # 添加全部修改和新增文件 # 将文件提交到本地仓库 git commit [file name] git commit -m \"commit information\" [file name] git commit -m \"commit inforamtion\" # 提交全部到本地仓库 # 添加远程仓库，这里是因为存在多个 git 用户所进行的配置，正常为 git@github:czTangt/blog.git git remote add origin git@github_czTangt:czTangt/blog.git # 提交到远程仓库 git push -u origin [branch name] git push -f # 强制提交 # 分支操作 git checkout [branch name] # 切换分支 git branch -a # 查看所有分支 git checkout -b local_dev origin/remote_dev # 创建本地分支并于远程分支连接 git push origin --delete remote_dev # 删除远程分支 ","date":"2024.11.1","objectID":"/blog/categories/config/git/:1:0","tags":["config"],"title":"Some about Git","uri":"/blog/categories/config/git/"},{"categories":["config"],"content":"文件修改\r对于 git 而言，git add . 会将所有修改和新增的文件信息提交到暂存区，之后使用 git commit -m \"xxx\" 会将暂存区的文件信息提交到本地仓库。但是这种方法是对于新增和修改的文件而言，对于删除的文件信息不会进行更新，所以可以采用两种方案： 使用 git rm xxx 一个一个手动删除文件（rm 命令没有办法使用 git rm . 一起更新全部的文件删除信息），之后这些文件删除信息就提交到暂存区了，后续就可以继续使用 git commit -m \"xxx\" 来将代码提交到本地仓库 使用 git commit -am 命令，该命令会在提交到本地仓库时，先更新修改和删除的文件信息到暂存区（注意它不会提交新增加的文件信息）。所以加了 -a 在 commit 的时候，可以帮助省一步 git add，但是也只是对修改和删除文件有效，新文件还是要 git add，不然就是 untracked 状态。 综上所述：git add 和 git rm 都是等价的操作，前者添加修改和新增文件信息，后者添加删除文件信息，他们都是将文件信息提交到暂存区，之后使用 git commit -m \"xxx\" 来将暂存区的文件信息提交到本地仓库，最后使用 git push -u origin main 来提交本地仓库代码到远程仓库的 main 分支。 ","date":"2024.11.1","objectID":"/blog/categories/config/git/:2:0","tags":["config"],"title":"Some about Git","uri":"/blog/categories/config/git/"},{"categories":["config"],"content":"远程仓库到自己仓库\r拉取别人的仓库到自己仓库，主要应对github中没有对应仓库的情况繁琐指南，存在对应仓库，直接进行 fork，然后在本地添加自己的远程。简单的操作如下： git branch -r | grep -v '\\-\u003e' | while read remote; do git branch --track \"${remote#origin/}\" \"$remote\";done # 获取所有远程分支到本地 git fetch --all # 获取该项目远程库的所有分支及其内容 git fetch --tags # 获取该项目远程库的标签(没标签就不必了) git remote rename origin old-origin # 将原来的origin重命名一下 git remote add origin git@172.28.3.77:xs-soc/test-code.git # 指定需要迁移到新的目标地址(自己的仓库) git push origin --all # 推送所有分支及其内容 git push --tags # 推送所有标签及其内容 git remote rm origin # 删除当前远程库 git branch -M main # 重命名主要分支仓库 git push -u origin main # 推送到指定分支 ","date":"2024.11.1","objectID":"/blog/categories/config/git/:3:0","tags":["config"],"title":"Some about Git","uri":"/blog/categories/config/git/"},{"categories":["config"],"content":"Git 加速\rgit失败的原因绝大多数都是网络问题，所以挂代理是最为推荐的选择。以下是起作用的一些方法 通用方法，更换 git 的代理为 443 SSH：连接到主机github.com端口22：连接时间超时 但是对于 wsl，直接使用最新 wsl2 共用主机的代理即可（最为推荐），不嫌麻烦可以给配置个代理 配置wsl镜像 Windows10系统下配置WSL2自动走Clash代理，之后clash打开allow lan模式即可 WSL2内使用Windows的v2ray代理 | Nafx’s Blog，这是v2的模式，首先最后面设置，然后前面配置bashrc 有时候最后的方法会起点作用 git clone失败解决方案 ","date":"2024.11.1","objectID":"/blog/categories/config/git/:4:0","tags":["config"],"title":"Some about Git","uri":"/blog/categories/config/git/"},{"categories":["config"],"content":"这里就是对于 Vscode 的 PicGo 插件进行配置 ","date":"2024.10.31","objectID":"/blog/categories/config/picgo/:0:0","tags":["config"],"title":"VScode PicGo插件配置","uri":"/blog/categories/config/picgo/"},{"categories":["config"],"content":"上传配置\r这里因为使用 vscode 来写 Markdown 语法，所以想着仿照之前 Typora + PicGo 配置的剪切板粘贴上传图片功能。这里因为之前在 PicGo 应用中配置过，所以这次就直接获取参数然后输入即可。 配置信息\r这里的配置信息直接从软件中抄过来，或者随便看看阿里云图床的配置文章就可以知道大致该怎么填写了。之后这里 Aliyun: Path 选择之前自己创建的目录，可以通过 OSS -\u003e Bucket -\u003e 文件列表 来查看。另外选择 Pic Bed: Current 为 aliyun，这样上面的配置才可以生效。同时还设置了快捷键，对于使用截图软件，把图片放在剪切板上的情况，修改快捷键为 ctrl + alt +w，这样和普通粘贴分割开了，更加方便。 ","date":"2024.10.31","objectID":"/blog/categories/config/picgo/:1:0","tags":["config"],"title":"VScode PicGo插件配置","uri":"/blog/categories/config/picgo/"},{"categories":["config"],"content":"文件名设置\rCustom Output Format 就是文件在 vscode 中的展现形式，这里针对 Fixit 主题中 Image 的要求 进行了修改。这样后面的 title 可以直接生成，然后我们需要修改的就是前面的 alt 了。 layouts/partials/plugin/image.html 文件在之前进行修改了，所以图片下面的图标显示的就只有 alt 了，只有鼠标放在图片上面和放大图片显示的才是 title。 本地格式\rCustom Upload Format就是上传文件的格式，随便设置即可，因为不会有太多的格式要求，这里就是默认的配置。 上传格式\r","date":"2024.10.31","objectID":"/blog/categories/config/picgo/:2:0","tags":["config"],"title":"VScode PicGo插件配置","uri":"/blog/categories/config/picgo/"},{"categories":["config"],"content":"保存路径\r这里有一个 Data Path，vscode 插件会把每次的提交形成 json 数据添加到这个文件中，所以可以设置存储路径，之后查看图片可以迅速找到相关信息。这里我也将路径设置为博客的仓库，使其作为附属信息上传到 github 上。 路径配置\r","date":"2024.10.31","objectID":"/blog/categories/config/picgo/:3:0","tags":["config"],"title":"VScode PicGo插件配置","uri":"/blog/categories/config/picgo/"},{"categories":["compile"],"content":"这里记录词法分析，正则表达式，自动机的相关知识。 ","date":"2024.10.31","objectID":"/blog/categories/compile/lexer-re-automata/:0:0","tags":["compile"],"title":"Lexer Re Automata","uri":"/blog/categories/compile/lexer-re-automata/"},{"categories":["compile"],"content":"正则表达式与自动机理论\r","date":"2024.10.31","objectID":"/blog/categories/compile/lexer-re-automata/:1:0","tags":["compile"],"title":"Lexer Re Automata","uri":"/blog/categories/compile/lexer-re-automata/"},{"categories":["compile"],"content":"课程目标\r这里讲解怎么写一个自动化词法分析器生成器。根据前面的理论，我们使用 ANTLR4 来生成词法分析器，其实质上是我们使用 ANTLR4 利用正则表达式（regular expression -\u003e RE）的规则来进行生成词法分析器。同时我们还学习了利用 java 来手写词法分析器，实质就是在使用 java 代码模拟状态转移图，它也就是自动机。那么我们来看 ANTLR4 原理，他就是把 .g4 文件转化为 .java 文件，也就是把正则表达式转化为了自动机，然后通过模拟自动机就可以得到词法分析器了。 因此我们的目标就是通过正则表达式来直接得到得到一个词法分析器。 conversion\r由上图，我们构建词法分析器就是把 RE 转化为 DFA（有穷状态自动机 Deterministic FInite Automata），然后再转化为词法分析器，但是这个过程往往是困难的，所以我们采用简略的方法，通过先转化为 NFA（不确定的又穷状态自动机Nondeteeministic Finite Automata），再转化为 DFA，再进行后续的操作。 ","date":"2024.10.31","objectID":"/blog/categories/compile/lexer-re-automata/:1:1","tags":["compile"],"title":"Lexer Re Automata","uri":"/blog/categories/compile/lexer-re-automata/"},{"categories":["compile"],"content":"编程语言介绍\r语言是字符串构成的集合。 根据这句高度抽象的结论，我们会一层层进行解剖。 字符 字母表 $\\Sigma$ 是一个有限的符号集合，符号没有意义，它的语义是后来自己赋予的。 字符串 字符表 $\\Sigma$ 上的串(s) 是由 $\\Sigma$ 中符号构成的一个有穷序列。 其中 $\\epsilon$ 是空串，我们定义它为零，即 $|\\epsilon| = 0$ 字符串之间存在运算 连接运算， $x = day, y = houce, xy = dayhouce, \\epsilon s = s \\epsilon = s$ 指数运算，$s^{0} \\triangleq \\epsilon$，$s^{i} \\triangleq ss^{i-1}, i\u003e0$，这里存在上标就是连接的意思 语言 语言是给定字母表 $\\Sigma$ 上一个任意的可数的串集合。 $\\varnothing$，这一个是空集，什么语言都没有；${ \\epsilon }$，这个里面有一个语言，不过是个空串 举例：id：${a,b,c,d,a1}$；ws：${blank, tab, newline }$，if：${ if }$ 我们知道语言是串的集合，正因为是集合，所以我们可以通过集合操作构造新的语言 rules\r","date":"2024.10.31","objectID":"/blog/categories/compile/lexer-re-automata/:1:2","tags":["compile"],"title":"Lexer Re Automata","uri":"/blog/categories/compile/lexer-re-automata/"},{"categories":["compile"],"content":"RE\r每个正则表达式 r 对应一个正则语言 L(r)。正则表达式是语法（ID：[a-zA-Z][a-zA-Z0-9]*），正则语言是语义（{a1,a2,ab,……}） ","date":"2024.10.31","objectID":"/blog/categories/compile/lexer-re-automata/:2:0","tags":["compile"],"title":"Lexer Re Automata","uri":"/blog/categories/compile/lexer-re-automata/"},{"categories":["compile"],"content":"语法\r给定字母表，$\\Sigma$ 上的正则表达式由且仅由以下规则定义： $\\epsilon$ 是正则表达式 $\\forall a \\in \\Sigma$，a 是正则表达式 如果 r 是正则表达式，则 (r) 是正则表达式 如果 r 与 s 是正则表达式，则 r | s，rs，r* 也是正则表达式 运算优先级：$() \\succ * \\succ 连接 \\succ |$ ，例子：$(a) \\mid ((b)^{*} (c)) \\equiv a | b^{*} c$ ","date":"2024.10.31","objectID":"/blog/categories/compile/lexer-re-automata/:2:1","tags":["compile"],"title":"Lexer Re Automata","uri":"/blog/categories/compile/lexer-re-automata/"},{"categories":["compile"],"content":"语义\r正则表达式对应的正则语言 $L(r)$ $L(\\epsilon) = { \\epsilon}$ $L(a) = a, \\forall a \\in \\Sigma$ $L((r)) = L(r)$ $L(r|s)=L(r) \\cup L(s)\\quad L(rs)=L(r)L(s)\\quad L(r^{*})=(L(r))^{*}$ ","date":"2024.10.31","objectID":"/blog/categories/compile/lexer-re-automata/:2:2","tags":["compile"],"title":"Lexer Re Automata","uri":"/blog/categories/compile/lexer-re-automata/"},{"categories":["compile"],"content":"符号\rsymbol\rsymbol\r","date":"2024.10.31","objectID":"/blog/categories/compile/lexer-re-automata/:2:3","tags":["compile"],"title":"Lexer Re Automata","uri":"/blog/categories/compile/lexer-re-automata/"},{"categories":["compile"],"content":"自动机\r","date":"2024.10.31","objectID":"/blog/categories/compile/lexer-re-automata/:3:0","tags":["compile"],"title":"Lexer Re Automata","uri":"/blog/categories/compile/lexer-re-automata/"},{"categories":["compile"],"content":"NFA\r语法\r非确定性有穷自动机 $\\mathcal{A}$ 是一个五元组 $\\mathcal{A} = (\\Sigma, S, s_0, \\delta, F)$ 字母表 $\\Sigma (\\epsilon \\notin \\Sigma)$ 有穷的状态集合 $S$ 唯一的初始状态 $s_0 \\in S$，这里的唯一不是强求，因为可以转化为唯一形态，转化方法就是前面再添加ige初始状态，然后通过 ${\\epsilon }$ 边转移到原始初始状态即可。 状态转移函数 $\\delta$，$\\delta: S \\times (\\Sigma \\cup {\\epsilon}) \\rightarrow 2^S$ 接受状态集合 $F \\subseteq S$，下图的 3 就是接受状态 这里非确定一个就是指接受统一字符的状态转移不唯一，如下图的 0 号节点，它接受字符 a 可以跑到两个状态上去；另一个就是可能存在 ${ \\epsilon }$ 边，在没有字符驱动的情况下自发的跑到另外一个状态。 state transfer\r上面的状态转移图没有规定如果碰到其他的字符该怎么处理，所以下图就约定所有没有对应出边的字符默认指向 空状态 $\\varnothing$，也就是 $(\\Sigma \\cup {\\epsilon})$，它表示达到自身，也意味着一个死状态。 state transfer\r语义\r有穷自动机是一类及其简单的计算装置，它可以识别（接收/拒绝）$\\Sigma$ 上的字符串 接收 （非确定性）有穷自动机 $\\mathcal{A}$ 接受字符串 x，当且仅当存在一条从开始状态 $s_0$ 到某个接受状态 $f \\in F$ 、标号为 x 的路径。 对于上面的状态转移图，只有 3 是接受状态，因此 $aabb \\in L(\\mathcal{a}), ababab \\notin L(\\mathcal{A})$ 因此，$\\mathcal{A}$ 定义了一种语言 $L(\\mathcal{A})$：它能接受的所有字符串构成的集合。所以根据上方状态转移图，可以得到自动机语言：$L(\\mathcal{A}) = L((a|b)^*abb)$ 由上面的语义，我们可以得到自动机的两个基本问题 Membership 问题：给定字符串 $x$，$x \\in L(\\mathcal{A})?$ $L(\\mathcal{A})$ 究竟是什么？ ","date":"2024.10.31","objectID":"/blog/categories/compile/lexer-re-automata/:3:1","tags":["compile"],"title":"Lexer Re Automata","uri":"/blog/categories/compile/lexer-re-automata/"},{"categories":["compile"],"content":"DFA\r语法\r确定性有穷自动机 $\\mathcal{A}$ 是一个五元组 $\\mathcal{A} = (\\Sigma, S, s_0, \\delta, F)$ 字母表 $\\Sigma (\\epsilon \\notin \\Sigma)$ 有穷的状态集合 $S$ 唯一的初始状态 $s_0 \\in S$，这个唯一是一定需要的 状态转移函数 $\\delta$，$\\delta: S \\times \\Sigma \\rightarrow S$ 接受状态集合 $F \\subseteq S$，下图的 3 就是接受状态 state transfer\r这里的约定就是：所有没有对应出边的字符串默认指向一个“死状态” 语义\r上图的自动机语言还是 $L(\\mathcal{A}) = L((a|b)^*abb)$，也就是上面的 NFA 和下面的 DFA 等价的。因此可以看出 NFA 适合去表达一个语言，容易得出语言是什么；而 DFA 则是因为状态的转移确定，适合写词法分析器。即 NFA 简介易于理解，便于描述语言 $L(\\mathcal{A})$；DFA易于判断$x \\in L(\\mathcal{A})$，适合产生词法分析器。那么转换就是 $RE \\Rightarrow NFA \\Rightarrow DFA \\Rightarrow$ 词法分析器。 ","date":"2024.10.31","objectID":"/blog/categories/compile/lexer-re-automata/:3:2","tags":["compile"],"title":"Lexer Re Automata","uri":"/blog/categories/compile/lexer-re-automata/"},{"categories":["compile"],"content":"相互转换\r这里就是根据下面这张图，使得正则表达式和自动机之间相互转换。 conversion\r","date":"2024.10.31","objectID":"/blog/categories/compile/lexer-re-automata/:4:0","tags":["compile"],"title":"Lexer Re Automata","uri":"/blog/categories/compile/lexer-re-automata/"},{"categories":["compile"],"content":"RE -\u003e NFA\r采用 Thompson 构造法，使得 $r \\Rightarrow NFA$，要求 $L(N(r)) = L(r)$，即两个语言等价。这里就是对于正则表达式语法的每个规则来定义自动机，然后最后将这些自动机按规则进行组合就得到了 NFA。 $N(r)$ 的性质以及 Thompson 构造法复杂度分析 $N(r)$ 的开始状态和接受状态均唯一 开始状态没有入边，接受状态没有出边 $N(r)$ 的状态数 $|S| \u003c 2 \\times |r|$（$|r|: r$ 中运算符和运算分量的总和） 每个状态最多有两个 $\\epsilon \\text{-}$ 入边与两个 $\\epsilon \\text{-}$ 出边 $\\forall a \\in \\Sigma$，每个状态最多有一个 $a \\text{-}$ 入边与一个 $a\\text{-}$ 出边 自动机构造如下： Thompson\r","date":"2024.10.31","objectID":"/blog/categories/compile/lexer-re-automata/:4:1","tags":["compile"],"title":"Lexer Re Automata","uri":"/blog/categories/compile/lexer-re-automata/"},{"categories":["compile"],"content":"NFA -\u003e DFA\r原理\r采用子集构造法，也就是用 DFA 模拟 NFA。 子集构造法\r下面就是从 NFA 到 DFA 的构造对应表，有了这张表就有了自动机。之所以是子集构造法，是因为构造出来的 DFA 对应于 NFA 的一个状态子集。同时这里因为在 NFA 中 10 是接受状态，所以在 DFA 中，对应的 E 也是接收状态。 构造对应表\r形式化描述子集构造法\r这里根据上图的转化，会得到两个重要的公式： $\\epsilon$ 闭包：从状态 s 开始，只通过 $\\epsilon \\text{-}$ 转移可达的状态集合 $\\epsilon\\text{-closure}(s)={t\\in S_N|s\\xrightarrow{\\epsilon^*}t}$，这个公式的含义就是把 NFA 中的初始状态归结于 DFA 中的初始状态。上图中 NFA 的 ${0,1,2,4,7}$，它是初始状态，在 NFA 中，从 0 开始，通过 $\\epsilon$ 边进行连接的状态在 DFA 中都是初始状态。之后进行扩展操作 $\\epsilon \\text{-closure(T)} = \\bigcup_{s \\in T}\\epsilon \\text{-closure(s)}$，这个就是把上面的初始状态都添加在一起，转化为了集合形式，即状态集合，它为下面的 move 公式提供操作变量。 $\\text{move(T,a)} = \\bigcup_{s\\in T} \\delta(s,a)$，这个公式就是根据集合的当前状态，然后根据转移函数 $\\delta$，逐个查看集合中每个元素在同一个字符作用的目标元素是什么，最后将目标元素添加到新集合中，这个集合就是 DFA 中的下一个状态。 之后就可以形式化描述子集构造法：子集构造法($N \\rightarrow D$) 的原理： $$ \\begin{array}{l} N: (\\Sigma_N, S_N, n_0, \\delta_N, F_N) \\\\ D: (\\Sigma_D, S_D, d_0, \\delta_D, F_D) \\\\ \\Sigma_{D} = \\Sigma_{N} \\\\ S_{D} \\subseteq 2^{S_{N}} \\quad (\\forall s_{D} \\in S_{D} : s_{D} \\subseteq S_{N}) \\end{array} $$ 初始状态：$d_{0} = \\epsilon \\text{-closure}(n_{0})$ 状态转移：$\\forall a \\in \\Sigma_{D} : \\delta_{D}(s_{D}, a) = \\epsilon\\text{-closure}(\\operatorname{move}(s_{D}, a))$ 接受状态集：$F_{\\mathcal{D}} = { s_{D} \\in S_{\\mathcal{D}} \\mid \\exists f \\in F_N \\colon f \\in s_{D} }$ 子集构造法的复杂度分析：（$|S_N=n|$，下面的符号就是算法分析中的分析符号） $$\\left|S_{D}\\right| = \\Theta\\left(2^{n}\\right) = O\\left(2^{n}\\right) \\cap \\Omega\\left(2^{n}\\right)$$ 对于任何算法，最坏情况下，$|S_{D}| = \\Omega\\left(2^{n}\\right)$。 ","date":"2024.10.31","objectID":"/blog/categories/compile/lexer-re-automata/:4:2","tags":["compile"],"title":"Lexer Re Automata","uri":"/blog/categories/compile/lexer-re-automata/"},{"categories":["compile"],"content":"DFA最小化\r方法\r我们还是查看之前使用 NFA -\u003e DFA 的转换图来看，下面的 DFA 就是使用子集构造法将 NFA 转化而来的，毫无疑问，与上面的图相比，它不是最小的，所以这里需要探究的就是如何将 DFA 转化为最小化的形式。 conversion\r这里DFA最小化算法基本思想：等价的状态可以合并。对于等价而言，如果存在某个能区分状态 s 与 t 的字符串，则称 s 与 t 是可区分的；否则，称 s 与 t 是等价的。这里的字符串 x 区分状态 s 与 t，就是指如果分别从 s 与 t 出发，沿着标号为 x 的路径到达的两个状态中只有一个是接受状态，则称区分了状态 s 与 t，也就是s 与 t 不等价。 所以状态等价就是说，对于两个状态而言，在任意同一个字符的驱动下从当前状态进行转换，转换后的状态也是等价的。它可以用下面的公式进行表示： $$ \\begin{array}{l} s \\sim t \\iff \\forall a \\in \\Sigma. \\left( (s \\xrightarrow{a} s’) \\land (t \\xrightarrow{a} t’) \\implies (s’ \\sim t’) \\right)\\\\ s \\nsim t \\iff \\exists a \\in \\Sigma. \\left( (s \\xrightarrow{a} s’) \\land (t \\xrightarrow{a} t’) \\land (s’ \\nsim t’) \\right) \\end{array} $$ 基于该定义，不断合并等价的状态，直到无法合并为止。但是我们的定义是一个递归的，不知道一开始要从什么地方入手，同时我们又得到所有的接受状态并不是等价的。所以这里采取的办法就是划分，利用反例公式 $s \\nsim t \\Longleftrightarrow \\exists a \\in \\Sigma. ( s \\xrightarrow{a} s’ ) \\land ( t \\xrightarrow{a} t’ ) \\land ( s’ \\nsim t’ )$ 进行划分，而非合并。也就是首先根据接受状态与非接受状态必定不等价先划分为两类 $\\Pi = {F, S \\setminus F}$，然后在这个基础上根据上面的反例公式进行分裂，直至再也无法划分为止，这里就到达了不动点，之后就是将同一等价类里的状态合并。 划分步骤\r上面就是分裂的过程，在 $\\Pi_0$ 到 $\\Pi_1$ 的过程中，${A,B,C}$ 和 ${D}$ 在经过 b 进行传递的状态是不等价的，此时 D 转移到 E 上了，E 输出 $S \\setminus F$，所以不等价。之后的操作也是这样挑选字符看转移后的状态处于哪一个集合中，如果不在本身的集合，那么就是不等价，需要进行分裂。 合并\r上图就是最后的分裂之后再合并得到最小化 DFA 的转换。 注意\r需要注意处理\"死状态\"，也就是指向 ${ \\varnothing}$ 的一些没有画出来的边，在进行分裂时需要添加上，即${F, S \\setminus F, { \\varnothing }}$ 刚刚的算法不适用于 NFA 最小化，NFA最小化问题是 PSPACE-complete 的，复杂度很高。 ","date":"2024.10.31","objectID":"/blog/categories/compile/lexer-re-automata/:4:3","tags":["compile"],"title":"Lexer Re Automata","uri":"/blog/categories/compile/lexer-re-automata/"},{"categories":["compile"],"content":"DFA -\u003e 词法分析器\r这里对于词法分析器的构造，需要注意一下几个要求，然后按照之前使用 java 模拟的方法进行构造即可： 需要满足最前优先匹配和最长优先匹配，与此同时，因为需要生成词法分析器的特定目的，所以要保留各个 NFA 的接受状态的信息，表明匹配的是什么正则表达式 需要消除 “死状态”，避免词法分析器徒劳消耗输入流。如果加上死状态，那么词法分析器就有可能走这条路径，然后会进行一直匹配，最后匹配出的也是死状态，妨碍正确匹配。 进行模拟的过程如下图所示，和之前 java 模拟的过程一样。 模拟过程\r最后需要注意初始划分需要考虑不同的词法单元。之前的划分按照接受状态和非接受状态进行划分，但是这里需要写词法分析器，所以最后的接收状态对应了不同的词法单元，所以也需要进一步划分为不同的集合。 特定词法单元\r","date":"2024.10.31","objectID":"/blog/categories/compile/lexer-re-automata/:4:4","tags":["compile"],"title":"Lexer Re Automata","uri":"/blog/categories/compile/lexer-re-automata/"},{"categories":["programming"],"content":"这里是 python 使用技巧的记录，包括日常使用和数据之间的转换。 ","date":"2024.10.31","objectID":"/blog/categories/programming/python/:0:0","tags":["programming"],"title":"Some about Python","uri":"/blog/categories/programming/python/"},{"categories":["programming"],"content":"基础知识\r","date":"2024.10.31","objectID":"/blog/categories/programming/python/:1:0","tags":["programming"],"title":"Some about Python","uri":"/blog/categories/programming/python/"},{"categories":["programming"],"content":"字符串\r\"\"\" \"\"\" 可以存储数行字符串 str = \"\"\"learn python the smart way 2nd edition hello word\"\"\" 使用 enumerate() 可以获得元素的序号 for idx, c in enumerate(str): print(idx, c) str.split 会把字符串划分为一个列表，依照空格进行划分 for word in str.split(): print(word) str.splitlines 会把字符串划分为一个列表，依照\"\\n\"进行划分 for line in str.splitlines(): if(line.startswith(\"hello\")): # startswith print(line) ","date":"2024.10.31","objectID":"/blog/categories/programming/python/:1:1","tags":["programming"],"title":"Some about Python","uri":"/blog/categories/programming/python/"},{"categories":["programming"],"content":"函数\r接收不定长参数，*args 表示参数数目不定，可以看成一个元组，把第一个参数后面的参数当作元组中的元素 def add(x, *args): total = x for arg in args: total += arg return total 上面的函数不能使用关键词传入参数，要使用关键词 **kwargs，它表示参数数目不定，相当于一个字典，键和值对应于键值对 def add(x, **kwargs): total = x for arg, value in kwargs.items(): print(\"adding %s=%s\" % (arg,value)) total += value return total # 使用方法如下： def foo(*args, **kwargs): print(args, kwargs) add(1, 2, 3, 4) foo(2, 3, x='bar', z=10) map 方法生成序列，map(aFun, aSeq)，函数 aFun 应用到序列 aSeq 上的每一个元素上，返回一个列表，不管这个序列原来是什么类型。事实上，根据函数参数的多少，map 可以接受多组序列，将其对应的元素作为参数传入函数。 def square(a, b, c): return a**2 + b + c a = [1,2,3] b = (4, 5, 6) print(list(map(square, a, b, b))) ","date":"2024.10.31","objectID":"/blog/categories/programming/python/:1:2","tags":["programming"],"title":"Some about Python","uri":"/blog/categories/programming/python/"},{"categories":["programming"],"content":"文件读写\rpython 提供安全的 with 来进行文件读写，当 with 块的内容结束后，Python 会自动调用它的 close 方法，确保读写的安全。 模式 描述 r 只读。该文件必须已存在。 r+ 可读可写。该文件必须已存在，写为追加在文件内容末尾。 rb 表示以二进制方式读取文件。该文件必须已存在。 w 只写。打开即默认创建一个新文件，如果文件已存在，则覆盖写（即文件内原始数据会被新写入的数据清空覆盖）。 w+ 写读。打开创建新文件并写入数据，如果文件已存在，则覆盖写。 wb 表示以二进制写方式打开，只能写文件， 如果文件不存在，创建该文件；如果文件已存在，则覆盖写。 a 追加写。若打开的是已有文件则直接对已有文件操作，若打开文件不存在则创建新文件，只能执行写（追加在后面），不能读。 a+ 追加读写。打开文件方式与写入方式和a一样，但是可以读。需注意的是你若刚用a+打开一个文件，一般不能直接读取，因为此时光标已经是文件末尾，除非你把光标移动到初始位置或任意非末尾的位置。 import os os.remove('newfile.txt') with open('newfile.txt','w+') as f: for i in range(30): x = 1.0 / (i - 10) f.write('hello world: ' + str(i) + '\\n') ","date":"2024.10.31","objectID":"/blog/categories/programming/python/:1:3","tags":["programming"],"title":"Some about Python","uri":"/blog/categories/programming/python/"},{"categories":["programming"],"content":"其他\r通过 split 对 “,” 进行分割，使得一行可以输入多个值。 a, b = input().split(\",\") print(f\"a = {a}, b = {b}\") print 操作，默认每次输入后会换行，控制结尾的参数是 end，设置 end 把 “\\n” 替换成了 “//\"。同时它一次也可以输出多个内容，默认以空格分隔，这里控制分割的参数就是 sep，修改之后空格变成 “//\"。 print(\"data\", end=\"//\") print(\"Data\", \"whale\", sep=\"//\") ","date":"2024.10.31","objectID":"/blog/categories/programming/python/:1:4","tags":["programming"],"title":"Some about Python","uri":"/blog/categories/programming/python/"},{"categories":["programming"],"content":"数据转换\r这里强制自己使用byte类型，这样可以统一python的不同数据类型 ","date":"2024.10.31","objectID":"/blog/categories/programming/python/:2:0","tags":["programming"],"title":"Some about Python","uri":"/blog/categories/programming/python/"},{"categories":["programming"],"content":"AllToBytes\r字符串转化为 bytes，也可以直接在前面加 'b' 来转换 string = \"Hello World\" str_byte = bytes(string, 'utf-8') # -\u003e b'Hello World' 二进制字符串转化为 bytes hex_string = \"68 656c6c6f20776f726c64\" # 这里空格不会影响结果，但是需要是两个字符(68中间不能加空格)一组 hex_byte = bytes.fromhex(hex_string) # -\u003e b'hello world' # list(hex_byte) -\u003e [104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100] 长整型转换为 bytes，小端序方式 long_i = 6788912312 # 下面就是计算转化为16进制的字节数 int.to_bytes(long_i, (long_i.bit_length() + 7) // 8, byteorder=\"little\") # -\u003e b'\\xb8\\x94\\xa6\\x94\\x01' 十六进制数转化为 bytes，小端序方式 hex_int = 0x12345678 int_byte = int.to_bytes(hex_int, 4, byteorder='little') # -\u003e b'xV4\\x12' 整型列表转化为 bytes list_num = [0x12, 0x34, 0x56, 0x78] list_byte = bytes(list_num) # -\u003e b'\\x124Vx' 字节列表转化为 bytes，先转化为字符串，再转化 str_list = ['1', 'C', 'E', 'B', 'E', '0', '8', '9', '7', '4', 'A', '9', '6', '1', 'C', '5'] # 先转str再转byte bytes(\"\".join(str_list), encoding=\"utf-8\") # -\u003e b'1CEBE08974A961C5' ","date":"2024.10.31","objectID":"/blog/categories/programming/python/:2:1","tags":["programming"],"title":"Some about Python","uri":"/blog/categories/programming/python/"},{"categories":["programming"],"content":"AllToBytes\rbytes 转化为字符串 byte = b'Hello World' byte_str = str(byte, 'utf-8') # -\u003e 'Hello World' bytes 转化为十六进制字符串 byte = b'hello world' byte_hex = byte.hex() # -\u003e '68656c6c6f20776f726c64' bytes 转化为长整型，小端序 byte = b'\\xb8\\x94\\xa6\\x94\\x01' i = int.from_bytes(byte, byteorder='little') # -\u003e 6788912312 bytes 转化为十六进制整型 byte = b'xV4\\x12' int_num = int.from_bytes(byte, byteorder='little') # -\u003e 305419896 0x12345678 bytes 转化为整型列表 byte = b'\\x124Vx' list_num = list(byte) # -\u003e [18, 52, 86, 120] bytes 转化为字符串列表 byte = b'1CEBE08974A961C5' str_list = [str(byte[i:i + 2], 'utf-8') for i in range(0, len(byte), 2)] # -\u003e ['1C', 'EB', 'E0', '89', '74', 'A9', '61', 'C5'] ","date":"2024.10.31","objectID":"/blog/categories/programming/python/:2:2","tags":["programming"],"title":"Some about Python","uri":"/blog/categories/programming/python/"},{"categories":["programming"],"content":"其余转换处理\r转化为字符串 chr(a) # 将 int 类型的 a 根据其 ascii 码转化为 str 字符 hex(a) # 将 int 类型的 a 转化为其十六进制 str 类型 str(a) # 将所有类型的 a 按照其本身转化为 str 类型 str = a.decode() # 将 bytes 类型的 a 转化为 str 类型 转化为整型 # a 为 k 进制数，使用 int 将 k 进制数的 a 转化为十进制数 # # int(a) 直接将字符 a 转化为 int 类型，此时 a 必须为数字字符，注意：不是转化 为ascii 码，而是转化为数字类型，即值不变，类型改变 int(a,k) # 将 str 类型的十六进制数 a 转化为 int 类型(这里十六进制需要加上0x) eval(a) # 将字符类型的 a 按其 ascii 码转化为 int 类型 ord(a) ","date":"2024.10.31","objectID":"/blog/categories/programming/python/:2:3","tags":["programming"],"title":"Some about Python","uri":"/blog/categories/programming/python/"},{"categories":["programming"],"content":"数据处理\rstruct 模块可以解决 bytes 和其他二进制数据类型的转换。pack 函数把任意数据类型变成 bytes，unpack 把 bytes 变成相应的数据类型。这里的格式就是(format:str, v1, v2, …)，其中format对于后面的数据进行匹配，然后输出。 ","date":"2024.10.31","objectID":"/blog/categories/programming/python/:3:0","tags":["programming"],"title":"Some about Python","uri":"/blog/categories/programming/python/"},{"categories":["programming"],"content":"pack\rpack 函数把任意数据类型变成 bytes struct.pack('\u003cII', 10240099, 1767863401) # -\u003e b'\\x00\\x9c@ci_ti' 如果符合ascii的标准，就直接转化为字符 ","date":"2024.10.31","objectID":"/blog/categories/programming/python/:3:1","tags":["programming"],"title":"Some about Python","uri":"/blog/categories/programming/python/"},{"categories":["programming"],"content":"unpack\runpack 把 bytes 变成相应的数据类型 struct.unpack('\u003cI', b'it_i') # -\u003e (1767863401,) 这里只有一个符合 I 的规则，所以只有一个数据 ","date":"2024.10.31","objectID":"/blog/categories/programming/python/:3:2","tags":["programming"],"title":"Some about Python","uri":"/blog/categories/programming/python/"},{"categories":["programming"],"content":"数据格式\rformat 参数就是上面使用的描述符，struct 利用它可以指定使用大端序还是小端序来解析或者生成数据 Character Byte order Size Alignment @ native native native，凑足4个字节 = native standard none \u003c little-endian standard none \u003e big-endian standard none ! network(=big-endian) standard none 数据格式，用于匹配当前字符的数据 Format C Type Python type Standard size x pad byte no value c char string of length 1 1 b signed char integer 1 B unsigned char integer 1 ? _Bool bool 1 h short integer 2 H unsigned short integer 2 i int integer 4 I unsigned int integer 4 l long integer 4 L unsigned long integer 4 q long long integer 8 Q unsigned long long integer 8 f float float 4 d double float 8 s char[] string 1 p char[] string 1 P void * integer 0 ","date":"2024.10.31","objectID":"/blog/categories/programming/python/:3:3","tags":["programming"],"title":"Some about Python","uri":"/blog/categories/programming/python/"},{"categories":null,"content":"关于我\r在系统/软件安全领域学习的菜狗 有趣的事情总能吸引我，然后忘记正事 ","date":"2024.10.29","objectID":"/blog/about/:1:0","tags":null,"title":"About","uri":"/blog/about/"},{"categories":null,"content":"网址\rhttps://cztangt.github.io/blog/ https://github.com/czTangt ","date":"2024.10.29","objectID":"/blog/about/:2:0","tags":null,"title":"About","uri":"/blog/about/"},{"categories":null,"content":"联系方式\r渠道 信息 QQ Mjk3MzE3NDU5Mg== 微信 VDEzMjY0NzE4NjI5 邮箱 Y3ouVGFuZ3RAZ21haWwuY29t ","date":"2024.10.29","objectID":"/blog/about/:3:0","tags":null,"title":"About","uri":"/blog/about/"}]