<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>02 Parser Cfg LL LR - czTang</title><meta name=author content="czTang">
<meta name=description content="这里记录上下文无关文法、LL、LR 算法相关知识。
"><meta name=keywords content='compile'><meta itemprop=name content="02 Parser Cfg LL LR"><meta itemprop=description content="这里记录上下文无关文法、LL、LR 算法相关知识。"><meta itemprop=datePublished content="2024-11-14T18:46:16+08:00"><meta itemprop=dateModified content="2024-12-09T09:54:29+08:00"><meta itemprop=wordCount content="715"><meta itemprop=keywords content="Compile"><meta property="og:url" content="https://czTangt.github.io/blog/posts/compile/parser-cfg-ll-lr/"><meta property="og:site_name" content="czTang"><meta property="og:title" content="02 Parser Cfg LL LR"><meta property="og:description" content="这里记录上下文无关文法、LL、LR 算法相关知识。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-11-14T18:46:16+08:00"><meta property="article:modified_time" content="2024-12-09T09:54:29+08:00"><meta property="article:tag" content="Compile"><meta name=twitter:card content="summary"><meta name=twitter:title content="02 Parser Cfg LL LR"><meta name=twitter:description content="这里记录上下文无关文法、LL、LR 算法相关知识。"><meta name=application-name content="FixIt"><meta name=apple-mobile-web-app-title content="FixIt"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel=icon href=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410312135963.svg><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical type=text/html href=https://czTangt.github.io/blog/posts/compile/parser-cfg-ll-lr/ title="02 Parser Cfg LL LR - czTang"><link rel=prev type=text/html href=https://czTangt.github.io/blog/posts/compile/compilers-lab/ title="Compilers Lab"><link rel=next type=text/html href=https://czTangt.github.io/blog/posts/config/ida/ title="IDA 配置和使用"><link rel=stylesheet href=/blog/css/style.min.css><link rel=preload href=/blog/lib/fontawesome-free/all.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/blog/lib/fontawesome-free/all.min.css></noscript><link rel=preload href=/blog/lib/animate/animate.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/blog/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"02 Parser Cfg LL LR","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/czTangt.github.io\/blog\/posts\/compile\/parser-cfg-ll-lr\/"},"genre":"posts","keywords":"compile","wordcount":715,"url":"https:\/\/czTangt.github.io\/blog\/posts\/compile\/parser-cfg-ll-lr\/","datePublished":"2024-11-14T18:46:16+08:00","dateModified":"2024-12-09T09:54:29+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"czTang"},"description":""}</script><script src=/blog/js/head/color-scheme.min.js></script></head><body data-header-desktop=sticky data-header-mobile=auto><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=left><div class=header-title><a href=/blog/ title=czTang><span class=header-title-pre><i class='fa fa-coffee'>&nbsp</i></span><span class=header-title-text>czTang</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/blog/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> Archives</a></li><li class=menu-item><a class=menu-link href=/blog/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> Categories</a></li><li class=menu-item><a class=menu-link href=/blog/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> Tags</a></li><li class=menu-item><a class=menu-link href=/blog/about/><i class="fa-solid fa-user fa-fw fa-sm" aria-hidden=true></i> About</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/blog/ title=czTang><span class=header-title-pre><i class='fa fa-coffee'>&nbsp</i></span><span class=header-title-text>czTang</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/blog/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> Archives</a></li><li class=menu-item><a class=menu-link href=/blog/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> Categories</a></li><li class=menu-item><a class=menu-link href=/blog/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> Tags</a></li><li class=menu-item><a class=menu-link href=/blog/about/><i class="fa-solid fa-user fa-fw fa-sm" aria-hidden=true></i> About</a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=container><aside class="aside-collection animate__animated animate__fadeIn animate__faster" aria-label=合集><div class="details collection-details open"><div class="details-summary collection-summary"><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i>
<span class=collection-name data-collections=合集>Compile</span>
<span class=collection-count>6</span><i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class="details-content collection-content"><nav><ul class=collection-list><li class=collection-item><a href=/blog/posts/compile/lexer-re-automata/ title="01 Lexer Re Automata">01 Lexer Re Automata</a></li><li class=collection-item><a href=/blog/posts/compile/compilers-lab/ title="Compilers Lab">Compilers Lab</a></li><li class=collection-item><span class=active title="02 Parser Cfg LL LR">02 Parser Cfg LL LR</span></li><li class=collection-item><a href=/blog/posts/compile/semantics-symboltable-ag/ title="03 Semantics SymbolTable Ag">03 Semantics SymbolTable Ag</a></li><li class=collection-item><a href=/blog/posts/compile/llvm-ir-control/ title="04 LLVM IR Control">04 LLVM IR Control</a></li><li class=collection-item><a href=/blog/posts/compile/codegen-riscv-isel-ra/ title="05 Codegen Riscv Isel Ra">05 Codegen Riscv Isel Ra</a></li></ul><div class=collection-nav-simple><a href=/blog/posts/compile/compilers-lab/ class=collection-nav-item rel=prev title="Compilers Lab"><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i></a><span class=text-secondary>3/6</span><a href=/blog/posts/compile/semantics-symboltable-ag/ class=collection-nav-item rel=next title="03 Semantics SymbolTable Ag"><i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></nav></div></div></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>02 Parser Cfg LL LR</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/czTangt title=作者 target=_blank rel="external nofollow noopener noreferrer author" class=author><img loading=lazy src=/blog/images/avatar.jpg alt=czTang data-title=czTang width=20 height=20 class=avatar style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'>&nbsp;czTang</a></span><span class=post-included-in>&nbsp;收录于 <a href=/blog/categories/compile/ class=post-category title="分类 - Compile"><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> Compile</a> 和 <a href=/blog/collections/compile/ class=post-collection title="合集 - Compile"><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i> Compile</a></span></div><div class=post-meta-line><span title="发布于 2024-11-14 18:46:16"><i class="fa-solid fa-calendar-days fa-fw me-1" aria-hidden=true></i><time datetime=2024.11.14>2024.11.14</time></span>&nbsp;<span title="更新于 2024-12-09 09:54:29"><i class="fa-regular fa-calendar-check fa-fw me-1" aria-hidden=true></i><time datetime=2024.12.9>2024.12.9</time></span>&nbsp;<span title="715 字"><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 800 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 4 分钟</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#cfg>CFG</a><ul><li><a href=#语法>语法</a></li><li><a href=#语义>语义</a></li></ul></li><li><a href=#ll1-语法分析算法>LL(1) 语法分析算法</a><ul><li><a href=#自顶向下>自顶向下</a></li><li><a href=#递归下降>递归下降</a></li><li><a href=#基于预测分析表>基于预测分析表</a><ul><li><a href=#first-集合>FIRST 集合</a></li><li><a href=#follow-集合>FOLLOW 集合</a></li><li><a href=#构建预测分析表>构建预测分析表</a></li><li><a href=#综合例子>综合例子</a></li></ul></li><li><a href=#适用于-ll1-文法>适用于 LL(1) 文法</a></li></ul></li><li><a href=#adaptive-ll-语法分析算法>Adaptive LL(*) 语法分析算法</a></li><li><a href=#lr0-语法分析算法>LR(0) 语法分析算法</a><ul><li><a href=#语法分析树>语法分析树</a></li><li><a href=#推导与归约>推导与归约</a><ul><li><a href=#归约过程>归约过程</a></li><li><a href=#lr-分析表的构建>LR 分析表的构建</a><ul><li><a href=#状态>状态</a></li><li><a href=#句柄>句柄</a></li><li><a href=#增广文法>增广文法</a></li><li><a href=#状态机转换>状态机转换</a></li><li><a href=#构建分析表>构建分析表</a></li></ul></li></ul></li><li><a href=#文法定义>文法定义</a></li><li><a href=#其余>其余</a></li></ul></li></ul></nav></div></div><div class=content id=content><p>这里记录上下文无关文法、LL、LR 算法相关知识。</p><h2 id=cfg class=heading-element><span>CFG</span>
<a href=#cfg class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><h3 id=语法 class=heading-element><span>语法</span>
<a href=#%e8%af%ad%e6%b3%95 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>Definition(Context-Free Grammar, 上下文无关文法)，上下文无关文法 G 是一个四元组 <code>G = (T, N, S, P)</code>：</p><ul><li>T 是 <strong>终结符号</strong>（Terminal）集合，对应于词法分析器产生的词法单元</li><li>N 是 <strong>非终结符号</strong>（Non-terminal）集合</li><li>S 是 <strong>开始</strong>（Start）符号（$S \in N $且唯一）</li><li>P 是 <strong>产生式</strong>（Production）集合</li></ul><p>$$
A \in N \rightarrow \alpha \in (T \cup N)^*
$$</p><p><strong>头部/左部</strong>（Head）A：<strong>单个</strong>非终结符</p><p><strong>体部/右部</strong>（Body）$\alpha$：终结符与非终结符构成的串，也可以是空串$\epsilon$</p><h3 id=语义 class=heading-element><span>语义</span>
<a href=#%e8%af%ad%e4%b9%89 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>上下文无关文法 G 定义了一个语言 L(G)。语言是串的集合，从文法得到串的过程就是<strong>推导</strong>（Derivation）。推导就是将某个产生式的左边<code>替换</code>成它的右边，每一步推导需要选择替换哪个非终结符号，以及使用哪个产生式。对于下面的推导式而言，E 就是非终结符，id 就是终结符，目的就是从左边推到为右边，得到只包含终结符的式子。
$$
E \rightarrow E + E \mid E * E \mid (E) \mid -E \mid \text{id}
$$</p><p>对于推导也存在区分，如果一直选择最左边的非终结符进行推导，就称为 Leftmost Derivation，如下所示：
$$
E \implies -E \implies -(E) \implies -(E + E) \implies \pmb{-(\text{id} + E)} \implies -(\text{id} + \text{id})
$$
如果一直选择最右边的非终结符进行推导，就称为 Rightmost Derivation，如下所示
$$
E \implies -E \implies -(E) \implies -(E + E) \implies \pmb{-(E + \text{id})} \implies -(\text{id} + \text{id})
$$</p><p>由上述推导规则可以得到相关简单表示：
$$
\begin{align}
E &\implies -E \text{ : 经过一步推导得出} \\
E &\xRightarrow{\text{+}} -(\text{id} + E) \text{ : 经过一步或多步推导得出} \\
E &\xRightarrow{\text{*}} -(\text{id} + E) \text{ : 经过零步或多步推导得出}
\end{align}
$$</p><p>在推导的过程中，除了最左边的 program 和最后边的 文法写的程序，中间产物都被称为句型（Sentential Form），即 如果 $S \xRightarrow{*} \alpha$，且 $\alpha \in (T \cup N)^*$，则称 $\alpha$ 是文法 G 的一个<strong>句型</strong>。而最右边的结果被称为句子（Sentence），即 如果 $S \xRightarrow{*} w$，且 $w \in T^*$，则称 $w$ 是文法 G 的一个<strong>句子</strong>。</p><p>那么此时就可以定义文法 G 生成的语言 L(G) 了，即 文法 G 的语言 L(G) 是它能推导出的<strong>所有句子</strong>构成的集合 $L(G) = { w \mid S \xRightarrow{*} w }$。</p><h2 id=ll1-语法分析算法 class=heading-element><span>LL(1) 语法分析算法</span>
<a href=#ll1-%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90%e7%ae%97%e6%b3%95 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>自顶向下的、递归下降的、基于预测分析表的、适用于 LL(1) 文法的 LL(1) 语法分析器。</p><h3 id=自顶向下 class=heading-element><span>自顶向下</span>
<a href=#%e8%87%aa%e9%a1%b6%e5%90%91%e4%b8%8b class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>这里指语法分析树从上往下进行构建，<strong>根节点</strong>是文法的起始符号 <code>S</code>，<strong>叶节点</strong>是词法单元流 <code>w$</code>，仅包含终结符号与特殊的文件结束符 <code>$(EOF)</code>，<strong>中间节点</strong>表示对某个非终结符应用某个产生式进行推导。那么这里的问题就是选择哪个非终结符，以及选择哪个产生式。这里对于 LL(1) 而言，第一个 L 就是表示从左向右读入词法单元；第二个 L 表示在推导的每一步，LL(1) 总是选择最左边的非终结符进行展开。即构建最左推导；1 表示只需向前看一个输入符号便可确定使用哪条产生式。</p><h3 id=递归下降 class=heading-element><span>递归下降</span>
<a href=#%e9%80%92%e5%bd%92%e4%b8%8b%e9%99%8d class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>这里指实现方式，就是为每个非终结符写一个递归函数，内部按需调用其它非终结符对应的递归函数，下降一层。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241115124335.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241115124335.png?size=small" data-sub-html="<h2>20241115124335</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241115124335.png alt=递归下降的典型实现框架 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241115124335.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241115124335.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241115124335.png?size=large 2x" data-title=20241115124335 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>递归下降的典型实现框架</figcaption></figure></p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241115125451.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241115125451.png?size=small" data-sub-html="<h2>20241115125451</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241115125451.png alt=递归下降过程 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241115125451.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241115125451.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241115125451.png?size=large 2x" data-title=20241115125451 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>递归下降过程</figcaption></figure></p><h3 id=基于预测分析表 class=heading-element><span>基于预测分析表</span>
<a href=#%e5%9f%ba%e4%ba%8e%e9%a2%84%e6%b5%8b%e5%88%86%e6%9e%90%e8%a1%a8 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>设计预测分析表就是源于上述递归下降过程的一个问题，在上图展开非终结符 S 的过程中，为什么前两次玄策了 $S \implies (S + F)$，而第三次选择了 $S \implies F$？这里就是因为它们面对的当前词法单元不同。由此根据不同的词法单元，形成了一张预测分析表，之后就可以使用预测分析表来确定产生式。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241115130059.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241115130059.png?size=small" data-sub-html="<h2>20241115130059</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241115130059.png alt=预测分析表 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241115130059.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241115130059.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241115130059.png?size=large 2x" data-title=20241115130059 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>预测分析表</figcaption></figure></p><p>这里指明了每个<strong>非终结符</strong>在面对不同的<strong>词法单元或文件结束符</strong>时，该选择哪个<strong>产生式</strong>（按编号进行索引）或者<strong>报错</strong>（空单元格）。下面就是递归下降、基于预测分析表的实现方法，这里根据预测分析表，从左往右逐个字符进行匹配。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241116153444.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241116153444.png?size=small" data-sub-html="<h2>20241116153444</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241116153444.png alt=实现方法 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241116153444.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241116153444.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241116153444.png?size=large 2x" data-title=20241116153444 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>实现方法</figcaption></figure></p><p>那么如何得到这个预测分析表呢，就需要先知道两个概念。</p><h4 id=first-集合 class=heading-element><span>FIRST 集合</span>
<a href=#first-%e9%9b%86%e5%90%88 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>$FIRST(\alpha)$ 是可从 $\alpha$ 推导得到的句型的<strong>首终结符号</strong>的集合。即对于任意的（产生式的右部）$\alpha \in (N \cup T)^*$：
$$
\text{FIRST}(\alpha) = \{ t \in T \cup \{ \epsilon \} \mid \alpha \overset{*}{\Rightarrow} \textcolor{red}{t} \beta \lor \alpha \overset{*}{\Rightarrow} \epsilon \}
$$
因此对于这个集合而言，考虑非终结符 $A$ 的所有产生式 $A \rightarrow \alpha_1, \quad A \rightarrow \alpha_2, \quad \ldots, \quad A \rightarrow \alpha_m$，如果它们对应的 $FIRST(\alpha)$ 集合互不相交，则只需查看当前输入词法单元，即可确定选择哪个产生式（或报错）。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241116162747.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241116162747.png?size=small" data-sub-html="<h2>20241116162747</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241116162747.png alt="符号 X 的 FIRST 集合计算" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241116162747.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241116162747.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241116162747.png?size=large 2x" data-title=20241116162747 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>符号 X 的 FIRST 集合计算</figcaption></figure></p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241116162828.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241116162828.png?size=small" data-sub-html="<h2>20241116162828</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241116162828.png alt="符号串 $X\beta$ 的 FIRST 集合计算" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241116162828.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241116162828.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241116162828.png?size=large 2x" data-title=20241116162828 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>符号串 $X\beta$ 的 FIRST 集合计算</figcaption></figure></p><p>具体可以看下面的例子：</p><ul><li>后面跟的为终结符</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>A-&gt;aB<span class=p>|</span>ε
</span></span><span class=line><span class=cl>A-&gt;c
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>First<span class=o>(</span>A<span class=o>)</span> <span class=o>=</span> <span class=o>{</span>a，ε，c<span class=o>}</span></span></span></code></pre></td></tr></table></div></div><ul><li>后面跟的为非终结符</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 情况一</span>
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>A-&gt;Ba
</span></span><span class=line><span class=cl>B-&gt;b
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>First<span class=o>(</span>A<span class=o>)</span> <span class=o>=</span> <span class=o>{</span>b<span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 情况二</span>
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>A-&gt;Bc
</span></span><span class=line><span class=cl>B-&gt;b<span class=p>|</span>ε
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>First<span class=o>(</span>A<span class=o>)</span> <span class=o>=</span> <span class=o>{</span>b, c<span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 情况三</span>
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>A-&gt;BC
</span></span><span class=line><span class=cl>B-&gt;b<span class=p>|</span>ε
</span></span><span class=line><span class=cl>C-&gt;c<span class=p>|</span>ε
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>First<span class=o>(</span>A<span class=o>)</span> <span class=o>=</span> <span class=o>{</span>b, c, ε<span class=o>}</span></span></span></code></pre></td></tr></table></div></div><h4 id=follow-集合 class=heading-element><span>FOLLOW 集合</span>
<a href=#follow-%e9%9b%86%e5%90%88 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>$FOLLOW(A)$ 是可能在某些句型中<strong>紧跟在 $A$ 右边的终结符</strong>的集合。即对于任意的（产生式的左部）非终结符$A \in N$：</p><p>$$
\text{FOLLOW}(A) = \{ t \in T \cup \{ \text{\$} \} \mid \exists s.\ S \overset{*}{\Rightarrow} s \triangleq \beta A \textcolor{red}{t} \gamma \}
$$</p><p>这里的 $\$$ 就是文法开始符，只在第一个字符的 $FOLLOW$ 集合中进行添加。考虑产生式 $A \rightarrow \alpha$，如果从 $\alpha$ 可能推导出空串（$\textcolor{red}{\alpha \overset{*}{\Rightarrow} \epsilon}$），则只有当当前词法单元 $t \in FOLLOW(A)$，才可以选择该产生式。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241117110404.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241117110404.png?size=small" data-sub-html="<h2>20241117110404</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241117110404.png alt="符号 X 的 FOLLOW 集合计算" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241117110404.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241117110404.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241117110404.png?size=large 2x" data-title=20241117110404 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>符号 X 的 FOLLOW 集合计算</figcaption></figure></p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241117110432.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241117110432.png?size=small" data-sub-html="<h2>20241117110432</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241117110432.png alt="符号串 $X\beta$ 的 FOLLOW 集合计算" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241117110432.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241117110432.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241117110432.png?size=large 2x" data-title=20241117110432 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>符号串 $X\beta$ 的 FOLLOW 集合计算</figcaption></figure></p><h4 id=构建预测分析表 class=heading-element><span>构建预测分析表</span>
<a href=#%e6%9e%84%e5%bb%ba%e9%a2%84%e6%b5%8b%e5%88%86%e6%9e%90%e8%a1%a8 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>根据上述对于 FIRST集合 和 FOLLOW集合 的描述，可以计算给定文法 G 的预测分析表：对应每条产生式 $A \rightarrow \alpha$ 与终结符 $\textcolor{blue}{t}$，如果
$$
t \in \text{FIRST}(\alpha) \\
\alpha^* \Rightarrow \epsilon \land t \in \text{FOLLOW}(A)
$$
则在表格 $[\textcolor{red}{A}, \textcolor{blue}{t}]$ 中填入 $A \rightarrow \alpha$（编号）。</p><h4 id=综合例子 class=heading-element><span>综合例子</span>
<a href=#%e7%bb%bc%e5%90%88%e4%be%8b%e5%ad%90 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>对于下面的例子，可以得到它们的 FIRST 和 FOLLOW 集合。
$$
X \rightarrow Y \\
X \rightarrow \alpha \\
Y \rightarrow \epsilon \\
Y \rightarrow c \\
Z \rightarrow d \\
Z \rightarrow XYZ
$$</p><table><thead><tr><th>FIRST集合</th><th>FOLLOW集合</th></tr></thead><tbody><tr><td>$FIRST(X) = \{a, c, \epsilon \}$</td><td></td></tr><tr><td>$FIRST(Y) = \{c, \epsilon \}$</td><td>$FOLLOW(X) = \{a, c, d, \$ \}$</td></tr><tr><td>$FITST(Z) = \{a, c, d \}$</td><td>$FOLLOW(Y) = \{a, c, d, \$ \}$</td></tr><tr><td>$FITST(XYZ) = \{a, c, d \}$</td><td>$FOLLOW(Z) = \empty$</td></tr><tr><td>$FITST(YZ) = \{a, c, d \}$</td><td></td></tr></tbody></table><p>关于 FIRST 和 FOLLOW 的更多讲解和例子可以看 <a href=https://blog.csdn.net/weixin_44445120/article/details/115681574 target=_blank rel="external nofollow noopener noreferrer">这篇文章</a>。之后根据上面信息，可以构建相应的预测分析表。也可以看 <a href="https://www.bilibili.com/video/BV1Cu411m7VX?spm_id_from=333.788.videopod.sections&amp;vd_source=17ac9da9453dbd6d64b9616668574c5f" target=_blank rel="external nofollow noopener noreferrer">这个视频</a> 来学习两个集合的构造方法。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241117121918.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241117121918.png?size=small" data-sub-html="<h2>20241117121918</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241117121918.png alt=预测分析表 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241117121918.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241117121918.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241117121918.png?size=large 2x" data-title=20241117121918 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>预测分析表</figcaption></figure></p><h3 id=适用于-ll1-文法 class=heading-element><span>适用于 LL(1) 文法</span>
<a href=#%e9%80%82%e7%94%a8%e4%ba%8e-ll1-%e6%96%87%e6%b3%95 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>这里主要说明它的局限性。对于上面预测分析表的构建，需要定义 LL(1) 文法，即如果文法 G 的预测分析表是<strong>无冲突</strong>的，则 G 是 LL(1)文法。无冲突就是每个单元格里只有一个产生式（编号）即<strong>仅根据当前 token 即可递推 production</strong>。那么根据这个无冲突的预测分析表，对于当前选择的非终结符，仅根据输入中当前的词法单元（LL(1)）即可确定需要使用哪条产生式。这里根据 LL(1) 文法的定义就可以看到其局限性，它需要的就是预测分析表是无冲突的，其他情况就不适用这个文法了。</p><h2 id=adaptive-ll-语法分析算法 class=heading-element><span>Adaptive LL(*) 语法分析算法</span>
<a href=#adaptive-ll-%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90%e7%ae%97%e6%b3%95 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>看 <a href="https://www.bilibili.com/video/BV1eA4m1w7tm/?spm_id_from=333.999.0.0&amp;vd_source=17ac9da9453dbd6d64b9616668574c5f" target=_blank rel="external nofollow noopener noreferrer">视频</a> 和 <a href=https://github.com/courses-at-nju-by-hfwei/compilers-papers-we-love/blob/master/parsing/ANTLR/PLDI2014%20Adaptive%20LL%28Star%29%20Parsing%20The%20Power%20of%20Dynamic%20Analysis%20%28ALLStar%29.pdf target=_blank rel="external nofollow noopener noreferrer">论文</a> 理解吧。</p><p>记录一下别人的 <a href=https://pfmiles.github.io/blog/concept-and-implementation-of-ll-star/ target=_blank rel="external nofollow noopener noreferrer">博客1</a>，<a href=https://ling-yuchen.github.io/2022/12/04/NJU-Compiler-Principle/#06-%E7%AC%A6%E5%8F%B7%E8%A1%A8 target=_blank rel="external nofollow noopener noreferrer">博客2</a>。第二篇是视频的笔记，虽然它只是截图保存🐶。</p><h2 id=lr0-语法分析算法 class=heading-element><span>LR(0) 语法分析算法</span>
<a href=#lr0-%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90%e7%ae%97%e6%b3%95 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209084935.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209084935.png?size=small" data-sub-html="<h2>20241209084935</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209084935.png alt=相关文法 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209084935.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209084935.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209084935.png?size=large 2x" data-title=20241209084935 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>相关文法</figcaption></figure></p><p>对于 LL(k) 而言，它的缺陷就是在<strong>仅看到右部的前 k 个词法单元</strong>时就必须预测要使用哪条产生式。那么相对应的，LR(k) 的优势就是看到某个产生式的<strong>整个右部</strong>对应的词法单元之后再做决定。</p><p>那么 LR 语法分析器的特点就是自底向上、不断归约、基于句柄识别自动机，适用于 LR 文法。</p><h3 id=语法分析树 class=heading-element><span>语法分析树</span>
<a href=#%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90%e6%a0%91 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>这里的语法分析树是自底向上进行构建的，<strong>根节点</strong>是文法的起始符号 S；每个<strong>中间非终结符节点</strong>表示使用它的某条产生式进行归约；<strong>叶节点</strong>是词法单元流 $w$$，它仅包含终结符号与特殊的文本结束符 $$$。</p><h3 id=推导与归约 class=heading-element><span>推导与归约</span>
<a href=#%e6%8e%a8%e5%af%bc%e4%b8%8e%e5%bd%92%e7%ba%a6 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>下图就是推导与归约的示例，我们首先进行自顶向下的最右推导，之后直接沿着反方向进行归约。因此这里的 LR 语法分析器中的 L 就是<strong>从左向右</strong>扫描输入；R 就是构建<strong>反向最右</strong>推导。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241207161648.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241207161648.png?size=small" data-sub-html="<h2>20241207161648</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241207161648.png alt=推导与归约1 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241207161648.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241207161648.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241207161648.png?size=large 2x" data-title=20241207161648 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>推导与归约1</figcaption></figure></p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241207161823.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241207161823.png?size=small" data-sub-html="<h2>20241207161823</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241207161823.png alt=推导与归约2 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241207161823.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241207161823.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241207161823.png?size=large 2x" data-title=20241207161823 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>推导与归约2</figcaption></figure></p><p>由上图可以看出，这里的最右推导就是指对于一个产生式，最先解析右侧的的非终结符，使其转化为终结符，然后再解析左侧的非终结符。因此反方向的归约从左到右进行识别，如果识别到产生式完整的右部，那么就转化为产生式的左部，这样持续进行，最终把终结符推导为最后的 E。</p><p>这里之所以采用最右推导是为了效率，若是最左推导，那么归约就是从右往左了。这样构造的话，非终结符必须全部输入完成才会进行解析，因为这里是从后往前。而采用最右推导，那么归约就是从前往后了，这样在读入输入的时候就可以进行归约构建，增强效率。</p><h4 id=归约过程 class=heading-element><span>归约过程</span>
<a href=#%e5%bd%92%e7%ba%a6%e8%bf%87%e7%a8%8b class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>归约如下图所示。上边缘就是需要进行归约的部分，剩余的输入就是还没有读入的部分，这里就是一遍读入一遍进行归约。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208160256.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208160256.png?size=small" data-sub-html="<h2>20241208160256</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208160256.png alt=归约概念 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208160256.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208160256.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208160256.png?size=large 2x" data-title=20241208160256 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>归约概念</figcaption></figure></p><p>下面就是归约的过程，通过栈结构将左侧的子树进行压栈，如果栈的栈顶部分满足产生式，可以推导出左半部分，那么就移除右半部分，将左半部分压栈。否则从左往右读入输入进行压栈。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208203532.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208203532.png?size=small" data-sub-html="<h2>20241208203532</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208203532.png alt=归约过程 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208203532.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208203532.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208203532.png?size=large 2x" data-title=20241208203532 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>归约过程</figcaption></figure></p><p>那么现在的问题就是对于这个栈结构，什么时候进行归约，又是按哪条产生式进行归约？例如上面：为什么第二个 F 以 T * F 整体被归约为 T？那么回答就是，这与栈的当前状态 “T * F” 相关。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208205131.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208205131.png?size=small" data-sub-html="<h2>20241208205131</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208205131.png alt="LR 分析表" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208205131.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208205131.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208205131.png?size=large 2x" data-title=20241208205131 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>LR 分析表</figcaption></figure></p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208205234.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208205234.png?size=small" data-sub-html="<h2>20241208205234</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208205234.png alt=分析表解析 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208205234.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208205234.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208205234.png?size=large 2x" data-title=20241208205234 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>分析表解析</figcaption></figure></p><p>这里需要注意，对于归约和 GOTO 语句而言，若是进行了归约，那么就存在着出栈的操作，此时对于 GOTO 语句的状态就不是当前的状态，而是上一次的状态，因为出栈引起了状态的变化。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208205501.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208205501.png?size=small" data-sub-html="<h2>20241208205501</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208205501.png alt=移入与归约 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208205501.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208205501.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208205501.png?size=large 2x" data-title=20241208205501 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>移入与归约</figcaption></figure></p><h4 id=lr-分析表的构建 class=heading-element><span>LR 分析表的构建</span>
<a href=#lr-%e5%88%86%e6%9e%90%e8%a1%a8%e7%9a%84%e6%9e%84%e5%bb%ba class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>这里展示了 LR(0) 句柄识别有穷状态自动机，我们之后要做的就是解释这个状态集怎么转化为分析表的。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208214009.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208214009.png?size=small" data-sub-html="<h2>20241208214009</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208214009.png alt=句柄识别有穷状态自动机 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208214009.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208214009.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208214009.png?size=large 2x" data-title=20241208214009 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>句柄识别有穷状态自动机</figcaption></figure></p><h5 id=状态 class=heading-element><span>状态</span>
<a href=#%e7%8a%b6%e6%80%81 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>首先我们需要知道状态是什么，对于这个分析表，状态是语法分析树的上边缘，存储在栈中。由此我们可以的到下面的结论。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208213456.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208213456.png?size=small" data-sub-html="<h2>20241208213456</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208213456.png alt=状态定义 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208213456.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208213456.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208213456.png?size=large 2x" data-title=20241208213456 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>状态定义</figcaption></figure></p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208213657.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208213657.png?size=small" data-sub-html="<h2>20241208213657</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208213657.png alt=项集和项集族 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208213657.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208213657.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208213657.png?size=large 2x" data-title=20241208213657 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>项集和项集族</figcaption></figure></p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208214205.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208214205.png?size=small" data-sub-html="<h2>20241208214205</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208214205.png alt=点的含义 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208214205.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208214205.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208214205.png?size=large 2x" data-title=20241208214205 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>点的含义</figcaption></figure>由上图，<code>·</code> 表示我们当前看的位置。一开始，栈为空，期望输入是 <code>E</code> 可以展开得到的一个句子并以 <code>$</code> 结束。输入以 <code>E</code> 开始，意味着它可能以 <code>E</code> 的任何一个右部开始。</p><h5 id=句柄 class=heading-element><span>句柄</span>
<a href=#%e5%8f%a5%e6%9f%84 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>根据下图我们可以知道句柄的概念，之后就需要知道句柄可能在哪里出现，有之前的操作我们可以看出，句柄在栈顶位置，所以这里就需要我们设计出一种满足“句柄总是出现在栈顶”性质的 LR 语法分析器。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208210929.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208210929.png?size=small" data-sub-html="<h2>20241208210929</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208210929.png alt=句柄概念 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208210929.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208210929.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208210929.png?size=large 2x" data-title=20241208210929 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>句柄概念</figcaption></figure></p><h5 id=增广文法 class=heading-element><span>增广文法</span>
<a href=#%e5%a2%9e%e5%b9%bf%e6%96%87%e6%b3%95 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>这里我们需要进行的就是添加一个文法帮助我们进行转换。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208214717.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208214717.png?size=small" data-sub-html="<h2>20241208214717</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208214717.png alt=增广文法 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208214717.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208214717.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208214717.png?size=large 2x" data-title=20241208214717 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>增广文法</figcaption></figure></p><h5 id=状态机转换 class=heading-element><span>状态机转换</span>
<a href=#%e7%8a%b6%e6%80%81%e6%9c%ba%e8%bd%ac%e6%8d%a2 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>由一开始的自动机就可以看出，这里通过 <code>·</code> 点的移动来进行状态的转换，根据产生式的内容进行转移。</p><p>$$
J = \text{GOTO}(I, X) = \text{CLOSURE}(\{[A \to \alpha X \cdot \beta ] \mid [A \to \alpha \cdot X \beta] \})
$$</p><p>接受状态：
$$
F = \{ I \in C \mid \exists [A \to \alpha \cdot] \in I \}
$$
此时，产生式 $ A \ to \alpha$ 的完整右部出现在栈顶</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220006.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220006.png?size=small" data-sub-html="<h2>20241208220006</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220006.png alt=状态转移 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220006.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220006.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220006.png?size=large 2x" data-title=20241208220006 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>状态转移</figcaption></figure></p><h5 id=构建分析表 class=heading-element><span>构建分析表</span>
<a href=#%e6%9e%84%e5%bb%ba%e5%88%86%e6%9e%90%e8%a1%a8 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220036.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220036.png?size=small" data-sub-html="<h2>20241208220036</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220036.png alt=分析表构造规则 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220036.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220036.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220036.png?size=large 2x" data-title=20241208220036 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>分析表构造规则</figcaption></figure></p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220046.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220046.png?size=small" data-sub-html="<h2>20241208220046</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220046.png alt=分析表构造规则 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220046.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220046.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220046.png?size=large 2x" data-title=20241208220046 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>分析表构造规则</figcaption></figure></p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220056.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220056.png?size=small" data-sub-html="<h2>20241208220056</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220056.png alt=分析表构造规则 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220056.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220056.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220056.png?size=large 2x" data-title=20241208220056 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>分析表构造规则</figcaption></figure></p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220105.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220105.png?size=small" data-sub-html="<h2>20241208220105</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220105.png alt=分析表构造规则 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220105.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220105.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220105.png?size=large 2x" data-title=20241208220105 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>分析表构造规则</figcaption></figure></p><h3 id=文法定义 class=heading-element><span>文法定义</span>
<a href=#%e6%96%87%e6%b3%95%e5%ae%9a%e4%b9%89 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220128.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220128.png?size=small" data-sub-html="<h2>20241208220128</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220128.png alt=文法定义 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220128.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220128.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220128.png?size=large 2x" data-title=20241208220128 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>文法定义</figcaption></figure></p><p>这里的无冲突，就是指每一个空位上只有一个规则，而上图可见是冲突的，它不是 LR(0) 文法。这里的 <code>0</code> 指的就是归约时无需向前看，<code>·</code> 移动到什么地方就进行归约判断。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220406.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220406.png?size=small" data-sub-html="<h2>20241208220406</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220406.png alt=自动机与栈 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220406.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220406.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220406.png?size=large 2x" data-title=20241208220406 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>自动机与栈</figcaption></figure></p><h3 id=其余 class=heading-element><span>其余</span>
<a href=#%e5%85%b6%e4%bd%99 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>余下的 <code>LSR(1)</code>、<code>LR(1)</code>、<code>LALR(1)</code> 算法都是面对移入归约冲突、归越归约冲突的不同改进。具体可以看课程。</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2024-12-09 09:54:29">更新于 2024.12.9&nbsp;
<a class=git-hash href=https://github.com/czTangt/blog.git/commit/205b3cbc3434d85ba99216000529a4dff916c5b0 rel="external nofollow noopener noreferrer" target=_blank title="commit by czTangt(cz.tangt@gmail.com) 205b3cbc3434d85ba99216000529a4dff916c5b0: add content to compile"><i class="fa-solid fa-hashtag fa-fw" aria-hidden=true></i>205b3cb</a></span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href="https://github.com/czTangt/blog.git/blob/main/content/posts%5ccompile%5cparser-cfg-ll-lr.md?plain=1" title=查看源码 target=_blank rel="external nofollow noopener noreferrer" class=link-to-source>查看源码</a></span><span><a href=https://github.com/czTangt/blog.git/edit/main/content/posts%5ccompile%5cparser-cfg-ll-lr.md title=编辑此页 target=_blank rel="external nofollow noopener noreferrer" class=link-to-edit>编辑此页</a></span><span><a href="https://github.com/czTangt/blog.git/issues/new?title=[BUG]%2002+Parser+Cfg+LL+LR&amp;body=%7cField%7cValue%7c%0A%7c-%7c-%7c%0A%7cTitle%7c02+Parser+Cfg+LL+LR%7c%0A%7cURL%7chttps://czTangt.github.io/blog/posts/compile/parser-cfg-ll-lr/%7c%0A%7cFilename%7chttps://github.com/czTangt/blog.git/blob/main/content/posts%5ccompile%5cparser-cfg-ll-lr.md?plain=1%7c" title=报告问题 target=_blank rel="external nofollow noopener noreferrer" class=link-to-report>报告问题</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 X" data-sharer=twitter data-url=https://czTangt.github.io/blog/posts/compile/parser-cfg-ll-lr/ data-title="02 Parser Cfg LL LR" data-hashtags=compile><i class="fa-brands fa-x-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://czTangt.github.io/blog/posts/compile/parser-cfg-ll-lr/ data-hashtag=compile><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://czTangt.github.io/blog/posts/compile/parser-cfg-ll-lr/ data-title="02 Parser Cfg LL LR"><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/blog/tags/compile/ class=post-tag title="标签 - Compile">Compile</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/blog/>主页</a></span></section></div><div class=post-nav><a href=/blog/posts/compile/compilers-lab/ class=post-nav-item rel=prev title="Compilers Lab"><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>Compilers Lab</a><a href=/blog/posts/config/ida/ class=post-nav-item rel=next title="IDA 配置和使用">IDA 配置和使用<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article><aside class=toc id=toc-auto aria-label=目录><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside></main><footer class=footer><div class=footer-container><div class="footer-line powered order-1">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.136.5"><img class=hugo-icon src=/blog/images/hugo.min.svg alt="Hugo logo"> Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.3.14"><img class=fixit-icon src=/blog/images/fixit.min.svg alt="FixIt logo"> FixIt</a></div><div class="footer-line copyright order-2" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2024</span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class="variant-numeric d-none">0%</span></div></div><a href=https://github.com/czTangt/blog title="View source on GitHub" target=_blank rel="external nofollow" class="github-corner left d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true" width="56" height="56"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><noscript><div class=noscript-warning>该网站在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/blog/lib/lightgallery/css/lightgallery-bundle.min.css><link rel=preload href=/blog/lib/katex/katex.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/blog/lib/katex/katex.min.css></noscript><link rel=stylesheet href=/blog/lib/cookieconsent/cookieconsent.min.css><script src=/blog/lib/autocomplete/autocomplete.min.js defer></script><script src=/blog/lib/fuse/fuse.min.js defer></script><script src=/blog/lib/lightgallery/lightgallery.min.js defer></script><script src=/blog/lib/lightgallery/plugins/thumbnail/lg-thumbnail.min.js defer></script><script src=/blog/lib/lightgallery/plugins/zoom/lg-zoom.min.js defer></script><script src=/blog/lib/sharer/sharer.min.js async defer></script><script src=/blog/lib/katex/katex.min.js defer></script><script src=/blog/lib/katex/auto-render.min.js defer></script><script src=/blog/lib/katex/mhchem.min.js defer></script><script src=/blog/lib/cookieconsent/cookieconsent.min.js defer></script><script src=/blog/js/codeblock.js defer></script><script src=https://libs.baidu.com/jquery/2.1.4/jquery.min.js defer></script><script>window.config={code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:10},comment:{enable:!1},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},lightgallery:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{distance:100,findAllMatches:!1,fuseIndexURL:"/blog/search.json",highlightTag:"em",ignoreFieldNorm:!1,ignoreLocation:!1,isCaseSensitive:!1,location:0,maxResultLength:10,minMatchCharLength:2,noResultsFound:"没有找到结果",snippetLength:30,threshold:.3,type:"fuse",useExtendedSearch:!1},version:"v0.3.14"}</script><script src=/blog/js/theme.min.js defer></script></body></html>