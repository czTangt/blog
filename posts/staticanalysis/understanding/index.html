<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>01 Understanding Static Analysis - czTang</title><meta name=author content="czTang">
<meta name=description content="记录一下对于静态分析的理解。
"><meta name=keywords content='Static Analysis'><meta itemprop=name content="01 Understanding Static Analysis"><meta itemprop=description content="记录一下对于静态分析的理解。"><meta itemprop=datePublished content="2024-12-19T08:18:00+08:00"><meta itemprop=dateModified content="2024-12-22T12:22:35+08:00"><meta itemprop=wordCount content="14211"><meta itemprop=keywords content="Static Analysis"><meta property="og:url" content="https://czTangt.github.io/blog/posts/staticanalysis/understanding/"><meta property="og:site_name" content="czTang"><meta property="og:title" content="01 Understanding Static Analysis"><meta property="og:description" content="记录一下对于静态分析的理解。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-19T08:18:00+08:00"><meta property="article:modified_time" content="2024-12-22T12:22:35+08:00"><meta property="article:tag" content="Static Analysis"><meta name=twitter:card content="summary"><meta name=twitter:title content="01 Understanding Static Analysis"><meta name=twitter:description content="记录一下对于静态分析的理解。"><meta name=application-name content="FixIt"><meta name=apple-mobile-web-app-title content="FixIt"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel=icon href=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410312135963.svg><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical type=text/html href=https://czTangt.github.io/blog/posts/staticanalysis/understanding/ title="01 Understanding Static Analysis - czTang"><link rel=prev type=text/html href=https://czTangt.github.io/blog/posts/compile/codegen-riscv-isel-ra/ title="05 Codegen Riscv Isel Ra"><link rel=next type=text/html href=https://czTangt.github.io/blog/posts/programming/java/ title="Some about Java"><link rel=stylesheet href=/blog/css/style.min.css><link rel=preload href=/blog/lib/fontawesome-free/all.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/blog/lib/fontawesome-free/all.min.css></noscript><link rel=preload href=/blog/lib/animate/animate.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/blog/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"01 Understanding Static Analysis","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/czTangt.github.io\/blog\/posts\/staticanalysis\/understanding\/"},"genre":"posts","keywords":"Static Analysis","wordcount":14211,"url":"https:\/\/czTangt.github.io\/blog\/posts\/staticanalysis\/understanding\/","datePublished":"2024-12-19T08:18:00+08:00","dateModified":"2024-12-22T12:22:35+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"czTang"},"description":""}</script><script src=/blog/js/head/color-scheme.min.js></script></head><body data-header-desktop=sticky data-header-mobile=auto><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=left><div class=header-title><a href=/blog/ title=czTang><span class=header-title-pre><i class='fa fa-coffee'>&nbsp</i></span><span class=header-title-text>czTang</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/blog/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> Archives</a></li><li class=menu-item><a class=menu-link href=/blog/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> Categories</a></li><li class=menu-item><a class=menu-link href=/blog/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> Tags</a></li><li class=menu-item><a class=menu-link href=/blog/about/><i class="fa-solid fa-user fa-fw fa-sm" aria-hidden=true></i> About</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/blog/ title=czTang><span class=header-title-pre><i class='fa fa-coffee'>&nbsp</i></span><span class=header-title-text>czTang</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/blog/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> Archives</a></li><li class=menu-item><a class=menu-link href=/blog/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> Categories</a></li><li class=menu-item><a class=menu-link href=/blog/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> Tags</a></li><li class=menu-item><a class=menu-link href=/blog/about/><i class="fa-solid fa-user fa-fw fa-sm" aria-hidden=true></i> About</a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=container><aside class="aside-collection animate__animated animate__fadeIn animate__faster" aria-label=合集><div class="details collection-details open"><div class="details-summary collection-summary"><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i>
<span class=collection-name data-collections=合集>Static Analysis</span>
<span class=collection-count>2</span><i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class="details-content collection-content"><nav><ul class=collection-list><li class=collection-item><span class=active title="01 Understanding Static Analysis">01 Understanding Static Analysis</span></li><li class=collection-item><a href=/blog/posts/staticanalysis/control-flow-analysis/ title="02 Control Flow Analysis">02 Control Flow Analysis</a></li></ul><div class=collection-nav-simple><i class="fa-solid fa-angle-left fa-fw collection-nav-item text-secondary" aria-hidden=true></i><span class=text-secondary>1/2</span><a href=/blog/posts/staticanalysis/control-flow-analysis/ class=collection-nav-item rel=next title="02 Control Flow Analysis"><i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></nav></div></div></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>01 Understanding Static Analysis</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/czTangt title=作者 target=_blank rel="external nofollow noopener noreferrer author" class=author><img loading=lazy src=/blog/images/avatar.jpg alt=czTang data-title=czTang width=20 height=20 class=avatar style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'>&nbsp;czTang</a></span><span class=post-included-in>&nbsp;收录于 <a href=/blog/categories/static-analysis/ class=post-category title="分类 - Static Analysis"><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> Static Analysis</a> 和 <a href=/blog/collections/static-analysis/ class=post-collection title="合集 - Static Analysis"><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i> Static Analysis</a></span></div><div class=post-meta-line><span title="发布于 2024-12-19 08:18:00"><i class="fa-solid fa-calendar-days fa-fw me-1" aria-hidden=true></i><time datetime=2024.12.19>2024.12.19</time></span>&nbsp;<span title="更新于 2024-12-22 12:22:35"><i class="fa-regular fa-calendar-check fa-fw me-1" aria-hidden=true></i><time datetime=2024.12.22>2024.12.22</time></span>&nbsp;<span title="14211 字"><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 14300 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 29 分钟</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#静态分析概览>静态分析概览</a><ul><li><a href=#静态分析定义>静态分析定义</a></li><li><a href=#静态分析用途>静态分析用途</a></li><li><a href=#静态分析定位>静态分析定位</a></li></ul></li><li><a href=#不完备性>不完备性</a><ul><li><a href=#不可判定>不可判定</a></li><li><a href=#莱斯定理>莱斯定理</a></li><li><a href=#莱斯定理验证>莱斯定理验证</a></li></ul></li><li><a href=#静态分析类型>静态分析类型</a><ul><li><a href=#完美的静态分析>完美的静态分析</a></li><li><a href=#妥协的静态分析>妥协的静态分析</a></li><li><a href=#现实的静态分析>现实的静态分析</a></li></ul></li><li><a href=#编译基础>编译基础</a><ul><li><a href=#词法分析>词法分析</a></li><li><a href=#语法分析>语法分析</a></li><li><a href=#语义分析>语义分析</a></li><li><a href=#中间表示>中间表示</a><ul><li><a href=#ast-和-ir>AST 和 IR</a></li><li><a href=#三地址码>三地址码</a></li><li><a href=#静态单赋值>静态单赋值</a></li><li><a href=#现实中的-ir>现实中的 IR</a><ul><li><a href=#soot>Soot</a></li><li><a href=#llvm>LLVM</a></li></ul></li></ul></li><li><a href=#优化和代码生成>优化和代码生成</a></li></ul></li><li><a href=#其余参考资料>其余参考资料</a></li></ul></nav></div></div><div class=content id=content><p>记录一下对于静态分析的理解。</p><div class="details admonition tip open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-regular fa-lightbulb" aria-hidden=true></i>前提说明</div><div class=details-content><div class=admonition-content><p>由于笔者知识面受限，所以关于当前系列文章做出以下解释：</p><ol><li>在计算机科学中，<a href=https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90 target=_blank rel="external nofollow noopener noreferrer">程序分析</a> 是指自动分析一个程序的包括正确性、健壮性、安全性和活跃性等特征的过程。程序分析主要研究两大领域：程序的优化和程序的正确性。前者研究如何提升程序性能并且降低程序的资源占用，后者研究如何确保程序完成预期的任务。同时程序分析可以在不执行程序的情况下进行（静态程序分析），也可以在执行时进行（动态程序分析），或结合二者。这里都是来自 wiki 的介绍，而本文的相关术语也遵从上面的介绍，静态分析就是程序分析的一个方面，全称为静态程序分析。</li><li>在我的学习中，感觉静态分析的相关知识和编译器优化的内容存在很大程度上的重叠，所以就将 <a href=https://homepages.dcc.ufmg.br/~fernando/classes/dcc888 target=_blank rel="external nofollow noopener noreferrer">DCC888</a> 的内容也补充进来。后来发现该课程主页的名称为 <strong>Static Program Analysis</strong>，拿过来记录也名正言顺。所以本系列文章就是基于 <a href="https://www.bilibili.com/video/BV1b7411K7P4/?spm_id_from=333.337.search-card.all.click" target=_blank rel="external nofollow noopener noreferrer">《软件分析》</a>，<a href="https://www.bilibili.com/video/BV1Rt4y1s7tC/?spm_id_from=333.337.search-card.all.click" target=_blank rel="external nofollow noopener noreferrer">《软件分析技术》</a>，<a href="https://www.youtube.com/playlist?list=PLC-dUCVQghfdu7AG5f_p4oRyKgjDuoAWU" target=_blank rel="external nofollow noopener noreferrer">《DCC888》</a> 三门课程与其余参考资料所写的笔记。</li></ol></div></div></div><h2 id=静态分析概览 class=heading-element><span>静态分析概览</span>
<a href=#%e9%9d%99%e6%80%81%e5%88%86%e6%9e%90%e6%a6%82%e8%a7%88 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><div class="details admonition abstract open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-clipboard-list" aria-hidden=true></i>注意事项</div><div class=details-content><div class=admonition-content><p>下面的内容大部分来自于 <a href=https://zhuanlan.zhihu.com/p/417187798 target=_blank rel="external nofollow noopener noreferrer">沉浸式《程序分析》教材</a>，但是在那篇文章中，对于程序分析的描述为本文一开始提到的静态程序分析。所以在这篇文章中，采用静态分析替代那篇文章中的程序分析。</p></div></div></div><h3 id=静态分析定义 class=heading-element><span>静态分析定义</span>
<a href=#%e9%9d%99%e6%80%81%e5%88%86%e6%9e%90%e5%ae%9a%e4%b9%89 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>静态分析</div><div class=details-content><div class=admonition-content><p><strong>静态分析（Static Analysis）</strong> 是一种在实际运行程序 <em>P</em> 之前，通过分析静态程序 <em>P</em> 本身来推测程序的行为，并判断程序是否满足某些特定的 <strong>属性（Property）</strong> <em>Q</em> 的方法。</p></div></div></div><p>上述中静态程序指的就是不运行程序的状态，它也被称为 “静态” 或 “编译时”，它与程序的 “动态” 和 “运行时” 相对应。由此可以看出，静态分析就是对于给定的程序代码进行自动化扫描、分析，而不必运行程序。</p><h3 id=静态分析用途 class=heading-element><span>静态分析用途</span>
<a href=#%e9%9d%99%e6%80%81%e5%88%86%e6%9e%90%e7%94%a8%e9%80%94 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>静态分析的用处有很多，主要可以分为下面的内容：</p><ul><li><strong>程序可靠性（Program Reliability）</strong>：空指针异常而导致的程序崩溃会影响程序的可靠性，诸如这样的 <em>bug</em> 还存在很多，但是他们中很多都可以在没有运行的状态下被静态分析检测出来。同时导致程序不响应的程序缺陷，例如内存泄漏，也会被静态分析检测出来。</li><li><strong>程序安全性（Program Security）</strong>：对于程序中的可能引起注入攻击等的缺陷代码，静态分析也可以进行识别。</li><li><strong>编译优化（Compiler Optimization）</strong>：在将源码编译为目标平台程序的过程中，静态分析可以在中间环节对中间代码进行优化。其中 <em>Dead code elimination</em> 可以避免永远执行不到的代码最终编译到目标平台程序中；<em>Code motion</em> 可以将循环中的某些计算不变式语句提取到循环外部，进行避免冗余计算，提高程序运行速度。</li><li><strong>程序理解（Program Understanding）</strong>：<em>IDE</em> 提供的不止有代码编辑功能，还有程序理解功能。比如 <em>IDE</em> 可以提示代码的调用关系、继承关系、声明类型等信息，这些关于程序的诸多信息的提取很多都是通过静态分析技术来完成的。</li></ul><h3 id=静态分析定位 class=heading-element><span>静态分析定位</span>
<a href=#%e9%9d%99%e6%80%81%e5%88%86%e6%9e%90%e5%ae%9a%e4%bd%8d class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>静态分析属于程序设计语言的一部分，而程序设计语言主要分为三类研究内容：</p><ul><li><strong>理论</strong>：设计一款程序设计语言一般是从其语法、语义的设计开始，也包括选择什么类型系统，支持什么语言特性等问题。一般情况下，这类理论研究一般可以自证，即可以将语言的语法、语义、类型系统等形式化，然后在其形式化基础上用理论方法证明该语言的诸多属性，这也就是为什么很多 <em>PL</em> 的论文并没有实现实验部分。</li><li><strong>环境</strong>：程序设计语言有了理论设计，在实际中想要运行的起来，必须要有支撑它的环境系统，这主要包括编译系统和运行时系统两个部分。编译系统强调语法的解析（如果是静态语言还会有类型检查等），运行时系统强调语义的解释执行（比解释器更复杂的运行时系统也会负责垃圾回收等内存问题）。<em>PL</em> 的环境系统往往避免不了在实现细节上做很多脏活累活，使得语言在实际中真能好用起来。</li><li><strong>应用</strong>：有了理论与环境的支撑，语言就能跑起来了。然而，一个工业级的程序设计语言通常是一个非常复杂的系统，如何保障该复杂系统的可靠性、安全性、高性能等需求，是需要一系列方法来支撑的，这些方法（如静态分析、程序验证、程序合成等）通常要以语言的理论部分为基础（如语法、语义），结合不同的数学理论来完成各自应用的目标。在 <em>PL</em> 应用中，最具代表性的技术就是静态分析。</li></ul><p>虽然程序设计语言数量繁多，但是无非属于以下三大类（称为 <strong>程序设计语言范式，Programming Paradigm</strong>）：</p><ul><li><strong>命令式程序设计语言（Imperative Programming Languages，IP）</strong>：在 <em>IP</em> 中，指令一个一个给出，用条件、循环等来控制逻辑（指令执行的顺序），同时这些逻辑通过程序变量不断修改程序状态，最终计算出结果。尽管 IP 现在都是高级语言了，但是本质上并没有脱离那种 “类似汇编的，通过读取、写入等指令操作内存数据” 的编程方式。国内高等教育中接触的绝大多数编程语言都是 IP 的，比如 Java、C、C++ 等。</li><li><strong>函数式程序设计语言（Functional Programming Language，FP）</strong>：在 <em>FP</em> 中，逻辑（用函数来表达）可以像数据一样抽象起来，复杂的逻辑（高阶函数）可以通过操纵（传递、调用、返回）简单的逻辑（低阶函数）和数据来表达，没有了时序与状态，隐藏了计算的很多细节。不同的逻辑因为没有被时序和状态耦合在一起，程序本身模块化更强，也更利于不同逻辑被并行的处理，同时避免因并行或并发处理可能带来的程序故障隐患，这也说明了为什么 FP 语言如 Haskell 在金融等领域（高并发且需要避免程序并发错误）受到瞩目。</li><li><strong>逻辑式程序设计语言（Logic Programming Language，LP）</strong>：<em>LP</em> 抽象的能力就更强了，计算细节干脆不见了，把想表达的逻辑直观表达出来就好了。如今，在数据驱动计算日益增加的背景下，LP 中的声明式语言，如 Datalog 作为代表开始崭露头角，在诸多专家领域开拓应用市场。</li></ul><h2 id=不完备性 class=heading-element><span>不完备性</span>
<a href=#%e4%b8%8d%e5%ae%8c%e5%a4%87%e6%80%a7 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>由上文静态分析的定义可知，静态分析是通过分析程序的代码而推理出程序在动态运行时可能的行为，然后判断程序是否满足关注的一些属性的一种方法。这里关注的信息可能是：</p><ul><li>该程序是否会泄漏私有信息？</li><li>该程序是否会引用空指针？</li><li>该程序中所有 cast 操作都是安全的吗？</li><li>该程序的这块代码是否是死代码？</li><li>&mldr;&mldr;</li></ul><p>可以看出，静态分析可以判断的属性有很多，而且有些至关重要。所以如果静态分析可以准确无误地判断上述程序的所有属性，那么程序就不愁还会存在可靠性和安全性的问题了，只需要关注于静态分析的优化即可。但是显示情况却不是这样的，这就需要下面一系列理论的支持了。</p><h3 id=不可判定 class=heading-element><span>不可判定</span>
<a href=#%e4%b8%8d%e5%8f%af%e5%88%a4%e5%ae%9a class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>可判定问题是指：对于回答是或否的问题，如果存在一个算法，使得对于该问题的每一个实例都能给出 是/否 的答案，那么这个问题就是可判定问题。而将这个问题转移到程序上面，就是说对于一个程序或者代码而言，只看其初始状态，而不运行这个程序，那么是否可以判断其是否会停机？答案就是它是不可判定的。</p><p>而要知道它为什么是不可判定问题，就需要知道哥德尔不完备定理和图灵停机问题的相关知识，因此可以从 <a href="https://www.bilibili.com/video/BV1o7421K7pY/?spm_id_from=333.1387.upload.video_card.click&amp;vd_source=17ac9da9453dbd6d64b9616668574c5f" target=_blank rel="external nofollow noopener noreferrer">停机悖论三句话就能证明不完备性定理？</a> 来进行了解。在观看之后就可以明白一个概念，不存在一个算法能够回答停机问题，它是不可判定的。</p><h3 id=莱斯定理 class=heading-element><span>莱斯定理</span>
<a href=#%e8%8e%b1%e6%96%af%e5%ae%9a%e7%90%86 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>现在关注 <strong>静态分析是否可以准确无误地判断上述程序的所有属性问题</strong>，那么就需要引入莱斯定理。</p><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>Rice 定理</div><div class=details-content><div class=admonition-content><p>对于使用 <strong>递归可枚举（Recursively Enumerable）</strong> 的语言描述的程序，其任何 <strong>非平凡（Non-trivial）</strong> 的属性都是不可判定的。</p></div></div></div><p>这里的 <strong>递归可枚举</strong> 就可以理解为图灵完备语言；而对于 <strong>非平凡属性</strong>，定义一个属性是平凡的，那么这个属性要么对任何一个递归可枚举语言编写的所有程序为真，要么为假，否则它就是非平凡的。由此可以把这里的非平凡属性理解为和程序运行时行为相关的属性，它体现的是一种语义相关而不是语法相关的属性。例如，一个程序是否存在 while 循环、是否存在左右括号等类似的就是和 <strong>语法相关</strong> 的属性，而这里讨论的是否会泄漏私有信息等就是和 <strong>语义相关</strong> 的属性。因此可以进一步将莱斯定理理解为下面的表述：</p><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>Rice 定理</div><div class=details-content><div class=admonition-content><p>一个程序的任何语义（运行时行为）相关的属性都是不可判定的。</p></div></div></div><h3 id=莱斯定理验证 class=heading-element><span>莱斯定理验证</span>
<a href=#%e8%8e%b1%e6%96%af%e5%ae%9a%e7%90%86%e9%aa%8c%e8%af%81 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>既然成功理解了莱斯定理，知道其含义，那么就需要知道它为什么是正确的，这样就涉及到上面提起的不可判定了。这里的证明思路需要和图灵机停机进行联系，也就是将证明这个问题（非平凡属性）是否可判定 <strong>规约</strong> 到是否可以判定图灵机停机问题上。如此一来，如果该问题可判定，那么就可以得到图灵停机问题也可以判定的结果，继而根据已知事情反证出来该问题不可判定。下面就是使用 <em>python</em> 来定义一个 <code>Halt</code> 函数：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>Halt</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=n>i</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>trick</span><span class=p>(</span><span class=n>k</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span><span class=p>(</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>k</span> <span class=o>*</span> <span class=n>k</span> <span class=o>*</span> <span class=n>k</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>is_cube</span><span class=p>(</span><span class=n>trick</span><span class=p>)</span></span></span></code></pre></td></tr></table></div></div><p>这里 Halt 函数用来判定在给定程序 p 和输入 i 的条件下，p 是否会停机。之后再内部定义一个函数 <code>trick</code>，它的输入是 k，首先执行输入为 i 的程序 p，之后返回输入 k 的立方。如果 p(i) 不停机，也就是一直处于运行状态，那么这个 trick 函数就不会进行返回操作；而如果 p(i) 能够停机，那么这个函数就会返回给定参数的立方值。</p><p>现在假设 Halt 函数中的 <code>is_cube(trick)</code> 是可以确切无误地判断 <strong>给定函数 trick 是否可以计算立方值问题</strong> 的函数（这里可以把计算立方值替换为任何非平凡的属性），那么就可以得到下面的两种情况：</p><ol><li>p(i) 会停机，之后 trick 就会返回立方值，又因为 is_cube(trick) 可以确切判断出 trick 可以计算立方值，因此 <code>is_cube(trick) = Halt(p, i) = true</code>，也就是判定了程序可以停止。</li><li>p(i) 不会停机，之后 trick 不会返回立方值，而此时 is_cube(trick) 可以确切判断出 trick 不可以计算立方值，因此 <code>is_cube(trick) = Halt(p, i) = false</code>，也就是判定了程序不可以停机。</li></ol><p>从上述可以知道，如果真存在一个可判定非平凡属性是否为真的算法（即这里的 <code>is_cube</code>），那么就可以得到一个可判断图灵提及的算法（即这里的 <code>Halt</code>），即可以通过调用 <code>is_cube(trick)</code> 的结果准确的判断程序 p 是否会停机。但是又因为图灵停机问题是不可判定的，因此就不存在一个可判定非平凡属性的算法，那么莱斯定理就成立了。</p><h2 id=静态分析类型 class=heading-element><span>静态分析类型</span>
<a href=#%e9%9d%99%e6%80%81%e5%88%86%e6%9e%90%e7%b1%bb%e5%9e%8b class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><h3 id=完美的静态分析 class=heading-element><span>完美的静态分析</span>
<a href=#%e5%ae%8c%e7%be%8e%e7%9a%84%e9%9d%99%e6%80%81%e5%88%86%e6%9e%90 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>完美的静态分析</div><div class=details-content><div class=admonition-content><p>如果一个静态分析 <em>S</em> 能够对于程序的某个非平凡性质 <em>Q</em> 给出确切的答案，就称 <em>S</em> 是 <em>P</em> 关于 <em>Q</em> 的 <strong>完美静态分析（Perfect Static Analysis）</strong>。定义程序 <em>P</em> 关于 <em>Q</em> 的真实性为 <strong>真相（Truth）</strong>，那么完美静态分析有两层含义：</p><ul><li><strong>完全性（soundness）</strong>：真相一定包含在 <em>S</em> 给出的答案中；</li><li><strong>正确性（completeness）</strong>：<em>S</em> 给出的答案一定包含在真相中；</li></ul><p>那么记这个静态分析程序给出的答案集合 <em>A</em>，真相集合为 <em>T</em>，则完美的静态分析满足：
$$
T ⊆ A ∧ A ⊆ T ⇔ A = T
$$
其中，$T⊆A$ 体现了 <strong>soundness</strong>，$A⊆T$ 体现了 <strong>completeness</strong>。</p></div></div></div><p>根据上述的定义可知，一个完美的静态分析得到的结果是正确的，也是全面的，但是由上文的莱斯定理可以知道并不存在一个完美的方法可以准确判断任意程序的非平凡属性是否为真，也就是说不存在一个既能 <strong>Sound</strong> 又能 <strong>Complete</strong> 的静态分析方法。那么这里的静态分析是否就没用了呢？其实并不是，sound 和 complete 之间就是进行探索的领域。</p><h3 id=妥协的静态分析 class=heading-element><span>妥协的静态分析</span>
<a href=#%e5%a6%a5%e5%8d%8f%e7%9a%84%e9%9d%99%e6%80%81%e5%88%86%e6%9e%90 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220182000.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220182000.png?size=small" data-sub-html="<h2>20241220182000</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220182000.png alt="soundness & completeness" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220182000.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220182000.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220182000.png?size=large 2x" data-title=20241220182000 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>soundness & completeness</figcaption></figure>因为完美的静态分析并不存在，所以通常需要做一些妥协，也就是在 $T⊆A$ 和 $A⊆T$ 中只尽力满足其中一个条件，妥协另一个条件。于是，就得到了两种妥协后的静态分析类型。</p><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>过近似</div><div class=details-content><div class=admonition-content><p>记程序 <em>P</em> 关于性质 <em>Q</em> 的静态分析 <em>S</em> 为 <strong>Sound</strong> 的静态分析，当且仅当 <em>S</em> 给出的答案集合 <em>A</em> 和 <em>P</em> 关于 <em>Q</em> 的真相集合 <em>T</em> 之间满足：
$$
T⊆A
$$
这种分析策略也成为 <strong>过近似（Over-approximation）</strong>。</p></div></div></div><p>这里 <strong>Sound</strong> 的静态分析保证了 <strong>soundness</strong>，妥协了 <strong>completeness</strong>，会 <strong>过近似（Overapproximate）</strong> 程序的行为，因此会出现 <strong>假阳性（False Positive）</strong> 的现象，即判定为阳性，但实际是阴性的。反映在现实场景中即为 <strong>误报问题</strong>。比如真实的行为（Truth）给定程序存在 5 处空指针引用，那么一个 Sound 的结果就是它至少包含这 5 处空指针引用，即不存在漏报。但是它可能报出 9 处空指针引用，多余的这 4 处空指针引用就是误报，也就是假阳性的情况。但是这样的妥协理论上不但可以帮助找出所有的程序缺陷漏洞，还可以使得静态分析可以用于编译优化和程序验证等应用。这里对于编译优化而言，静态分析就是在判断该优化是否是正确的，所以需要 Sound 的分析来对所有情况进行考虑。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410102122370.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410102122370.png?size=small" data-sub-html="<h2>202410102122370</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410102122370.png alt="False Positive" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410102122370.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410102122370.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410102122370.png?size=large 2x" data-title=202410102122370 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>False Positive</figcaption></figure></p><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>欠近似</div><div class=details-content><div class=admonition-content><p>记程序 <em>P</em> 关于性质 <em>Q</em> 的静态分析 <em>S</em> 为 <strong>Complete</strong> 的静态分析，当且仅当 <em>S</em> 给出的答案集合 <em>A</em> 和 <em>P</em> 关于 <em>Q</em> 的真相集合 <em>T</em> 之前满足：
$$
A⊆T
$$
这种分析策略也成为 <strong>欠近似（Under-approximation）</strong>。</p></div></div></div><p>这里 <strong>Complete</strong> 的静态分析保证了 <strong>completeness</strong>，妥协了 <strong>soundness</strong>，会 <strong>欠近似（Underapproximate）</strong> 程序的行为，因此会出现 <strong>假阴性（False Negative）</strong> 现象，即判定为阴性，但实际是阳性。反映在现实场景中即为 <strong>漏报问题</strong>。比如真实的行为（Truth）给定程序存在 5 处空指针引用，那么一个 Complete 的结果就是它最多包含这 5 处空指针引用，即不存在误报。但是它可能报出 3 处空指针引用，缺少的 2 处空指针引用就是漏报，也就是假阴性的情况。而这样的妥协不影响分析应用的有效性，例如利用静态分析查找程序缺陷和安全漏洞，虽然因为漏报没有找到所有的 bug，但是找到一个 bug 都是有益的。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410102123417.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410102123417.png?size=small" data-sub-html="<h2>202410102123417</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410102123417.png alt="False Negative" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410102123417.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410102123417.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410102123417.png?size=large 2x" data-title=202410102123417 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>False Negative</figcaption></figure></p><h3 id=现实的静态分析 class=heading-element><span>现实的静态分析</span>
<a href=#%e7%8e%b0%e5%ae%9e%e7%9a%84%e9%9d%99%e6%80%81%e5%88%86%e6%9e%90 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>而现在，无论是怎样的分析应用，静态分析的设计都是在努力追求更好的 <strong>soundness</strong>。因为这样的分析会覆盖到更多的程序行为，对于像编译优化和程序验证这种应用，静态分析必须是 Sound 的，否则它会影响优化和验证的正确性。对于 Sound 可以通过下面的例子进一步理解：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=k>if</span> input <span class=k>then</span>
</span></span><span class=line><span class=cl>    <span class=nv>x</span> <span class=o>=</span> 1<span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=nv>x</span> <span class=o>=</span> 0<span class=p>;</span>
</span></span><span class=line><span class=cl>output x<span class=p>;</span></span></span></code></pre></td></tr></table></div></div><p>对于上面的代码，存在两种 Sound 的静态分析：</p><ul><li>当 <em>input</em> 为 <em>true</em>，x 是 1，当 <em>input</em> 为 <em>false</em>， x 是 0 ；</li><li>x 是 0 或 1</li></ul><p>这两种都保证了 soundness，不过前者更精确，代价也更高，分析速度慢；后者不那么精确，但相应代价也会更低一点，分析速度快。前者精确，但是需要维护条件分支的信息，需要额外的开销，如果针对一定规模的程序，这个开销将占据非常多的资源，很大程度上会拖累分析的速度；相比之下，后者不那么精准，但是因为不用维护额外的信息，分析速度会很快。由此可以对现实世界中的静态分析进行总结：</p><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>现实中的静态分析</div><div class=details-content><div class=admonition-content><p>现实中的静态分析需要在确保（尽可能接近）soundness 的前提下，在速度和精度之间做一个合适的权衡。</p></div></div></div><p>上述中尽可能接近 soundness，是因为在不少实际应用场景中，取得完全的 soundness 是困难的。例如分析 java 程序，那么 java 语言的反射特性、动态类加载特性以及 native 代码调用，都会在很大程度上影响分析的 soundness。在这种情况下，就是需要分析尽可能地接近 soundness 了。当下鉴于 soundness 对普遍应用的重要性，以及对部分应用的必要性，为 <strong>方便理解</strong>，如无特殊说明，静态分析都应做 Overapproximate 以获取 soundness。</p><h2 id=编译基础 class=heading-element><span>编译基础</span>
<a href=#%e7%bc%96%e8%af%91%e5%9f%ba%e7%a1%80 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><div class="details admonition abstract open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-clipboard-list" aria-hidden=true></i>注意事项</div><div class=details-content><div class=admonition-content><p>在最初的<code>前提说明</code>中，我提到自己认为静态分析与编译器优化（尤其是编译的中后端内容）之间存在较大的重叠。因此，我觉得有必要了解一些编译相关的知识，并记录了相关内容。以下内容主要参考了 <a href=https://blog-blockchain.xyz/pl/understanding-program-analysis target=_blank rel="external nofollow noopener noreferrer">（一）初始软件分析</a>，对编译基础进行一个概括性的介绍。详细内容可以参见 <a href=https://cztangt.github.io/blog/categories/compile/ target=_blank rel="external nofollow noopener noreferrer">compile</a> 中的相关内容。</p></div></div></div><p><strong>编译器（Compiler）</strong> 是一种计算机程序，它会将用某种编程语言写成的源代码（原始语言），转换成另一种编程语言（目标语言）。一般来说编译器的内部包含了如下的工作步骤：</p><ol><li>词法分析；</li><li>语法分析；</li><li>语义分析；</li><li>生成中间表示（intermediate representation，IR）；</li><li>优化；</li><li>代码生成；</li></ol><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220202616.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220202616.png?size=small" data-sub-html="<h2>20241220202616</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220202616.png alt=编译器工作步骤 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220202616.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220202616.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220202616.png?size=large 2x" data-title=20241220202616 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>编译器工作步骤</figcaption></figure></p><p>在这里，编译器的前端对接各种编程语言，对编程语言本身进行语法和语义分析，中端则负责代码优化，后端对接各种硬件架构，负责生成对应硬件下的可执行文件。而对于静态分析而言，关注的就是中间代码上的优化部分。</p><h3 id=词法分析 class=heading-element><span>词法分析</span>
<a href=#%e8%af%8d%e6%b3%95%e5%88%86%e6%9e%90 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p><strong>词法分析（lexical analysis）</strong> 的主要工作是将源代码的字符流转换成 <em>Token</em>（词法单元） 流，在这里，词法分析器会根据给定的规则把输入的源代码构建成 <em>Token</em>。例如对于 <code>int a = 0;</code>，就会产生 $int, \ a, \ =, \ 0, \ ;$ 这几个 Token。具体而言，Token 分为种别码和属性值，种别码是一个标识符，用于区分不同类型的 token，编译器就是通过它来识别和分类 token 的关键信息；而属性值就是 token 的具体信息了，它会在后续的语法分析和语义分析阶段被用于构建语法树和进一步的处理。下面就是种别码的不同类型，可以看出它是程序的关键字部分。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220210432.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220210432.png?size=small" data-sub-html="<h2>20241220210432</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220210432.png alt=种别码类型 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220210432.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220210432.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220210432.png?size=large 2x" data-title=20241220210432 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>种别码类型</figcaption></figure></p><p>下面就是一个简单的词法分析过程，输出的内容就是输入的字符流进行转化的结果。第一列就是字符，后面使用 <strong>&lt; ></strong> 包围的就是转换后的 Token 了。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220210617.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220210617.png?size=small" data-sub-html="<h2>20241220210617</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220210617.png alt=词法分析 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220210617.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220210617.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220210617.png?size=large 2x" data-title=20241220210617 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>词法分析</figcaption></figure></p><p>词法分析器可以读入字符流，然后转化为 Token，但是词法分析器的产生过程是不容易的。下图就展示了词法分析器代码产生的过程。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220212709.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220212709.png?size=small" data-sub-html="<h2>20241220212709</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220212709.png alt=词法分析流程 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220212709.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220212709.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220212709.png?size=large 2x" data-title=20241220212709 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>词法分析流程</figcaption></figure></p><p><strong>词法分析器</strong> 的产生始于对语言模式的定义，即需要知道对于某个字符，应该进行怎样的处理。而正则表达式（RE）正是描述语言词法规则的一种简洁而有效的工具。例如，<strong>正则表达式</strong> <code>[a-zA-Z_][a-zA-Z0-9_]*</code> 可以定义标识符的格式，而 <code>[0-9]+</code> 则可以描述整数常量。然而，正则表达式只是对模式的抽象描述，并不能直接用于字符流的解析。为了将正则表达式转化为实际可执行的结构，首先需要构造非确定性有限自动机（NFA）。<strong>NFA</strong> 是正则表达式的一种等价形式，它通过状态和状态间的转移来表示语言的匹配过程。NFA 的一个显著特点是它允许非确定性迁移，即在某个状态下，读取一个字符可以有多个可能的转移，这为复杂的模式解析提供了灵活性。NFA 的构造通常采用 Thompson 构造法，将简单的正则表达式片段逐步拼接为完整的自动机结构。</p><p>如下图就是 RE 向 NFA 的转化过程，上面的公式就是正则表达式的匹配公式。可以看出，随着对于正则表达式的不断解析，NFA 的构建也逐渐完善。这里的圆圈就是状态，随着中间箭头上字符的输入，状态进行不同的转移，从而匹配相应的正则表达式规则，即语法规则。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220223331.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220223331.png?size=small" data-sub-html="<h2>20241220223331</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220223331.png alt="NFA 结构" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220223331.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220223331.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220223331.png?size=large 2x" data-title=20241220223331 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>NFA 结构</figcaption></figure></p><p>然而，NFA 的非确定性也导致了解析效率的下降，因为在解析时可能需要同时跟踪多个状态，例如下图中 NFA 的 1 状态到 2、4 状态。为了解决这个问题，需要将 NFA 转换为确定性有限自动机（DFA）。<strong>DFA</strong> 通过子集构造法将 NFA 的多个状态集合映射为一个确定的状态，从而消除了非确定性。DFA 的每个状态都可以看作是 NFA 的一个状态集合，因此保留了与 NFA 等价的语言匹配能力，但解析效率得到了显著提高，因为在 DFA 中，每次读取一个字符只会有唯一的状态迁移。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220223752.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220223752.png?size=small" data-sub-html="<h2>20241220223752</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220223752.png alt="DFA 结构" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220223752.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220223752.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220223752.png?size=large 2x" data-title=20241220223752 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>DFA 结构</figcaption></figure></p><p>在得到 DFA 后，接下来的任务是将其转化为实际的词法分析器代码。DFA 本质上是一个状态迁移表，可以直接映射到代码实现中。词法分析器通过模拟 DFA 的运行过程，从字符流中逐个读取字符，根据 DFA 的状态迁移规则移动到下一个状态。当到达终止状态时，词法分析器便生成对应的 Token，并继续解析后续的字符。如果某个字符无法匹配任何状态迁移，则报告词法错误。通过这种方式，词法分析器实现了从正则表达式到自动机、再到代码的完整转换流程，从而能够高效地将源代码的字符流解析为词法单元。</p><h3 id=语法分析 class=heading-element><span>语法分析</span>
<a href=#%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p><strong>语法分析（parsing）</strong> 就是从词法分析器生成的 Token 流出发，根据特定语言的 <a href=https://zh.wikipedia.org/wiki/%E5%BD%A2%E5%BC%8F%E6%96%87%E6%B3%95 target=_blank rel="external nofollow noopener noreferrer">形式文法</a> 规则对 Token 进行结构化分析，从而确定输入文本的语法结构。形式文法（如上下文无关文法）定义了语言的语法规则，可以描述合法句子的结构和嵌套关系。语法分析的目标是验证这些规则是否被满足，同时将 Token 组织成有意义的结构。可以将这一过程类比为从单词（Token）构造语句：词法分析生成了“单词”，而语法分析负责根据语言规则将这些单词组合成语法正确的“句子”。</p><p>为了完成这一目标，语法分析器需要根据形式文法生成语法树，这种树形结构反映了 Token 在语法规则中的嵌套关系。例如，下图展示了从 Token 到语法树的构造过程，语法树的层次关系表示了不同语法规则的应用：<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220225227.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220225227.png?size=small" data-sub-html="<h2>20241220225227</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220225227.png alt=语法分析过程 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220225227.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220225227.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220225227.png?size=large 2x" data-title=20241220225227 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>语法分析过程</figcaption></figure></p><p><strong>语法分析器（parser）</strong> 的实现通常涉及两种主要的解析方法：自顶向下解析和自底向上解析。自顶向下解析以语言的起始符号为根，根据文法规则尝试生成整个输入的结构化表示，例如递归下降法；而自底向上解析则从输入的 Token 开始，逐步将其归约为更高层次的语法结构，例如使用 LR 分析方法。</p><p>在构造语法树时，语法分析器将通过匹配 Token 和文法规则来完成 Token 的层次化组织。例如，对于以下伪代码的辗转相除法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>while</span> <span class=nx>b</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>a</span> <span class=p>&gt;</span> <span class=nx>b</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nx>a</span> <span class=o>:=</span> <span class=nx>a</span> <span class=o>-</span> <span class=nx>b</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nx>b</span> <span class=o>:=</span> <span class=nx>b</span> <span class=o>-</span> <span class=nx>a</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=nx>a</span></span></span></code></pre></td></tr></table></div></div><p>语法分析器将根据文法规则对 Token 流进行处理，最终生成以下的 <strong>抽象语法树（AST）</strong>：<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220230131.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220230131.png?size=small" data-sub-html="<h2>20241220230131</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220230131.png alt=抽象语法树 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220230131.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220230131.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241220230131.png?size=large 2x" data-title=20241220230131 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>抽象语法树</figcaption></figure></p><p>抽象语法树是一种高层次的表达方式，删除了文法中不必要的细节，仅保留了表达程序结构和逻辑的核心信息。这种结构不仅便于程序的后续分析（如语义检查或优化），还能够作为解释器或编译器的输入。</p><p>通过这样的流程，语法分析实现了从 Token 到语法结构的转化，验证了输入代码的语法正确性，同时生成了表达程序逻辑的层次化数据结构。</p><h3 id=语义分析 class=heading-element><span>语义分析</span>
<a href=#%e8%af%ad%e4%b9%89%e5%88%86%e6%9e%90 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p><strong>语义分析（semantic analysis）</strong> 建立在语法分析生成的抽象语法树（AST）之上，旨在验证程序的逻辑正确性，确保程序的各部分含义符合语言的语义规则。语法分析关注的是形式结构是否符合文法，而语义分析则进一步检查这些结构是否具有合法的意义。例如，在变量赋值中，语法分析确保了赋值表达式的结构正确，而语义分析则要验证变量是否已声明、数据类型是否匹配等。</p><p>语义分析的核心任务可以分为以下几个方面：</p><ul><li><strong>类型检查</strong>：验证表达式、操作符及赋值操作是否符合语言的类型规则。例如，在赋值语句 <code>a = b + c;</code> 中，语义分析需确保 b 和 c 的类型是数值类型，且 <code>b + c</code> 的结果可以赋值给 a 的类型。类似地，函数调用时参数类型需与函数声明的参数类型一致。</li><li><strong>作用域检查</strong>：确认符号的引用是否在其合法作用域内。通过符号表，语义分析会在变量或函数被引用时查找它们的声明位置，若在当前作用域及其父作用域中均未找到匹配声明，则会报错。例如，若在函数内部使用一个未定义的变量，则语义分析会捕捉到这一错误。</li><li><strong>符号表管理</strong>：符号表记录程序中每个符号的相关信息，包括变量名、数据类型、作用域、初始值、存储位置等。语义分析会动态更新符号表，例如在变量声明时插入记录，在变量使用时查找匹配条目。</li><li><strong>属性计算</strong>：为语法树的每个节点附加语义信息，例如变量的类型、数组的维度、函数的返回值等。这些信息既用于当前的语义分析，也为后续阶段（如中间代码生成和优化）提供支持。例如，在表达式 <code>a + b</code> 中，属性计算需要确认 a 和 b 的类型，并推导出整个表达式的类型。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>b</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=n>b</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>a</span> <span class=o>&gt;</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span> <span class=o>=</span> <span class=n>a</span> <span class=o>-</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>b</span> <span class=o>=</span> <span class=n>b</span> <span class=o>-</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=n>a</span><span class=p>;</span></span></span></code></pre></td></tr></table></div></div><p>对于上述代码，语义分析的任务包括：</p><ol><li>符号表检查：变量 a 和 b 在声明后被插入符号表。随后，语义分析会在使用 a 和 b 时在符号表中查找它们的定义并验证是否符合上下文需求。</li><li>类型检查：表达式 <code>b != 0</code> 会被验证是否返回布尔值；减法操作 <code>a - b</code> 会检查操作数是否都是整型，并确保结果能赋值给变量 a 或 b。</li><li>作用域管理：验证 a 和 b 的作用域合法性，确保它们在 <code>while</code> 和 <code>if-else</code> 的嵌套语句中可见。</li><li>返回值验证：<code>return a;</code> 的返回值类型必须与函数声明的返回类型一致。</li></ol><p>语义分析通过对抽象语法树（AST）的遍历标注和符号表的交互，将类型检查、作用域验证等任务贯穿于整个代码分析过程。当语义分析的所有检查均通过时，程序被认为在逻辑上是正确的。与语法分析的形式验证相比，语义分析更关注程序的逻辑合理性。例如，语法分析可能允许 <code>int a = "string;"</code> 形式正确。但语义分析会根据类型规则报告错误。</p><p>下图就是对于抽象语法树进行标注而生成的 <strong>注释语法分析树</strong>，可以看出其与抽象语法树相比，标明了数据类型，初始值等信息。根据这些标明的信息，语义分析就可以对语法分析的结果进行进一步的审查，以确保程序的各部分含义符合语言的语义规则。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241221172432.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241221172432.png?size=small" data-sub-html="<h2>20241221172432</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241221172432.png alt=注释语法分析树 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241221172432.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241221172432.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241221172432.png?size=large 2x" data-title=20241221172432 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>注释语法分析树</figcaption></figure></p><p>语义分析的结果是为后续阶段（如中间代码生成或优化）提供更为具体和完整的语义信息，同时确保输入代码的逻辑正确性。借助语义分析，编译器能够更准确地捕获语义错误，例如类型不匹配、未定义变量使用或非法操作，从而提高程序的健壮性和可靠性。</p><h3 id=中间表示 class=heading-element><span>中间表示</span>
<a href=#%e4%b8%ad%e9%97%b4%e8%a1%a8%e7%a4%ba class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><div class="details admonition abstract open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-clipboard-list" aria-hidden=true></i>注意事项</div><div class=details-content><div class=admonition-content><p>这部分内容主要来自课程笔记 <a href=https://static-analysis.cuijiacai.com/02-ir/ target=_blank rel="external nofollow noopener noreferrer">程序的中间表示</a>，也就是 <a href="https://www.bilibili.com/video/BV1b7411K7P4/?spm_id_from=333.337.search-card.all.click" target=_blank rel="external nofollow noopener noreferrer">《软件分析》</a> 课程讲述的内容。</p></div></div></div><p>由上文可以知道编程语言转换为目标机器代码的过程中，会经历词法分析、语法分析、语义分析的前端阶段，然后得到了抽象语法树。之后 <strong>翻译器（Translator）</strong> 会将抽象语法树翻译成 <strong>中间表示（Intermediate Representation, IR）</strong>，也就是中间代码，IR 的出现解耦了编译器的机器相关部分和机器无关部分，在这一步之前都是和机器无关的，也就是说这几个阶段可以在不同架构的机器上几乎不加改动地复用，而后面的目标代码生成，对于不同架构的机器需要进行不同的处理。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241221161300.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241221161300.png?size=small" data-sub-html="<h2>20241221161300</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241221161300.png alt=源代码转化为机器码 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241221161300.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241221161300.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241221161300.png?size=large 2x" data-title=20241221161300 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>源代码转化为机器码</figcaption></figure></p><p>上图就是将源代码转化为机器码的过程，其中翻译器和代码生成中间的产物 IR 就是静态分析的目标。而下图也简洁的展示了静态分析关注的是编译器的中端，也就是生成中间代码和优化的部分。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241221164016.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241221164016.png?size=small" data-sub-html="<h2>20241221164016</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241221164016.png alt=编译器结构 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241221164016.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241221164016.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241221164016.png?size=large 2x" data-title=20241221164016 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>编译器结构</figcaption></figure></p><h4 id=ast-和-ir class=heading-element><span>AST 和 IR</span>
<a href=#ast-%e5%92%8c-ir class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>do</span> <span class=n>i</span> <span class=o>=</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>v</span><span class=p>);</span></span></span></code></pre></td></tr></table></div></div><p>对于上面的代码，可以转化为相应的抽象语法树和中间表示：</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241221172143.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241221172143.png?size=small" data-sub-html="<h2>20241221172143</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241221172143.png alt="AST 和 IR" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241221172143.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241221172143.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241221172143.png?size=large 2x" data-title=20241221172143 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>AST 和 IR</figcaption></figure></p><table><thead><tr><th>AST</th><th>IR</th></tr></thead><tbody><tr><td>层次更高，和语法结构更接近</td><td>低层次，和机器代码相接近</td></tr><tr><td>通常是依赖于具体的语言类的</td><td>通常和具体的语言无关，主要和运行语言的机器（物理机或虚拟机）有关</td></tr><tr><td>适合快速的类型检查</td><td>简单通用</td></tr><tr><td>缺少和程序控制流相关的信息</td><td>包含程序的控制流信息</td></tr><tr><td></td><td>通常作为静态分析的基础</td></tr></tbody></table><h4 id=三地址码 class=heading-element><span>三地址码</span>
<a href=#%e4%b8%89%e5%9c%b0%e5%9d%80%e7%a0%81 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>三地址码</div><div class=details-content><div class=admonition-content><p>将形如 $f(a_1, a_2, \ldots, a_n)$ 的指令称为 <strong>n 地址码（N-Address Code）</strong>。其中，每一个 $a_i$ 是一个地址，既可以通过 $a_i$ 传入数据，也可以通过 $a_i$ 传出数据，$f$ 是从地址到语句的一个映射，其返回值是某个语句 <em>s</em>，<em>s</em> 中最多包含输入的 <em>n</em> 个地址。这里，我们定义某编程语言 <em>L</em> 的语句 <em>s</em> 是 <em>L</em> 的操作符、关键字和地址的组合。</p></div></div></div><p>如上图采用的就是三地址码的形式，之后章节使用就是三地址码的 IR，这是因为一方面经典的分析算法是以三地址码作为 IR 的所以这种表示方法就一直沿用着；另一方面是因为它表示上更加简洁方便且表达能力完备。</p><p>对于三地址码而言，其地址可能存在下面几种类型：</p><ul><li>名字（Name），包括变量（Variable），用于只是程序位置、方便跳转指令书写的标签（Label）</li><li>字面常量（Literal Constant）</li><li>编译器生成的临时量（Compiler-Generated Temporaty）</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>x = y bop z
</span></span><span class=line><span class=cl>x = uop y
</span></span><span class=line><span class=cl>x = y
</span></span><span class=line><span class=cl>goto L
</span></span><span class=line><span class=cl>if x goto L
</span></span><span class=line><span class=cl>if x rop y goto L</span></span></code></pre></td></tr></table></div></div><p>对于上述三地址码形式进行分析：</p><ul><li><code>x, y, z</code> 是变量的地址。</li><li><code>bop</code> 是双目操作符（Binary Operator），可以是算数运算符，也可以是逻辑运算符。</li><li><code>uop</code> 是单目操作符（Unary Operator），可能是取负、按位取反或者类型转换。</li><li><code>L</code> 是标签（Label），是标记程序位置的助记符，本质上还是地址。</li><li><code>rop</code> 是关系运算符（Relational Operator），运算结果一般为布尔值。</li><li><code>goto</code> 是无条件跳转， <code>if ... goto</code> 是条件跳转。</li></ul><p>三地址码类似于汇编，但是比汇编的结构更为简单，同时需要注意无论是三地址码还是汇编，其指令类型不取决于具体的语言，而取决于运行这个语言的机器的 <strong>指令集体系结构（Instruction Set Architecture，ISA）</strong>。</p><h4 id=静态单赋值 class=heading-element><span>静态单赋值</span>
<a href=#%e9%9d%99%e6%80%81%e5%8d%95%e8%b5%8b%e5%80%bc class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p><strong>静态单赋值（Static Single Assignment，SSA）</strong> 是另一种IR的形式，它和三地址码的区别是，在每次赋值的时候都会创建一个新的变量，也就是说，在 SSA 中，每个变量（包括原始变量和新创建的变量）都只有唯一的一次定义。下图就是三地址码转化为的 SSA 形式。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241221174958.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241221174958.png?size=small" data-sub-html="<h2>20241221174958</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241221174958.png alt=中间表示比对 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241221174958.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241221174958.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241221174958.png?size=large 2x" data-title=20241221174958 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>中间表示比对</figcaption></figure></p><p>在没有控制语句的情况下，三地址码可以很简单地转化为 SSA 形式。但是在存在控制语句的情况下，对于 SSA 就需要额外处理。下图就展示了存在控制语句 if 的情况，在这个情形下，<code>y = x + 7</code> 的取值就收到上方不同分支中的 $x_0$ 和 $x_1$ 的影响。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241221175018.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241221175018.png?size=small" data-sub-html="<h2>20241221175018</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241221175018.png alt="merge 操作" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241221175018.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241221175018.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241221175018.png?size=large 2x" data-title=20241221175018 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>merge 操作</figcaption></figure></p><p>而对于这种控制流汇合（Merge）的情况，就需要使用特殊的 $\phi$ 函数来表示汇合的操作：</p><p>$$
x_3 = \phi(x_1, x_2) = \begin{cases}
x_1, & \text{if true} \\
x_2, & \text{otherwise}
\end{cases}
$$</p><p>上面的公式表示了对于两条路径的选择，但是在现实数据流分析中，要求 Sound 的分析不会放弃任何一条路径的结果。所以这个 $\phi$ 函数在某些情况下可能会采用其他形式处理，例如将上面的公式表示为 $x_3 = \{ x_1, x_2 \}$，以此说明最终结果同时包含了两条路径的结果。</p><h4 id=现实中的-ir class=heading-element><span>现实中的 IR</span>
<a href=#%e7%8e%b0%e5%ae%9e%e4%b8%ad%e7%9a%84-ir class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><h5 id=soot class=heading-element><span>Soot</span>
<a href=#soot class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>在现实中，对于不同的编程语言，采用的 IR 一般不同。例如对于 java(Android) 的静态分析而言，最多使用的就是 <strong>Soot</strong> 这个 Java 字节码分析工具，它提供了多种字节码分析和变换功能，通过它可以进行过程内和过程间的分析优化，以及程序流图的生成，还能通过图形化的方式输出，让用户对程序有个直观的了解。尤其是做单元测试的时候，可以很方便的通过这个生成控制流图然后进行测试用例的覆盖，显著提高效率。它同时也是一个字节码优化框架，内部对于同一个程序存在四种中间表示：</p><ul><li>Baf：精简的字节码表示，操作简单</li><li>Jimple：适用于优化的 3-address 中间表示</li><li>Shimple：Jimple 的 SSA 变体</li><li>Grimple：适用于反编译和代码检查的 Jimple 汇总版本。</li></ul><p>这里最为关键的就是 Jimple 的中间表示，它是三地址码形式，并且存在类型，可以用来做各种优化需要的分析，比如类型推测（需调用优化）、边界检查消除、常量分析、公共子串分析等。同时该中间表示操作简单，表达简洁，所以常被用来充当 java 静态分析中的中间表示。关于 Soot 的使用可以参照下面的命令，环境为 <code>jdk1.8</code>，Soot 的版本为 <code>sootclasses-trunk-jar-with-dependencies.jar</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># .java -&gt; .class</span>
</span></span><span class=line><span class=cl>javac hello.java
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># .class -&gt; .jimple</span>
</span></span><span class=line><span class=cl>java -cp sootclasses-trunk-jar-with-dependencies.jar soot.Main -f J -pp -cp . hello
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># .class -&gt; .dot</span>
</span></span><span class=line><span class=cl>java -cp sootclasses-trunk-jar-with-dependencies.jar soot.tools.CFGViewer -pp -cp . Hello
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># .dot -&gt; .svg</span>
</span></span><span class=line><span class=cl>dot -Tsvg -o Hello.svg <span class=s1>&#39;.\sootOutput\Hello void main(java.lang.String[]).dot&#39;</span></span></span></code></pre></td></tr></table></div></div><p>采用上面的命令，先将下面的代码文件 <strong>hello.java</strong> 转化为 <strong>hello.class</strong> 的字节码文件，之后就可以使用 Soot 来产生对应的 <strong>Hello.jimple</strong> 文件了。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Hello</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    	</span><span class=kt>int</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>2</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>4</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>a</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>3</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>a</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>c</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>a</span><span class=w> </span><span class=o>-=</span><span class=w> </span><span class=n>c</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;the value of a is: &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>a</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>产生的 Jimple 如下所示，这里首先排除 $ 开头的内置变量、label2 的 println 操作和 init 部分的初始化操作，然后主要关注的就是 main 函数的剩余部分。可以清晰的看出 Jimple 采用的就是三地址码形式，同时也没有使用 SSA 的模式，因为存在 <code>i4 = i3 + 4;</code> 和 <code>i4 = i3 - 4;</code> 这两条语句，对于同一个变量进行了多次赋值操作。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>public class Hello extends java.lang.Object
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    public void &lt;init&gt;()
</span></span><span class=line><span class=cl>    {
</span></span><span class=line><span class=cl>        Hello r0;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        r0 := @this: Hello;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        specialinvoke r0.&lt;java.lang.Object: void &lt;init&gt;()&gt;();
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        return;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    public static void main(java.lang.String[])
</span></span><span class=line><span class=cl>    {
</span></span><span class=line><span class=cl>        int i0, i3, i4;
</span></span><span class=line><span class=cl>        java.lang.StringBuilder $r0, $r2, $r3;
</span></span><span class=line><span class=cl>        java.io.PrintStream $r1;
</span></span><span class=line><span class=cl>        java.lang.String $r4;
</span></span><span class=line><span class=cl>        java.lang.String[] r5;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        r5 := @parameter0: java.lang.String[];
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        i0 = 1 + 1;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        i3 = i0 * 2;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        if i3 &lt;= 3 goto label1;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        i4 = i3 + 4;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        goto label2;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>     label1:
</span></span><span class=line><span class=cl>        i4 = i3 - 4;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>     label2:
</span></span><span class=line><span class=cl>        $r1 = &lt;java.lang.System: java.io.PrintStream out&gt;;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        $r0 = new java.lang.StringBuilder;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        specialinvoke $r0.&lt;java.lang.StringBuilder: void &lt;init&gt;()&gt;();
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        $r2 = virtualinvoke $r0.&lt;java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)&gt;(&#34;the value of a is: &#34;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        $r3 = virtualinvoke $r2.&lt;java.lang.StringBuilder: java.lang.StringBuilder append(int)&gt;(i4);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        $r4 = virtualinvoke $r3.&lt;java.lang.StringBuilder: java.lang.String toString()&gt;();
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        virtualinvoke $r1.&lt;java.io.PrintStream: void println(java.lang.String)&gt;($r4);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        return;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><p>之后还可以通过 Soot 将这个 Jimple 转化为 dot 的形式，然后通过 graphviz 工具将 dot 转化为下面的 svg/png 图形化界面进行展示。这里的图像化界面其实是指的 <strong>控制流图（Control Flow Graph，CFG）</strong>，它的基本单位就是由数条指令组合而成的基本块，这个会在控制流分析中进行陈述，这里只需要关心直观的图形展示即可。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/Hello.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/Hello.png?size=small" data-sub-html="<h2>Hello</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/Hello.png alt="Jimple 图形化展示" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/Hello.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/Hello.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/Hello.png?size=large 2x" data-title=Hello style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>Jimple 图形化展示</figcaption></figure></p><h5 id=llvm class=heading-element><span>LLVM</span>
<a href=#llvm class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p><strong>LLVM（The Low Level Virtual Machine）</strong> 是低级虚拟机的简称，它是当前各种研究领域最常用的编译器，也是很多大公司普遍使用的编译器。和其他编译器一样，LLVM 分为 <strong>前端（clang）</strong>，<strong>中端（opt）</strong> 和 <strong>后端（llc）</strong>。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241221203001.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241221203001.png?size=small" data-sub-html="<h2>20241221203001</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241221203001.png alt=LLVM结构 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241221203001.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241221203001.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241221203001.png?size=large 2x" data-title=20241221203001 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>LLVM结构</figcaption></figure></p><p>LLVM 用一种指令的序列来表达程序，这些指令的序列称为 bytecodes，或者简称为 bc。LLVM 的指令又被称为 LLVMIR，LLIR 和 target 机器没有绑定关系，是一种类汇编的代码，LLVM 的汇编代码的详细说明参见 <a href=https://llvm.org/docs/LangRef.html target=_blank rel="external nofollow noopener noreferrer">New tab (llvm.org)</a>。这里的 bc 文件就是一种二进制文件，对于人的阅读而言很不友好，因此 LLVM 也提供了与 bc 等价，但是人可以阅读的 ll 文件，该文件和上面的 Jimple 的展现形式类似，简洁且容易理解。之后利用下面的命令对于元文件进行操作，就可以得到相关的中间表示代码和图形化界面了。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># .c -&gt; .ll(下面的命令可以图形化展示)</span>
</span></span><span class=line><span class=cl>clang -Xclang -disable-O0-optnone -S -emit-llvm llvm.c -o llvm.ll
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># .c -&gt; .bc(下面的命令不可以图形化展示)</span>
</span></span><span class=line><span class=cl>clang -C -emit-llvm llvm.c -o 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># .ll/.bc -&gt; .dot</span>
</span></span><span class=line><span class=cl>opt -passes<span class=o>=</span>dot-cfg llvm.ll/.bc
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># .dot -&gt; .png</span>
</span></span><span class=line><span class=cl>dot .main.dot -Tpng -o llvm.png</span></span></code></pre></td></tr></table></div></div><p>在上面的命令中，<code>-S</code> 和 <code>-C</code> 用来控制产生 ll 和 bc 两种文件。二者都可以图形化展示，但是对于后者的产生命令，没有 <code>-Xclang -disable-O0-optnone</code> 就不能转化为图形，它会在 <code>opt</code> 产生 dot 文件时没有输出，只有 <code>WARNING</code>。究其原因，没有添加该指令而产生的 ll 文件（ bc 也一样）会存在 <code>optnone</code> 的标识，该标识会阻碍转换为图像。所以这里使用该指令，或者直接删除该标识，才可以使其转换成功。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>b</span> <span class=o>=</span> <span class=n>a</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span> <span class=o>=</span> <span class=n>b</span> <span class=o>*</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>c</span> <span class=o>=</span> <span class=mi>4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>a</span> <span class=o>&gt;</span> <span class=mi>3</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span> <span class=o>+=</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span> <span class=o>-=</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;the value of a is: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>对上面的 c 代码，使用 <code>clang</code> 转化为的 ll 中间表示形式如下，它没有使用 <code>-Xclang -disable-O0-optnone</code> 指令，所以可以看出在 <code>Function Attrs:</code> 和 <code>attributes #0</code> 两处都存在 <code>optnone</code> 的标识，直接将这个标识进行删除就可以达到使用上述指令一样的效果。而对于该 ll 文件进行分析，可以知道 <code>%+数字</code> 就是一个变量，而这些变量没有二次赋值，所以 LLVM 的中间表示为 SSA 的形式。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>; ModuleID = &#39;llvm.c&#39;
</span></span><span class=line><span class=cl>source_filename = &#34;llvm.c&#34;
</span></span><span class=line><span class=cl>target datalayout = &#34;e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128&#34;
</span></span><span class=line><span class=cl>target triple = &#34;x86_64-pc-linux-gnu&#34;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>@.str = private unnamed_addr constant [23 x i8] c&#34;the value of a is: %d\0A\00&#34;, align 1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>; Function Attrs: noinline nounwind optnone uwtable
</span></span><span class=line><span class=cl>define dso_local i32 @main() #0 {
</span></span><span class=line><span class=cl>  %1 = alloca i32, align 4
</span></span><span class=line><span class=cl>  %2 = alloca i32, align 4
</span></span><span class=line><span class=cl>  %3 = alloca i32, align 4
</span></span><span class=line><span class=cl>  %4 = alloca i32, align 4
</span></span><span class=line><span class=cl>  store i32 0, i32* %1, align 4
</span></span><span class=line><span class=cl>  store i32 1, i32* %2, align 4
</span></span><span class=line><span class=cl>  %5 = load i32, i32* %2, align 4
</span></span><span class=line><span class=cl>  %6 = add nsw i32 %5, 1
</span></span><span class=line><span class=cl>  store i32 %6, i32* %3, align 4
</span></span><span class=line><span class=cl>  %7 = load i32, i32* %3, align 4
</span></span><span class=line><span class=cl>  %8 = mul nsw i32 %7, 2
</span></span><span class=line><span class=cl>  store i32 %8, i32* %2, align 4
</span></span><span class=line><span class=cl>  store i32 4, i32* %4, align 4
</span></span><span class=line><span class=cl>  %9 = load i32, i32* %2, align 4
</span></span><span class=line><span class=cl>  %10 = icmp sgt i32 %9, 3
</span></span><span class=line><span class=cl>  br i1 %10, label %11, label %15
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>11:                                               ; preds = %0
</span></span><span class=line><span class=cl>  %12 = load i32, i32* %4, align 4
</span></span><span class=line><span class=cl>  %13 = load i32, i32* %2, align 4
</span></span><span class=line><span class=cl>  %14 = add nsw i32 %13, %12
</span></span><span class=line><span class=cl>  store i32 %14, i32* %2, align 4
</span></span><span class=line><span class=cl>  br label %19
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>15:                                               ; preds = %0
</span></span><span class=line><span class=cl>  %16 = load i32, i32* %4, align 4
</span></span><span class=line><span class=cl>  %17 = load i32, i32* %2, align 4
</span></span><span class=line><span class=cl>  %18 = sub nsw i32 %17, %16
</span></span><span class=line><span class=cl>  store i32 %18, i32* %2, align 4
</span></span><span class=line><span class=cl>  br label %19
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>19:                                               ; preds = %15, %11
</span></span><span class=line><span class=cl>  %20 = load i32, i32* %2, align 4
</span></span><span class=line><span class=cl>  %21 = call i32 (i8*, ...) @printf(i8* noundef getelementptr inbounds ([23 x i8], [23 x i8]* @.str, i64 0, i64 0), i32 noundef %20)
</span></span><span class=line><span class=cl>  %22 = load i32, i32* %1, align 4
</span></span><span class=line><span class=cl>  ret i32 %22
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>declare i32 @printf(i8* noundef, ...) #1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>attributes #0 = { noinline nounwind optnone uwtable &#34;frame-pointer&#34;=&#34;all&#34; &#34;min-legal-vector-width&#34;=&#34;0&#34; &#34;no-trapping-math&#34;=&#34;true&#34; &#34;stack-protector-buffer-size&#34;=&#34;8&#34; &#34;target-cpu&#34;=&#34;x86-64&#34; &#34;target-features&#34;=&#34;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&#34; &#34;tune-cpu&#34;=&#34;generic&#34; }
</span></span><span class=line><span class=cl>attributes #1 = { &#34;frame-pointer&#34;=&#34;all&#34; &#34;no-trapping-math&#34;=&#34;true&#34; &#34;stack-protector-buffer-size&#34;=&#34;8&#34; &#34;target-cpu&#34;=&#34;x86-64&#34; &#34;target-features&#34;=&#34;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&#34; &#34;tune-cpu&#34;=&#34;generic&#34; }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>!llvm.module.flags = !{!0, !1, !2, !3, !4}
</span></span><span class=line><span class=cl>!llvm.ident = !{!5}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>!0 = !{i32 1, !&#34;wchar_size&#34;, i32 4}
</span></span><span class=line><span class=cl>!1 = !{i32 7, !&#34;PIC Level&#34;, i32 2}
</span></span><span class=line><span class=cl>!2 = !{i32 7, !&#34;PIE Level&#34;, i32 2}
</span></span><span class=line><span class=cl>!3 = !{i32 7, !&#34;uwtable&#34;, i32 1}
</span></span><span class=line><span class=cl>!4 = !{i32 7, !&#34;frame-pointer&#34;, i32 2}
</span></span><span class=line><span class=cl>!5 = !{!&#34;Ubuntu clang version 14.0.0-1ubuntu1.1&#34;}</span></span></code></pre></td></tr></table></div></div><p>之后和上面的 Soot 一样，使用相关命令也可以将上述的中间表示转化为控制流图的形式。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/llvm.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/llvm.png?size=small" data-sub-html="<h2>llvm</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/llvm.png alt=llvm srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/llvm.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/llvm.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/llvm.png?size=large 2x" data-title=llvm style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>llvm</figcaption></figure></p><h3 id=优化和代码生成 class=heading-element><span>优化和代码生成</span>
<a href=#%e4%bc%98%e5%8c%96%e5%92%8c%e4%bb%a3%e7%a0%81%e7%94%9f%e6%88%90 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p><strong>优化阶段</strong> 以中间表示（IR）为输入，目标是提高程序的运行效率和资源利用率。优化分为两大类：机器无关优化和机器相关优化。前者专注于 IR 的逻辑结构，与具体的目标机器无关，因此具有跨平台复用的优势。例如，<strong>常量传播</strong> 通过分析程序的静态属性将计算结果提前确定，<strong>死代码消除</strong> 移除无意义的代码块，<strong>公共子表达式</strong> 消除检测并复用重复的计算结果，<strong>循环优化</strong> 则通过提取循环不变代码或展开循环体减少分支跳转，提高程序执行效率。静态分析在其中扮演了重要角色，通过控制流图和数据流图的构建，为优化提供了重要的基础信息。而这些优化措施，都会在之后的笔记中进行着重讲解。</p><p>相比之下，机器相关优化则深入目标架构的特性，结合硬件层面的需求对 IR 进行调整。例如，<strong>寄存器分配</strong> 利用目标机器的寄存器资源，优先分配热点变量，减少对内存的访问；<strong>流水线优化</strong> 则通过调整指令顺序避免数据冒险，提高指令并行执行的效率。这些优化措施往往与代码生成阶段密切结合，优化结果直接影响最终的目标代码质量。</p><p><strong>代码生成阶段</strong> 以优化后的 IR 为基础，将其逐步转换为目标机器的可执行代码。首先进行 <strong>指令选择</strong>，将抽象的 IR 操作映射为具体的目标机器指令，例如在 x86 架构中，ADD 指令可用于加法运算。接着，通过 <strong>寄存器分配</strong>，将高频变量优先分配至寄存器中，避免频繁的内存访问；若寄存器不足，则需通过溢出处理将变量存放至内存。最后，<strong>指令排布</strong> 通过调整指令顺序减少流水线冲突，进一步提升执行效率。</p><p>通过优化阶段与代码生成的紧密配合，编译器在语义正确的基础上，生成了高效、可靠的目标代码，从而实现了性能与可移植性的平衡。</p><h2 id=其余参考资料 class=heading-element><span>其余参考资料</span>
<a href=#%e5%85%b6%e4%bd%99%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><div class="details admonition quote open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-quote-right" aria-hidden=true></i>参考</div><div class=details-content><div class=admonition-content><p><ul><li><a href=https://www.cnblogs.com/zhouronghua/p/16213331.html target=_blank rel="external nofollow noopener noreferrer">程序分析与优化 - 1 导论</a></li><li><a href=https://static-analysis.cuijiacai.com target=_blank rel="external nofollow noopener noreferrer">静态分析基础教程</a></li><li><a href="https://jos.org.cn/jos/article/abstract/5651#:~:text=%E5%9C%A8%E4%BF%A1%E6%81%AF%E5%8C%96%E6%97%B6%E4%BB%A3%EF%BC%8C%E4%BA%BA,%E5%92%8C%E6%89%80%E9%9D%A2%E4%B8%B4%E7%9A%84%E6%8C%91%E6%88%98" target=_blank rel="external nofollow noopener noreferrer">程序分析研究进展</a></li><li><a href=https://www.cnblogs.com/zhouronghua/p/16220701.html target=_blank rel="external nofollow noopener noreferrer">程序分析与优化 - 2 控制流图</a></li></ul></div></div></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2024-12-22 12:22:35">更新于 2024.12.22&nbsp;
<a class=git-hash href=https://github.com/czTangt/blog.git/commit/73c17e98db42f9494d916cbe24dc55401ff19598 rel="external nofollow noopener noreferrer" target=_blank title="commit by czTangt(cz.tangt@gmail.com) 73c17e98db42f9494d916cbe24dc55401ff19598: add content to control flow analysis"><i class="fa-solid fa-hashtag fa-fw" aria-hidden=true></i>73c17e9</a></span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href="https://github.com/czTangt/blog.git/blob/main/content/posts%5cstaticAnalysis%5cunderstanding.md?plain=1" title=查看源码 target=_blank rel="external nofollow noopener noreferrer" class=link-to-source>查看源码</a></span><span><a href=https://github.com/czTangt/blog.git/edit/main/content/posts%5cstaticAnalysis%5cunderstanding.md title=编辑此页 target=_blank rel="external nofollow noopener noreferrer" class=link-to-edit>编辑此页</a></span><span><a href="https://github.com/czTangt/blog.git/issues/new?title=[BUG]%2001+Understanding+Static+Analysis&amp;body=%7cField%7cValue%7c%0A%7c-%7c-%7c%0A%7cTitle%7c01+Understanding+Static+Analysis%7c%0A%7cURL%7chttps://czTangt.github.io/blog/posts/staticanalysis/understanding/%7c%0A%7cFilename%7chttps://github.com/czTangt/blog.git/blob/main/content/posts%5cstaticAnalysis%5cunderstanding.md?plain=1%7c" title=报告问题 target=_blank rel="external nofollow noopener noreferrer" class=link-to-report>报告问题</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 X" data-sharer=twitter data-url=https://czTangt.github.io/blog/posts/staticanalysis/understanding/ data-title="01 Understanding Static Analysis" data-hashtags="Static Analysis"><i class="fa-brands fa-x-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://czTangt.github.io/blog/posts/staticanalysis/understanding/ data-hashtag="Static Analysis"><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://czTangt.github.io/blog/posts/staticanalysis/understanding/ data-title="01 Understanding Static Analysis"><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/blog/tags/static-analysis/ class=post-tag title="标签 - Static Analysis">Static Analysis</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/blog/>主页</a></span></section></div><div class=post-nav><a href=/blog/posts/compile/codegen-riscv-isel-ra/ class=post-nav-item rel=prev title="05 Codegen Riscv Isel Ra"><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>05 Codegen Riscv Isel Ra</a><a href=/blog/posts/programming/java/ class=post-nav-item rel=next title="Some About Java">Some About Java<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article><aside class=toc id=toc-auto aria-label=目录><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside></main><footer class=footer><div class=footer-container><div class="footer-line powered order-1">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.136.5"><img class=hugo-icon src=/blog/images/hugo.min.svg alt="Hugo logo"> Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.3.14"><img class=fixit-icon src=/blog/images/fixit.min.svg alt="FixIt logo"> FixIt</a></div><div class="footer-line copyright order-2" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2024</span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class="variant-numeric d-none">0%</span></div></div><a href=https://github.com/czTangt/blog title="View source on GitHub" target=_blank rel="external nofollow" class="github-corner left d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true" width="56" height="56"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><noscript><div class=noscript-warning>该网站在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/blog/lib/lightgallery/css/lightgallery-bundle.min.css><link rel=preload href=/blog/lib/katex/katex.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/blog/lib/katex/katex.min.css></noscript><link rel=stylesheet href=/blog/lib/cookieconsent/cookieconsent.min.css><script src=/blog/lib/autocomplete/autocomplete.min.js defer></script><script src=/blog/lib/fuse/fuse.min.js defer></script><script src=/blog/lib/lightgallery/lightgallery.min.js defer></script><script src=/blog/lib/lightgallery/plugins/thumbnail/lg-thumbnail.min.js defer></script><script src=/blog/lib/lightgallery/plugins/zoom/lg-zoom.min.js defer></script><script src=/blog/lib/sharer/sharer.min.js async defer></script><script src=/blog/lib/katex/katex.min.js defer></script><script src=/blog/lib/katex/auto-render.min.js defer></script><script src=/blog/lib/katex/mhchem.min.js defer></script><script src=/blog/lib/cookieconsent/cookieconsent.min.js defer></script><script src=/blog/js/codeblock.js defer></script><script src=https://libs.baidu.com/jquery/2.1.4/jquery.min.js defer></script><script>window.config={code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:10},comment:{enable:!1},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},lightgallery:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{distance:100,findAllMatches:!1,fuseIndexURL:"/blog/search.json",highlightTag:"em",ignoreFieldNorm:!1,ignoreLocation:!1,isCaseSensitive:!1,location:0,maxResultLength:10,minMatchCharLength:2,noResultsFound:"没有找到结果",snippetLength:30,threshold:.3,type:"fuse",useExtendedSearch:!1},version:"v0.3.14"}</script><script src=/blog/js/theme.min.js defer></script></body></html>