<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>03 Data Flow Analysis - czTang</title><meta name=author content="czTang">
<meta name=description content="记录一下对于数据流分析的理解。
"><meta name=keywords content='Static Analysis'><meta itemprop=name content="03 Data Flow Analysis"><meta itemprop=description content="记录一下对于数据流分析的理解。"><meta itemprop=datePublished content="2024-12-22T20:37:22+08:00"><meta itemprop=dateModified content="2025-01-14T18:18:02+08:00"><meta itemprop=wordCount content="20166"><meta itemprop=keywords content="Static Analysis"><meta property="og:url" content="https://czTangt.github.io/blog/posts/staticanalysis/data-flow-analysis/"><meta property="og:site_name" content="czTang"><meta property="og:title" content="03 Data Flow Analysis"><meta property="og:description" content="记录一下对于数据流分析的理解。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-22T20:37:22+08:00"><meta property="article:modified_time" content="2025-01-14T18:18:02+08:00"><meta property="article:tag" content="Static Analysis"><meta name=twitter:card content="summary"><meta name=twitter:title content="03 Data Flow Analysis"><meta name=twitter:description content="记录一下对于数据流分析的理解。"><meta name=application-name content="FixIt"><meta name=apple-mobile-web-app-title content="FixIt"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel=icon href=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410312135963.svg><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical type=text/html href=https://czTangt.github.io/blog/posts/staticanalysis/data-flow-analysis/ title="03 Data Flow Analysis - czTang"><link rel=prev type=text/html href=https://czTangt.github.io/blog/posts/staticanalysis/control-flow-analysis/ title="02 Control Flow Analysis"><link rel=stylesheet href=/blog/css/style.min.css><link rel=preload href=/blog/lib/fontawesome-free/all.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/blog/lib/fontawesome-free/all.min.css></noscript><link rel=preload href=/blog/lib/animate/animate.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/blog/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"03 Data Flow Analysis","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/czTangt.github.io\/blog\/posts\/staticanalysis\/data-flow-analysis\/"},"genre":"posts","keywords":"Static Analysis","wordcount":20166,"url":"https:\/\/czTangt.github.io\/blog\/posts\/staticanalysis\/data-flow-analysis\/","datePublished":"2024-12-22T20:37:22+08:00","dateModified":"2025-01-14T18:18:02+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"czTang"},"description":""}</script><script src=/blog/js/head/color-scheme.min.js></script></head><body data-header-desktop=sticky data-header-mobile=auto><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=left><div class=header-title><a href=/blog/ title=czTang><span class=header-title-pre><i class='fa fa-coffee'>&nbsp</i></span><span class=header-title-text>czTang</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/blog/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> Archives</a></li><li class=menu-item><a class=menu-link href=/blog/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> Categories</a></li><li class=menu-item><a class=menu-link href=/blog/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> Tags</a></li><li class=menu-item><a class=menu-link href=/blog/about/><i class="fa-solid fa-user fa-fw fa-sm" aria-hidden=true></i> About</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/blog/ title=czTang><span class=header-title-pre><i class='fa fa-coffee'>&nbsp</i></span><span class=header-title-text>czTang</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/blog/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> Archives</a></li><li class=menu-item><a class=menu-link href=/blog/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> Categories</a></li><li class=menu-item><a class=menu-link href=/blog/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> Tags</a></li><li class=menu-item><a class=menu-link href=/blog/about/><i class="fa-solid fa-user fa-fw fa-sm" aria-hidden=true></i> About</a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=container><aside class="aside-collection animate__animated animate__fadeIn animate__faster" aria-label=合集><div class="details collection-details open"><div class="details-summary collection-summary"><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i>
<span class=collection-name title=合集>Static Analysis</span>
<span class=collection-count>3</span><i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class="details-content collection-content"><nav><ul class=collection-list><li class=collection-item><a href=/blog/posts/staticanalysis/understanding/ title="01 Understanding Static Analysis">01 Understanding Static Analysis</a></li><li class=collection-item><a href=/blog/posts/staticanalysis/control-flow-analysis/ title="02 Control Flow Analysis">02 Control Flow Analysis</a></li><li class=collection-item><span class=active title="03 Data Flow Analysis">03 Data Flow Analysis</span></li></ul><div class=collection-nav-simple><a href=/blog/posts/staticanalysis/control-flow-analysis/ class=collection-nav-item rel=prev title="02 Control Flow Analysis"><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i></a><span class=text-secondary>3/3</span><i class="fa-solid fa-angle-right fa-fw collection-nav-item text-secondary" aria-hidden=true></i></div></nav></div></div></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>03 Data Flow Analysis</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/czTangt title=作者 target=_blank rel="external nofollow noopener noreferrer author" class=author><img loading=lazy src=/blog/images/avatar.jpg alt=czTang data-title=czTang width=20 height=20 class=avatar style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'>&nbsp;czTang</a></span><span class=post-included-in>&nbsp;收录于 <a href=/blog/categories/static-analysis/ class=post-category title="分类 - Static Analysis"><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> Static Analysis</a> 和 <a href=/blog/collections/static-analysis/ class=post-collection title="合集 - Static Analysis"><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i> Static Analysis</a></span></div><div class=post-meta-line><span title="发布于 2024-12-22 20:37:22"><i class="fa-solid fa-calendar-days fa-fw me-1" aria-hidden=true></i><time datetime=2024.12.22>2024.12.22</time></span>&nbsp;<span title="更新于 2025-01-14 18:18:02"><i class="fa-regular fa-calendar-check fa-fw me-1" aria-hidden=true></i><time datetime=2025.1.14>2025.1.14</time></span>&nbsp;<span title="20166 字"><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 20200 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 41 分钟</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#数据流分析概述>数据流分析概述</a><ul><li><a href=#近似方案>近似方案</a><ul><li><a href=#条件判断>条件判断</a></li><li><a href=#提前合并>提前合并</a></li></ul></li><li><a href=#符号抽象>符号抽象</a></li><li><a href=#基本概念>基本概念</a></li><li><a href=#约束记号>约束记号</a></li></ul></li><li><a href=#定义可达性分析>定义可达性分析</a><ul><li><a href=#问题描述>问题描述</a></li><li><a href=#问题分析>问题分析</a><ul><li><a href=#数据抽象>数据抽象</a></li><li><a href=#约束分析>约束分析</a></li></ul></li><li><a href=#问题求解>问题求解</a><ul><li><a href=#算法设计>算法设计</a></li><li><a href=#算法分析>算法分析</a></li></ul></li></ul></li><li><a href=#活跃变量分析>活跃变量分析</a><ul><li><a href=#问题描述-1>问题描述</a></li><li><a href=#问题分析-1>问题分析</a><ul><li><a href=#数据抽象-1>数据抽象</a></li><li><a href=#约束分析-1>约束分析</a></li></ul></li><li><a href=#问题求解-1>问题求解</a><ul><li><a href=#算法设计-1>算法设计</a></li><li><a href=#算法分析-1>算法分析</a></li></ul></li></ul></li><li><a href=#可用表达式分析>可用表达式分析</a><ul><li><a href=#问题描述-2>问题描述</a></li><li><a href=#问题分析-2>问题分析</a><ul><li><a href=#数据抽象-2>数据抽象</a></li><li><a href=#约束分析-2>约束分析</a></li></ul></li><li><a href=#问题求解-2>问题求解</a><ul><li><a href=#算法设计-2>算法设计</a></li><li><a href=#算法分析-2>算法分析</a></li></ul></li></ul></li><li><a href=#格理论基础>格理论基础</a><ul><li><a href=#基本概念-1>基本概念</a><ul><li><a href=#偏序>偏序</a></li><li><a href=#格>格</a></li><li><a href=#不动点>不动点</a></li><li><a href=#分配性>分配性</a></li></ul></li><li><a href=#单调框架>单调框架</a><ul><li><a href=#迭代算法>迭代算法</a></li><li><a href=#框架解释>框架解释</a></li></ul></li></ul></li><li><a href=#常量传播分析>常量传播分析</a><ul><li><a href=#问题描述-3>问题描述</a></li><li><a href=#问题分析-3>问题分析</a><ul><li><a href=#数据抽象-3>数据抽象</a></li><li><a href=#控制流约束>控制流约束</a></li><li><a href=#状态转移方程>状态转移方程</a></li><li><a href=#总结>总结</a></li></ul></li></ul></li><li><a href=#算法精度分析>算法精度分析</a><ul><li><a href=#mop-算法>MOP 算法</a></li><li><a href=#mop-与迭代算法>MOP 与迭代算法</a></li></ul></li><li><a href=#工作表算法>工作表算法</a></li><li><a href=#widening--narrowing>Widening & Narrowing</a><ul><li><a href=#区间分析>区间分析</a></li><li><a href=#基础-windening>基础 Windening</a></li><li><a href=#一般-windening>一般 Windening</a></li><li><a href=#narrowing>Narrowing</a></li></ul></li><li><a href=#其余参考资料>其余参考资料</a></li></ul></nav></div></div><div class=content id=content><p>记录一下对于数据流分析的理解。</p><div class="details admonition abstract open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-clipboard-list" aria-hidden=true></i>注意事项</div><div class=details-content><div class=admonition-content><p>下面的内容大部分来自于 <a href=https://static-analysis.cuijiacai.com/03-dfa-ap/ target=_blank rel="external nofollow noopener noreferrer">数据流分析及其应用</a>，它是对 <a href="https://www.bilibili.com/video/BV1b7411K7P4/?spm_id_from=333.337.search-card.all.click" target=_blank rel="external nofollow noopener noreferrer">《软件分析》</a> 课程中相关内容的总结，同时添加 <a href="https://www.bilibili.com/video/BV1Rt4y1s7tC/?spm_id_from=333.337.search-card.all.click" target=_blank rel="external nofollow noopener noreferrer">《软件分析技术》</a> 课程的相关内容。</p></div></div></div><p>命令式程序的基本构成单元是命令，而程序本身则是通过 <strong>顺序、选择和循环</strong> 三种控制结构来组织这些命令。在 <strong>数据流分析框架</strong> 中，主要关注如何对这些控制结构进行抽象，以便于理解和优化程序的行为。</p><h2 id=数据流分析概述 class=heading-element><span>数据流分析概述</span>
<a href=#%e6%95%b0%e6%8d%ae%e6%b5%81%e5%88%86%e6%9e%90%e6%a6%82%e8%bf%b0 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>数据流分析</div><div class=details-content><div class=admonition-content><p>简单来说，程序可以看成是状态（数据）和状态之间的转移（控制）两部分，因为状态转移的条件都被忽略了，核心分析的部分是状态数据在转移过程中的变化，所以叫做数据流分析。</p></div></div></div><p>上述就是对于数据流分析的简单定义，但是数据流分析在处理复杂程序时面临挑战，因为直接追踪数据流动既复杂又耗时。为了简化这一过程，通常采用近似方法，即对程序进行适当的修改，以便得到一个更易于分析的版本，同时确保分析结果与原始程序保持一致。这种近似方法主要包含两种手段：忽略条件判断和提前合并。</p><h3 id=近似方案 class=heading-element><span>近似方案</span>
<a href=#%e8%bf%91%e4%bc%bc%e6%96%b9%e6%a1%88 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><h4 id=条件判断 class=heading-element><span>条件判断</span>
<a href=#%e6%9d%a1%e4%bb%b6%e5%88%a4%e6%96%ad class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>忽略条件判断</div><div class=details-content><div class=admonition-content><p>忽略条件判断的核心思想是进行非确定性抽象，即假设所有分支条件都可能成立，从而生成一个程序行为的超集，确保原始程序的结果包含在抽象程序的结果中。</p></div></div></div><p>这种处理方式能够分析程序的所有可能路径，并确保分析结果的正确性。具体来说，有两种常见的抽象方式。</p><p>一种是对于分支条件的抽象。对于 if-else 语句，忽略条件判断，直接将分支抽象为非确定性选择。这里的 <code>nondet_choice</code> 表示程序可能执行 <code>stmt1</code> 或 <code>stmt2</code>，从而形成包含所有可能路径的抽象超集。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>condition</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>stmt1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>stmt2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>nondet_choice</span> <span class=n>stmt1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>nondet_choice</span> <span class=n>stmt2</span><span class=p>;</span></span></span></code></pre></td></tr></table></div></div><p>另一种是对于循环条件的抽象。对于循环结构，将循环条件抽象为非确定性路径。这种处理方式消除了控制流图中的环结构，保证程序一定能终止。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=n>condition</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>body</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>nondet_choice</span> <span class=n>body</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>nondet_choice</span> <span class=n>skip_loop</span><span class=p>;</span></span></span></code></pre></td></tr></table></div></div><p>上述两种语句的抽象本质上是构造一个超集。对于只有一条执行路径的原始程序，抽象后将存在多条执行路径，其中一定包含原始程序的执行路径。</p><h4 id=提前合并 class=heading-element><span>提前合并</span>
<a href=#%e6%8f%90%e5%89%8d%e5%90%88%e5%b9%b6 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>提前合并</div><div class=details-content><div class=admonition-content><p>提前合并的核心思想是不在路径末尾做合并，而是在控制流的汇合点提前进行合并。换句话说，对于忽略条件判断的结果，不是在计算每条路径的结果之后再进行汇总，而是首先考虑每条路径都会遍历，因此在多条路径的汇聚点就进行分支结果的合并，最终得到一个稳定的值，它就是程序的最终结果。</p></div></div></div><p>这种处理方式能够避免路径末尾合并带来的冗余计算，通过提前合并，可以加速分析过程并简化结果的计算。具体来说，没有提前合并，那么每条分支就都需要维护整个分支上的所有信息，直到最后才进行处理，这无疑会加重信息的存储，同时末尾过多信息的处理也会拖慢分析速度。</p><p>上述两种近似方案，对程序控制部分的分析进行了优化，但是对于程序数据部分的分析没有什么帮助。而数据的分析优化就是下面 <strong>符号抽象</strong> 的用途。</p><h3 id=符号抽象 class=heading-element><span>符号抽象</span>
<a href=#%e7%ac%a6%e5%8f%b7%e6%8a%bd%e8%b1%a1 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><div class="details admonition abstract open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-clipboard-list" aria-hidden=true></i>注意事项</div><div class=details-content><div class=admonition-content><p>下面的内容大部分来自于 <a href=https://static-analysis.cuijiacai.com/01-intro/#_1-3-%E6%8A%BD%E8%B1%A1 target=_blank rel="external nofollow noopener noreferrer">静态分析概述</a>。该文章介绍的是抽象的方法，但是我觉得这个和 <a href="https://www.bilibili.com/video/BV1Rt4y1s7tC/?spm_id_from=333.337.search-card.all.click" target=_blank rel="external nofollow noopener noreferrer">《软件分析技术》</a> 中介绍的符号分析方法简直一模一样，所以就将二者进行组合介绍。</p></div></div></div><p>在静态分析中，重点在于程序的特定性质，而非每个细节。抽象就是从程序中提取与研究特性相关的部分，忽略无关细节。这种方法不仅简化了问题，还能高效分析复杂程序的潜在问题。例如，分析除零错误（Zero Division Error）时，只需判断值是否为 0，而无需关心具体数值大小。通过将程序的 <strong>具体值集（Concrete Domain）</strong> 映射到 <strong>抽象值集（Abstract Domain）</strong>，问题得以简化，同时保证分析结果仍涵盖原程序的所有可能性。</p><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>符号抽象</div><div class=details-content><div class=admonition-content><p>对于程序 <em>P</em> 的 <strong>具体值集（Concrete Domain）</strong> $D_C$，静态分析 <em>S</em> 基于要研究的性质 <em>Q</em> 设计 <strong>抽象值集（Abstract Domain）</strong> $D_A$，并建立映射关系 $f_{D_C \rightarrow D_A} \ (f \subseteq D_C \times D_A)$，这个过程称为 <em>S</em> 对 <em>P</em> 关于 <em>Q</em> 的 <strong>抽象（Abstraction）</strong>。</p><p>通常 $|D_A| &lt; |D_C|$，因为抽象的目的是简化问题。而在 $D_A$ 中，常见两个特殊值：</p><ul><li>$\top$ 为 <strong>未确定值（Unknown）</strong></li><li>$\bot$ 为 <strong>未定义值（Undefined）</strong></li></ul><p>$\top \in D_A \land \bot \in D_A$，它们需要额外定义运算规则以适应表达式计算。</p></div></div></div><p>这里的 $D_C$ 包含程序中变量的所有具体值，如 $\{-2,-1,0,1,2,3,\ldots\}$，而 $D_A$ 是一个抽象化的集合，如 $\{\text{+},\text{-},\text{零}\}$。$f_{D_C \rightarrow D_A}$ 则是其 <strong>映射函数</strong>，将程序中的具体状态或值转化为适合静态分析的抽象状态或值。其中关系 $f \subseteq D_C \times D_A$ 表示映射 $f$ 是具体值域 $D_C$ 和抽象值域 $D_A$ 笛卡尔积的一个子集，即 $f = \{(c, a) \ | \ c \in D_C, a \in D_A\}$。这种表示方式允许 $f$ 是一个多对一的关系，即多个具体值可以映射到同一个抽象值，上述 $D_C$ 中的所有正数都可以映射为 $D_A$ 中的 $+$。</p><p>上述是对于单个变量而言的抽象，而程序中不止变量，还存在表达式，所以下面需要对于表达式进行处理。</p><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>状态转移</div><div class=details-content><div class=admonition-content><p>假设 $f_1 = f_{D_C \rightarrow D_A}$。对于程序 <em>P</em> 的二元操作集 <em>op</em>，定义映射：
$$
f_2 = f_{op \times D_A \times D_A \rightarrow D_A} \ (f_2 \subseteq op \times D_A \times D_A \times D_A)
$$
之后就可以通过 $f_2 \circ f_1$，将 $D_C$ 相关的表达式值映射到 $D_A$。其中：</p><ul><li>$f_1$为 <strong>状态函数（State Function）</strong>，定义如何将具体值转化为抽象值</li><li>$f_2$为 <strong>转移函数（Transfer Function）</strong>，定义如何基于抽象值解析表达式</li></ul></div></div></div><p>这里的 $f_2$ 定义了如何基于抽象值解析二元操作，这是对于具体值集中函数的抽象，使得经过符号抽象的变量可以通过抽象后的函数进行运算。其中 $op$ 是程序种的操作符集合（例如加法 <code>+</code>、减法 <code>-</code>、逻辑与 <code>&&</code> 等），$op \times D_A \times D_A \rightarrow D_A$ 表示两个抽象值通过一个操作符生成新的抽象值。而这里的 <strong>组合</strong> $f_2 \circ f_1$ 表示了对于变量的所有处理操作，先通过 $f_1$ 将具体值转换为抽象值，再通过 $f_2$ 对这些抽象值进行操作，得到新的抽象结果。</p><p>那么对于上述符号抽象过程，可以使用研究程序中变量的正负性来举例，则若是 $D_A = \{+,-,0,\top,\bot \}$，那么 $f_1 = f_{D_C \rightarrow D_A}$ 为
$$
\forall x \in D_C, \quad f_1(x) = \begin{cases} +, & \text{if } x > 0 \\ 0, & \text{if } x = 0 \\ -, & \text{if } x &lt; 0 \end{cases}
$$</p><p>$f_2 = f_{op \times D_A \times D_A \rightarrow D_A}$ 就是</p><p>$$
f_2 = \{(+, +, +, +), (+, -, -, -), (+, +, -, \top), (+, 0, 0, 0), \\
(/, +, +, +), (/, -, -, +), (\top, 0, \bot, \bot), (/, +, -, -), \ldots \}
$$</p><p>可以使用 Sound、过近似的分析原则分析下面的代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=n>input</span> <span class=n>then</span>
</span></span><span class=line><span class=cl>    <span class=n>y</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=n>y</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>z</span> <span class=o>=</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span><span class=p>;</span></span></span></code></pre></td></tr></table></div></div><p>这里会发现在进入 2-5 行的条件语句时，<em>y</em> 的值可能为 <em>10</em>，也可能为 <em>-1</em>。于是最终会认为 <em>y</em> 的抽象值为 $\top$，最终 <em>z</em> 的抽象值也就为 $\top$。这样的分析就是尽可能全面的，虽然它并不精准。这里 y 的抽象值会为 $\top$ 是根据 <strong>常量传播</strong> 的规则来的，在下面常量传播的板块会进行规则说明。</p><h3 id=基本概念 class=heading-element><span>基本概念</span>
<a href=#%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>数据流分析</div><div class=details-content><div class=admonition-content><p><strong>数据流分析（Data Flow Analysis）</strong> 是指分析数据在程序中是怎么流动的，具体而言，其分析的对象是基于抽象的应用特定型数据；行为是数据的流动；方式是安全近似，根据安全性需求选择过近似还是欠近似；基础是控制流图。而在数据的流动中，场景只有两个：</p><ul><li>在 CFG 的点内流动，即程序基本块内部的数据流。</li><li>在 CFG 的边上的流动，即由基本块间控制流触发的数据流。</li></ul></div></div></div><p>由此可以看出不同的数据流分析应当有：</p><ul><li>不同的数据抽象；</li><li>不同的流安全近似策略 &mdash; 过近似或者欠近似；</li><li>不同的 <strong>转移函数</strong> 和 <strong>控制流处理方法</strong>；</li></ul><p>上述对于转移函数进行了定义，那么下面还需要对于控制流处理方法进行介绍。</p><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>数据流值</div><div class=details-content><div class=admonition-content><p>定义程序 <em>P</em> 的 <strong>抽象数据状态（Abstract Data State，ADS）</strong>，也即 <strong>数据流值</strong> 为程序中所有数据抽象值的整体，由此：</p><ul><li>称每一个 IR 语句 <em>s</em> 执行之前，<em>pre(s)</em> 执行之后的数据流值为 <em>s</em> 的输入状态，记为 $IN[s]$，这里 <em>pre(s)</em> 为控制流中 <em>s</em> 的前驱的集合</li><li>称每一个 IR 语句 <em>s</em> 执行之后，<em>suc(s)</em> 执行之前的数据流值为 <em>s</em> 的输出状态，记为 $OUT[s]$，这里 <em>pre(s)</em> 为控制流中 <em>s</em> 的后继的集合</li></ul></div></div></div><p>而对于数据流值，还存在另外一种表示方式：</p><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>程序点</div><div class=details-content><div class=admonition-content><p>对于程序 <em>P</em> 的 IR 语句集 <em>S</em>，定义集合
$$
PP = \{ (s_i, s_j) | s_i, s_j \in S \land (s_i \in pre(s_j) \lor s_j \in suc(s_i) ) \}
$$
中的每一个元素为程序 <em>P</em> 的一个 <strong>程序点（Program Point）</strong>。</p></div></div></div><p>顾虑到 $i, j$ 是对于平面的 IR 语句的标记，其差值大小不好定义，但是这里的程序点是用控制流中 <strong>相邻语句的顺序二元组</strong> 来进行表示的。这里每一个程序点都对应了一个数据流值，而每一个不同的数据流值都会有一个或者多个程序点与之对应。简单而言，数据流值就是当前未执行语句 $s$ 前，所有变量状态的整体。它类似于寄存器组，存储着当前未执行指令前的寄存器状态。</p><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>交汇</div><div class=details-content><div class=admonition-content><p>定义数据流值在控制流推动下融合时的运算为 <strong>交汇（meet）</strong>，用符号 $\wedge$ 表示，其含义由具体的数据流分析决定。一般对于集合类型的数据流值，在可能性分析下，$\wedge$ 常定义为并集、必然性分析下，$\wedge$ 则常定义为交集。</p><ul><li>那么对于正向分析，每个语句 s 的输入状态，就是其前驱语句输出状态的交汇，即：
$$
IN[s] = \bigwedge_{s_i \in pre(s)} OUT[s_i]
$$</li><li>而对于逆向分析，每个语句 s 的输出状态，就是其后继语句输入状态的交汇，即：
$$
OUT[s] = \bigwedge_{s_i \in suc(s)} IN[s_i]
$$</li></ul></div></div></div><p>以正向分析为例，上述公式有如下 3 种常见的应用场景：<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241224201438.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241224201438.png?size=small" data-sub-html="<h2>20241224201438</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241224201438.png alt=交汇场景 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241224201438.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241224201438.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241224201438.png?size=large 2x" data-title=20241224201438 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>交汇场景</figcaption></figure></p><p>由上面的一系列定义，可以总结数据流分析的工作：</p><p>数据流分析的核心任务是为程序中的每个 <strong>程序点</strong> 关联一个 <strong>数据流值</strong>，用以表征在该程序点可能观察到的所有程序状态。这一过程可以形式化为寻找一个从程序点集合到数据流值集合的满射 $f_{PP \to D}$，这里程序的定义域为 <em>D</em>。在分析过程中，每个程序点的数据流值都可以通过程序语句的输入状态 $IN[s]$ 和输出状态 $OUT[s]$ 表达，这使得数据流分析可以等价地描述为对所有程序点输入输出状态集合的求解问题。</p><p>数据流分析需要满足一系列约束条件，统称为 <strong>安全近似导向型约束（SAOC）</strong>。这些约束主要来源于两个方面：一是语句的语义约束，即通过 <strong>状态转移方程</strong> 描述语句对程序状态的具体影响；二是 <strong>控制流约束</strong>，由程序控制流关系决定，确保不同语句之间输入输出状态的一致性。通过满足这些约束，数据流分析能够在安全的前提下对程序状态进行合理的近似和推断。</p><h3 id=约束记号 class=heading-element><span>约束记号</span>
<a href=#%e7%ba%a6%e6%9d%9f%e8%ae%b0%e5%8f%b7 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>状态转移</div><div class=details-content><div class=admonition-content><p>在数据流分析中，<strong>状态转移方程（State Transfer Function）</strong> 用于描述程序语句对数据流值的映射，它表示为 $f_{D \rightarrow D}$ 的映射。语句 s 的状态转移方程就是 $f_s$，它的作用就是根据控制流方向将输入状态映射为输出状态，或者反向从输出状态推导输入状态。</p></div></div></div><p>状态转移方程和上述定义的转移函数本质是一样的，都是 <strong>Transfer Function</strong>，只不过应用场景不一样，原相和相的集合不一样而已。后者是基于抽象值解析表达式，使其可以形成原来函数的超集；而前者则是基于数据流值进行的处理。</p><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>数据流方向</div><div class=details-content><div class=admonition-content><p>控制流都是从开始到结束的，而数据流由于分析场景的不同，存在两种不同的方向。定义顺控制流方向的数据流分析为 <strong>正向分析（Forward Analysis）</strong>，则 $f_s$ 满足 $OUT[s] = f_s(IN[s])$；定义逆控制流方向的数据流分析为 <strong>逆向分析（Backward Analysis）</strong>， $f_s$ 满足 $IN[s] = f_s(OUT[s])$。</p></div></div></div><p>最后根据上述信息，就可以定义控制流中的约束记号。</p><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>基本块状态</div><div class=details-content><div class=admonition-content><p>对于基本块 $B = \{s_1,s_2,\ldots,s_n\}$，其中 $\forall i = 1, 2, \dots, n - 1; IN[s_{i + 1}] = OUT[s_i]$。那么基本块 $B$ 的输入状态为 $IN[B] = IN[s_1]$，基本块 $B$ 的输出状态为 $OUT[B] = OUT[s_n]$。</p></div></div></div><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>状态转移方程</div><div class=details-content><div class=admonition-content><p>对于上述基本块 $B = \{s_1,s_2,\ldots,s_n\}$，$s_i$ 的状态转移方程为 $f_{s_1}$。</p><ul><li>在正向分析中，基本块 $B$ 的状态转移方程为 $f_B = f_{s_n} \circ \ldots \circ f_{s_2} \circ f_{s_1}$，满足
$$
OUT[B] = f_B(IN[B])
$$
其中，$IN[B] = \bigwedge_{P \in pre(B)} OUT[P]$。</li><li>在逆向分析中，基本块 $B$ 的状态转移方程为 $f_B = f_{s_1} \circ \ldots \circ f_{s_{n-1}} \circ f_{s_n}$，满足
$$
IN[B] = f_B(OUT[B])
$$
其中，$OUT[B] = \bigwedge_{S \in suc(B)} IN[S]$。</li></ul></div></div></div><h2 id=定义可达性分析 class=heading-element><span>定义可达性分析</span>
<a href=#%e5%ae%9a%e4%b9%89%e5%8f%af%e8%be%be%e6%80%a7%e5%88%86%e6%9e%90 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><div class="details admonition abstract open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-clipboard-list" aria-hidden=true></i>注意事项</div><div class=details-content><div class=admonition-content><p>在下面对于四种算法的定义中，不讨论方法调用和别分分析，这些会在之后的 <strong>过程间（Inter-Procedural）分析</strong> 中进行讨论。而这里的情况只考虑 <strong>过程内（Intra-Procedural）分析</strong> 的 CFG。</p></div></div></div><h3 id=问题描述 class=heading-element><span>问题描述</span>
<a href=#%e9%97%ae%e9%a2%98%e6%8f%8f%e8%bf%b0 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>Reaching Definition Analysis</div><div class=details-content><div class=admonition-content><p>程序中变量 <em>v</em> 的 <strong>定义（Definition）</strong> 是指对 <em>v</em> 赋值的语句。在程序点 <em>p</em> 的一个定义 <strong>到达（Reach）</strong> 程序点 <em>q</em>，如果存在一条从 <em>p</em> 到 <em>q</em> 的 <strong>控制流路径</strong>，且在这条路径上，定义 <em>d</em> 未被后续的重新定义所 <strong>覆盖（Kill）</strong>。这种分析每个程序点处定义是否可达的过程称为 <strong>定义可达性分析（Reaching Definition Analysis）</strong>。</p></div></div></div><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241229202355.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241229202355.png?size=small" data-sub-html="<h2>20241229202355</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241229202355.png alt=定义可达性分析 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241229202355.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241229202355.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241229202355.png?size=large 2x" data-title=20241229202355 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>定义可达性分析</figcaption></figure></p><p>从上述定义可以看出，“定义可达性” 实际上描述了一个定义可能的最长 <strong>生存期（Lifetime）</strong>。因为只要存在一条路径能够从定义点到达目标点，就认为该定义是可达的。这是一种 <strong>可能性分析（May Analysis）</strong>，采用了 <strong>过近似（Over-Approximation）</strong> 的原则。</p><p>定义可达性分析可以应用于检测程序中可能存在的未定义变量。例如，可以在 <strong>数据流图（DFG）</strong> 的入口处为每个变量 <em>v</em> 赋予一个 <strong>伪定义（Dummy Definition）</strong>。如果在程序中的某个点 <em>p</em> 使用了变量 <em>v</em>，并且 <em>v</em> 的伪定义能够到达程序点 <em>p</em>，则可以推测出变量 <em>v</em> 可能在定义之前被使用，即程序可能存在变量未定义的错误。</p><p>这里为什么是 <strong>可能存在</strong> 而不是 <strong>一定存在</strong> 呢？原因在于定义可达性分析采用的是可能性分析的策略：只要有任意一条控制流能够将定义传播到某个程序点，就认为定义是可达的。然而，在实际程序执行时，只会有唯一的一条控制流被真正执行，这条控制流未必与分析过程中得出结论的路径相符。因此只能推测出可能存在未定义变量的问题，而不能确保其一定发生。</p><h3 id=问题分析 class=heading-element><span>问题分析</span>
<a href=#%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>在这一小节中，会应用静态分析和数据流分析的基本思路，分析定义可达性问题。</p><h4 id=数据抽象 class=heading-element><span>数据抽象</span>
<a href=#%e6%95%b0%e6%8d%ae%e6%8a%bd%e8%b1%a1 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>首先，需要定义程序的 <strong>抽象数据状态</strong>。在此问题中，关注的数据流值是每个变量的定义，因此，程序的抽象数据状态可以用 <strong>定义的集合</strong> 表示。假设程序 <em>P</em> 中的所有定义为 $D = \{d_1, d_2, \dots, d_n\}$，则在定义可达性问题下，<em>D</em> 的幂集（Power Set）即为程序 <em>P</em> 的定义域（Domain）。每个程序点的数据流值可以表示为 <em>D</em> 的子集，描述能够到达该点的定义集合。也即确定 $f_{P \to D}$，为每个程序点关联一个数据流值。</p><p>在实际实现中，由于全集 <em>D</em> 是固定的，且 $|D| = n$，因此可以用 <strong>n 位的位向量（Bit Vector）</strong> 表示 <em>D</em> 的所有子集，即所有可能的抽象数据状态。位向量的第 i 位表示定义 $d_i$ 是否可达：</p><ul><li>第 i 位为 0 表示 $d_i$ 不可达；</li><li>第 i 位为 1 表示 $d_i$ 可达。</li></ul><p>用位向量表示全集确定的集合是常见做法。假设全集的势为 <em>n</em>，则其子集有 $2^{n}$ 个，而 <em>n</em> 位的位向量也有 $2^n$ 种可能，二者之间存在一一对应关系。除了位向量外，集合还可以用其他方式表示，例如哈希表或红黑树。但由于位向量在数据流分析中应用广泛，这里仅作介绍。为了更具一般性，接下来的分析仅基于集合的抽象，而不依赖其具体实现。</p><h4 id=约束分析 class=heading-element><span>约束分析</span>
<a href=#%e7%ba%a6%e6%9d%9f%e5%88%86%e6%9e%90 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>完成数据抽象后，进行估计分析。采用的策略是 <strong>安全近似</strong>（过近似）和 <strong>正向分析</strong>。估计的时候需要考虑两种约束：语义约束和控制流约束。</p><p>语义约束指程序语句的影响，例如，语句 <code>D: v = x op y</code> 生成了关于变量 <em>v</em> 的新定义 <em>D</em>，并覆盖程序中其他对 <em>v</em> 的定义，但不会影响后续其他定义覆盖该定义。赋值语句是定义的一种形式，定义还可以包括其他形式，例如引用参数。同时这里分析时以基本块为粒度。基本块 $B$ 中：</p><ul><li>生成的新定义记为集合 $gen_B$。</li><li>覆盖掉的定义记为集合 $kill_B$。</li></ul><p>例如：<br><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241229205617.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241229205617.png?size=small" data-sub-html="<h2>20241229205617</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241229205617.png alt=举例 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241229205617.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241229205617.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241229205617.png?size=large 2x" data-title=20241229205617 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>举例</figcaption></figure></p><p>$$
\begin{aligned}
gen_{B_1} & = {d_1, d_2, d_3}, \qquad kill_{B_1} = {d_4, d_5, d_6, d_7} \\
gen_{B_2} & = {d_4, d_5}, \qquad\quad\ kill_{B_2} = {d_1, d_2, d_7} \\
gen_{B_3} & = {d_6}, \qquad\qquad\ \ kill_{B_3} = {d_3} \\
gen_{B_4} & = {d_7}, \qquad\qquad\ \ kill_{B_4} = {d_1, d_4}
\end{aligned}
$$</p><p>在静态程序中，$gen_B$ 和 $kill_B$ 是固定的。基于此，可以得到基本块 $B$ 的 <strong>转移方程</strong>：
$$
OUT[B] = gen_B \cup (IN[B] - kill_B)
$$</p><p>控制流约束采用过近似原则：某定义达到程序点，只需存在至少一条路径可达即可。因此，定义 <strong>交汇操作符（Meet Operator）</strong> 为集合并操作：$\wedge = \cup$。<strong>控制流约束</strong> 表示为：<br>$$
IN[B] = \bigcup_{P \in pre(B)} OUT[P]
$$</p><h3 id=问题求解 class=heading-element><span>问题求解</span>
<a href=#%e9%97%ae%e9%a2%98%e6%b1%82%e8%a7%a3 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>由上述分析，可以得到该算法的相关信息：</p><div class="details admonition tip open"><div class="details-summary admonition-title"><i class="icon fa-fw fa-regular fa-lightbulb" aria-hidden=true></i>定义可达性分析<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content><p>对程序中任意程序点，分析在该点处每个变量的定义可能由哪些语句生成。要求上近似，即最后得到的返回值包括所有可能的定义。</p><ul><li>分析方向：正向分析</li><li>半格元素：从变量到定义集合的函数 $X \rightarrow 2^{D}$，其中 $X$ 是程序中所有变量的集合，$D$ 是程序中所有定义的集合。（格的概念下文会进行陈述）</li><li>合并运算（控制流约束）：对应集合的并 $IN[B] = \bigcup_{P \in pre(B)} OUT[P]$</li><li>最小元：映射任何变量到空集 $\bot$</li><li>输入值：最小元</li><li>转换函数（状态方程）： $OUT[B] = gen_B \cup (IN[B] - kill_B)$，其中<ul><li>对于基本块 $B$ 中给变量 $x$ 赋值的语句，$kill_B$ 表示所有给 $x$ 赋值的语句的行号，而 $gen_B$ 表示当前语句的行号；</li><li>而对于基本块 $B$ 中的其他语句，$kill_B$ 和 $gen_B$ 都是 $\emptyset$；</li><li>注意这里分析的都是基本块中的单个语句，所以直接对于 $kill_B$ 等表示变量相关的集合进行操作，而没有使用 $kill^{x}_B$ 进行描述。但是对于整个基本块而言，最后的结果必然会包括对于其余变量的操作。</li></ul></li></ul></div></div></div><blockquote><p>这里的基础就是 <strong>半格元素</strong>，之所以使用半格而不是全格，是因为全格需要存在最小上界和最大下界，同时要支持并操作和交操作。而半格就相对结构简单，只需要前面一半即可。同时，静态分析中的算法由于上近似（May）和下近似（Must）的原因，所以只需要并操作和交操作中的一种即可，因此这里使用半格。</p></blockquote><h4 id=算法设计 class=heading-element><span>算法设计</span>
<a href=#%e7%ae%97%e6%b3%95%e8%ae%be%e8%ae%a1 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>根据上面的分析，可以设计定义可达性问题的求解算法。****</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241229212635.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241229212635.png?size=small" data-sub-html="<h2>20241229212635</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241229212635.png alt=可达性分析算法 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241229212635.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241229212635.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241229212635.png?size=large 2x" data-title=20241229212635 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>可达性分析算法</figcaption></figure></p><p>可以通过下面的例子直观感受算法。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310220959122.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310220959122.png?size=small" data-sub-html="<h2>202310220959122</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310220959122.png alt=例子 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310220959122.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310220959122.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310220959122.png?size=large 2x" data-title=202310220959122 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>例子</figcaption></figure></p><h4 id=算法分析 class=heading-element><span>算法分析</span>
<a href=#%e7%ae%97%e6%b3%95%e5%88%86%e6%9e%90 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>上述算法是经典的静态分析迭代算法，用于解决定义可达性问题。初始化阶段将入口（ENTRY）的输出集合 $OUT[\text{ENTRY}]$ 设置为空集，其他基本块的输出集合也初始化为空集。这种分开初始化的方式是一种通用模式，因为某些情况下 ENTRY 和其他基本块的初始值可能不同。</p><p>该算法的核心是通过反复更新每个基本块的输入集合 $IN[B]$ 和输出集合 $OUT[B]$ 直到达到一个不动点（Fixed Point），即所有的 $OUT[B]$ 不再发生变化。在每次迭代中，$IN[B]$ 是其所有前驱节点输出集合的并集，而 $OUT[B]$ 是生成集合 $gen_B$ 与幸存者集合 $IN[B] - kill_B$ 的并集。</p><p>该算法可以停止。这是因为 $OUT[B]$ 在每次迭代中要么保持不变，要么增长，而定义的总集合 $D$ 是固定的，且 $OUT[B] \subseteq D$ 。因此，迭代最多进行 $|D| \times |B|$ 次，其中 $|B|$ 是基本块的总数。最终，当所有 $OUT[B]$ 都不再变化时，算法达到固定点。</p><p>具体分析过程中，$gen_B$ 和 $kill_B$ 是固定的，因为程序 $P$ 本身不改变。当新的定义到达基本块 $B$ 时，这些定义要么被 $kill_B$ 覆盖，要么幸存下来进入 $OUT[B]$ 。一旦定义被加入 $OUT[B]$ ，无论通过 $gen_B$ 还是幸存者集合，都会永久保留。因此，集合 $OUT[B]$ 具有单调性，并最终收敛。</p><h2 id=活跃变量分析 class=heading-element><span>活跃变量分析</span>
<a href=#%e6%b4%bb%e8%b7%83%e5%8f%98%e9%87%8f%e5%88%86%e6%9e%90 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><h3 id=问题描述-1 class=heading-element><span>问题描述</span>
<a href=#%e9%97%ae%e9%a2%98%e6%8f%8f%e8%bf%b0-1 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>Live Variable Analysis</div><div class=details-content><div class=admonition-content><p>在程序点 <em>p</em> 处，某个变量 <em>v</em> 的变量值可能在之后的某条控制流中被用到，称变量 <em>v</em> 是程序点 <em>p</em> 处的 <strong>活跃变量（Live Variable）</strong>，否则，称变量 <em>v</em> 为程序点 <em>p</em> 处的 <strong>死变量（Dead Variable）</strong>。分析在各个程序点处所有的变量是死是活的分析，就是 <strong>活跃变量分析（Live Variable Analysis）</strong>。这里程序点 <em>p</em> 处的变量 <em>v</em> 是活跃变量，当且仅当在 CFG 中存在某条从 <em>p</em> 开始的路径，在这条路径上变量 <em>v</em> 被使用了，并且在 <em>v</em> 被使用前，<em>v</em> 未被重新定义，即使用前没有被重新赋值。</p></div></div></div><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250101111544.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250101111544.png?size=small" data-sub-html="<h2>20250101111544</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250101111544.png alt=活跃变量分析 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250101111544.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250101111544.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250101111544.png?size=large 2x" data-title=20250101111544 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>活跃变量分析</figcaption></figure></p><p>这里判断活跃变量的标准不是这个变量之后有没有可能用到，而是 <strong>这个变量当前所储存的值在之后有没有可能被用到</strong>。</p><p>活跃变量分析可以应用在 <strong>寄存器分配（Register Allocation）</strong> 中，可以作为编译器优化的参考信息。比如说，如果在某个程序点处，所有的寄存器都被占满了，又需要用一个新的寄存器，那么就要从已经占满的这些寄存器中选择一个去覆盖它的旧值，这时应该更青睐于去覆盖那些储存死变量的寄存器。</p><h3 id=问题分析-1 class=heading-element><span>问题分析</span>
<a href=#%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90-1 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><h4 id=数据抽象-1 class=heading-element><span>数据抽象</span>
<a href=#%e6%95%b0%e6%8d%ae%e6%8a%bd%e8%b1%a1-1 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>同样按照上面理解定义可达性分析的流程理解这里的活跃变量分析，进行数据抽象。在活跃变量分析问题中，相比于之前关注每个变量的定义，这里关注的就是哪些是活跃变量。所以可以使用 <strong>变量的集合</strong> 作为数据流值。因此假设程序 <em>P</em> 中的所有变量为 $V = \{v_1, v_2, \dots, v_n\}$，则数据流分析的定义域为 $V$ 的幂集，即 $D = 2^V$。</p><p>每个程序点处的抽象程序状态就是 $V$ 的一个子集，表示这个程序点处所有的活跃变量的集合，而活跃变量分析的任务就是确定每个程序点的抽象程序状态。同时和定义可达性分析一样，因为全集确定，所以子集的实现可以使用位向量来表示</p><h4 id=约束分析-1 class=heading-element><span>约束分析</span>
<a href=#%e7%ba%a6%e6%9d%9f%e5%88%86%e6%9e%90-1 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>在某个程序点处的变量是否存活，判断标准是这个程序点之后，该变量的值是否还有被使用的可能。换句话来说，如果在某个程序点处，一个变量被使用了，那么在它之前的一些程序点上，该变量就是活的。这里的一些的标准是到某个变量的定义为止，因为这里判断活跃变量看的是变量的值，而不是变量本身，变量一旦被重新赋值，那么就可以把它视为死变量了（这里对于新的赋值而言就是新的活跃变量）。</p><p>由此可以看出，活跃变量分析适合从后往前进行分析，也就是逆向分析。因为若是从前往后进行分析，判断一个变量是否活跃需要正向搜索查看后续是否存在被使用的部分，效率低下；而从后往前分析，那么只需要在某程序点处找到了变量的使用，那么就可以证明在此之前任意可达此点且定义了该变量的程序点处，该变量都是活跃的。同时由上述对于活跃变量分析的定义可知，只要存在一条路径使得程序点 <em>p</em> 处的变量 <em>v</em> 的值被用到，那么就认为 <em>v</em> 在 <em>p</em> 处是活跃的，因此采用过近似的方式。</p><p>之后就是考虑 <strong>语义约束</strong>。在基本块 $B$ 中，需要考虑 $OUT[B]$ 如何被转化为 $IN[B]$，也就是 $IN[B]$ 中的活跃变量从何而来？</p><ul><li>第一种就是在 $OUT[B]$ 中已经存活的，并且在基本块 $B$ 中没有被重新定义；</li><li>第二种就是在基本块 $B$ 的表达式中，且是在基本快之前定义的变量（也就是说，如果基本块 $B$ 内部先定义一个变量，然后再使用这个变量，那么这个变量在 $IN[B]$ 处还是死变量）</li></ul><p>对于下方的 CFG，假设 $OUT[B] = \{v\}$，考虑 $B$ 中具有代表性的六种语句，则 $IN[B]$ 的结果如右所示：</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310220928054.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310220928054.png?size=small" data-sub-html="<h2>202310220928054</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310220928054.png alt=举例 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310220928054.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310220928054.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310220928054.png?size=large 2x" data-title=202310220928054 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>举例</figcaption></figure></p><p>这里可以记在基本块 B 中被定义的变量集合为 $def_B$，在基本块 $B$ 中定义前使用的变量集合为 $use_B$。而被使用但未被定义也属于在定义前使用，也就是说上述的 2、4、6 都满足 $v \in use_B$。而在情况 5 中，$v \notin use_B$，因为它是在被重定义之后才使用的，不符合上述约束分析的要求，无法确定 $IN_B$ 处的变量是否活跃。</p><p>于是，可以得到语义约束下的 <strong>状态方程</strong> 为：
$$
IN[B] = use_B \cup (OUT[B] - def_B)
$$</p><p>考虑控制流约束，由于采用过近似的方式，所以交汇操作应当定义为交集，即 $\wedge = \cup$，又是因为逆向分析，因此<strong>控制流约束</strong>为：
$$
OUT_B = \bigcup_{S \in suc(B)} IN[S]
$$</p><h3 id=问题求解-1 class=heading-element><span>问题求解</span>
<a href=#%e9%97%ae%e9%a2%98%e6%b1%82%e8%a7%a3-1 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>由上述分析，可以得到该算法的相关信息：</p><div class="details admonition tip open"><div class="details-summary admonition-title"><i class="icon fa-fw fa-regular fa-lightbulb" aria-hidden=true></i>活跃变量分析<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content><p>给定程序中的某条语句 <em>s</em> 和变量 <em>v</em>，如果在语句 <em>s</em> 执行前保存在 <em>v</em> 中的值在后续执行中还会被读取，则称 <em>v</em> 是语句 <em>s</em> 处的 <strong>活跃变量</strong>。最后需要得到的是所有可能的活跃变量。</p><ul><li>分析方向：逆向分析</li><li>半格元素：变量集合</li><li>合并运算：集合的并 $OUT_B = \bigcup_{S \in suc(B)} IN[S]$</li><li>最小元：空集</li><li>输出值：空集</li><li>转换函数：$IN[B] = use_B \cup (OUT[B] - def_B)$<ul><li>对于给 $x$ 赋值的语句（<code>x = 1</code>），$def_B = \{x\}$；对于其他语句，$def_B = \emptyset$；</li><li>$use_B$ 是基本块 $B$ 中在定义之前使用的所有变量的集合；</li></ul></li></ul></div></div></div><h4 id=算法设计-1 class=heading-element><span>算法设计</span>
<a href=#%e7%ae%97%e6%b3%95%e8%ae%be%e8%ae%a1-1 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>根据上面的分析，可以设计活跃变量分析问题的求解算法。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250101130844.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250101130844.png?size=small" data-sub-html="<h2>20250101130844</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250101130844.png alt=活跃变量分析算法 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250101130844.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250101130844.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250101130844.png?size=large 2x" data-title=20250101130844 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>活跃变量分析算法</figcaption></figure></p><p>可以通过下面的例子直观感受算法。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250101130911.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250101130911.png?size=small" data-sub-html="<h2>20250101130911</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250101130911.png alt=举例 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250101130911.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250101130911.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250101130911.png?size=large 2x" data-title=20250101130911 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>举例</figcaption></figure></p><h4 id=算法分析-1 class=heading-element><span>算法分析</span>
<a href=#%e7%ae%97%e6%b3%95%e5%88%86%e6%9e%90-1 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>这里的算法和定义可达性分析基本上一致，都是可能性分析（May Analysis）的迭代算法，区别就在于定义可达性算法为正向分析，初始化先初始输出状态（也是由分析顺序决定初始化状态），而活跃变量分析算法为逆向分析，初始化先初始输入状态。</p><h2 id=可用表达式分析 class=heading-element><span>可用表达式分析</span>
<a href=#%e5%8f%af%e7%94%a8%e8%a1%a8%e8%be%be%e5%bc%8f%e5%88%86%e6%9e%90 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><h3 id=问题描述-2 class=heading-element><span>问题描述</span>
<a href=#%e9%97%ae%e9%a2%98%e6%8f%8f%e8%bf%b0-2 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>Avaliable Expression Analysis</div><div class=details-content><div class=admonition-content><p>称一个表达式 <code>x op y</code> 在程序点 <em>p</em> 处是 <strong>可用的（Avaliable）</strong> 需要满足后续条件：如果所有从程序入口到程序点 <em>p</em> 的路径都必须经过（使用） <code>x op y</code> 表达式，并且在最后一次 <code>x op y</code> 的使用之后，没有 <em>x</em> 或者 <em>y</em> 的重定义。这里对于程序中每个程序点处的可用表达式的分析，称之为 <strong>可用表达式分析（Avaliable Expression Analysis）</strong>。</p></div></div></div><p>这里说一个表达式是可用的，指的是这个表达是的值肯定已经被计算过了，可以直接复用之前的结果，没必要再算一遍，也就是说，这个表达式不需要忙碌于计算。可以使用下面的例子进行说明：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=k>if</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=n>then</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>c</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>b</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>d</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>b</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>if</span><span class=w> </span><span class=n>d</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=n>then</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>c</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>d</span><span class=p>;</span></span></span></code></pre></td></tr></table></div></div><p>上面两个代码功能性上是等价的，但是在案例一中， <code>a - b</code> 被重复计算了两次，而案例二中， <code>a - b</code> 只被计算了一次，因此案例二的效率是更高的。在案例一的第 2 行， <code>a - b</code> 就是一个可用表达式，在之前肯定已经被计算过，因此可以对程序进行优化，通过一个变量或者是寄存器储存之前的计算结果，从而在之后不需要进行重复的计算。</p><p>可用表达式的相关信息还可以被用来检测 <strong>全局的公共子表达式（Global Common Subexpression）</strong>。</p><p>从定义中不难看出，可用表达式分析是一种必然性分析。因为在上述表达式优化的应用场景中，可以不优化每一个表达式，但不可以优化错误（也就是说一旦决定优化某个表达式，这个表达式就必须必然是可用表达式）。</p><h3 id=问题分析-2 class=heading-element><span>问题分析</span>
<a href=#%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90-2 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><h4 id=数据抽象-2 class=heading-element><span>数据抽象</span>
<a href=#%e6%95%b0%e6%8d%ae%e6%8a%bd%e8%b1%a1-2 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>在这个问题中，考虑程序中所有表达式的集合，即 $E = \{e_1,e_2,\ldots e_n \}$，其中 $e_i$ 是程序中的表达式。那么，每个程序点处的抽象程序状态，也就是说数据流值为 $E$ 的一个子集，整个分析的定义域 $D = 2^E$。</p><h4 id=约束分析-2 class=heading-element><span>约束分析</span>
<a href=#%e7%ba%a6%e6%9d%9f%e5%88%86%e6%9e%90-2 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>上面的定义已经指明从程序的入口进行分析，所以这里为正向分析，同时又由于所有路径都可用才是可用，因为这里为必然性分析（Must Analysis）。</p><p>对于语义约束，基于上述定义，这里需要从 $IN[B]$ 中加入 $B$ 中产生的新表达式，删除 $IN[B]$ 中被 $B$ 重定义变量的表达式。因此定义 $gen_B$ 为基本块 $B$ 中所有表达式的集合，$kill_B$ 为 <strong>程序中所有变量被 $B$ 重新定义的表达式</strong> 的集合。</p><blockquote><p><strong>$kill_B$</strong>：表示程序中所有可能被基本块 $B$ 重定义的表达式集合，而不是 $IN[B]$ 中被 $B$ 重定义的表达式集合。<br>这是因为 $gen_B$ 和 $kill_B$ 需要在数据流分析算法执行前静态计算，以避免在每次迭代中重复计算。此外，由于后续操作是取差集，$kill_B$ 取更大的集合不会影响最终结果。</p></blockquote><p>于是得到基本块 $B$ 的 <strong>状态转移方程</strong> 为：
$$
OUT[B] = gen_B \cup (IN[B] - kill_B)
$$</p><p>考虑控制流约束，由于采用过近似的方式，所以交汇操作应当定义为交集，即 $\wedge = \cap$，又是因为逆向分析，因此<strong>控制流约束</strong>为：
$$
IN[B] = \bigcap_{P \in pre(B)} OUT[P]
$$</p><h3 id=问题求解-2 class=heading-element><span>问题求解</span>
<a href=#%e9%97%ae%e9%a2%98%e6%b1%82%e8%a7%a3-2 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>由上述分析，可以得到该算法的相关信息：</p><div class="details admonition tip open"><div class="details-summary admonition-title"><i class="icon fa-fw fa-regular fa-lightbulb" aria-hidden=true></i>活跃变量分析<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content><p>给定程序中某个位置 <em>p</em>，如果从入口到 <em>p</em> 的所有路径都对表达式 <em>exp</em> 求值，并且最后一次求值后该表达式的所有变量都没有被修改，则 <em>exp</em> 称作 <em>p</em> 的一个 <strong>可用表达式</strong>。最后的结果就是当前的可用表达式。要求下近似。</p><ul><li>分析方向：正向分析</li><li>半格元素：表达式的集合</li><li>合并运算：集合的交 $IN[B] = \bigcap_{P \in pre(B)} OUT[P]$</li><li>最小元：全集</li><li>输出值：空集</li><li>转换函数：$OUT[B] = gen_B \cup (IN[B] - kill_B)$<ul><li>对于给 $x$ 赋值的语句，$kill_B$ 为所有包含 $x$ 的表达式，$gen_B$ 为当前求值语句中不含 $x$ 的表达式；</li><li>对于其他语句，$kill_B$ 为 $\emptyset$，$gen_B$ 为当前语句中求值的表达式；</li></ul></li></ul></div></div></div><h4 id=算法设计-2 class=heading-element><span>算法设计</span>
<a href=#%e7%ae%97%e6%b3%95%e8%ae%be%e8%ae%a1-2 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>基于上述分析，可以设计可用表达式分析算法如下：<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250101134244.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250101134244.png?size=small" data-sub-html="<h2>20250101134244</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250101134244.png alt=可用表达式分析 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250101134244.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250101134244.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250101134244.png?size=large 2x" data-title=20250101134244 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>可用表达式分析</figcaption></figure></p><blockquote><p>这里的 $U$ 和 $I$ 常在集合论中表示全集。</p></blockquote><p>可以通过下面的例子来直观感受一下上面的算法。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250101134345.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250101134345.png?size=small" data-sub-html="<h2>20250101134345</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250101134345.png alt=举例 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250101134345.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250101134345.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250101134345.png?size=large 2x" data-title=20250101134345 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>举例</figcaption></figure></p><h4 id=算法分析-2 class=heading-element><span>算法分析</span>
<a href=#%e7%ae%97%e6%b3%95%e5%88%86%e6%9e%90-2 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>这里的算法和定义可达性分析算法基本一致，不同的之处在于：</p><ul><li>初始化的时候，除了程序入口之外的其他基本块 $B$ 的 $OUT[B]$ 都初始化为了全集，因为在最开始的时候，所有的表达式都是可用的。只有在分析过程中发现表达式中的某个变量被重定义的时候，表达式才会变得不可用（需要重新计算）。</li><li>控制流约束部分变成了交集，因为这里是必然性分析。</li></ul><p>这里注意在分析初始状态的时候，需要通过语义以及对算法执行过程的影响来分析到底是空集还是全集。</p><h2 id=格理论基础 class=heading-element><span>格理论基础</span>
<a href=#%e6%a0%bc%e7%90%86%e8%ae%ba%e5%9f%ba%e7%a1%80 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><h3 id=基本概念-1 class=heading-element><span>基本概念</span>
<a href=#%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5-1 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><h4 id=偏序 class=heading-element><span>偏序</span>
<a href=#%e5%81%8f%e5%ba%8f class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>对于数据流分析的基础知识，可以从数学的角度去探索，这个产物就是格。而了解格需要先知道偏序是什么。</p><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>偏序关系</div><div class=details-content><div class=admonition-content><p>定义 <strong>偏序集（Poset）</strong> 为 $(P, \preccurlyeq)$，其中 $\preccurlyeq$ 为一个二元关系，这个二元关系在 $P$ 上定义了 <strong>偏序关系</strong>，并且 $\preccurlyeq$ 具有如下性质：</p><ol><li>自反性：$\forall x \in P, x \preceq x$；</li><li>反对称性：$\forall x, y \in P, x \preceq y \land y \preceq x \Rightarrow x = y$；</li><li>传递性：$\forall x, y, z \in P, x \preceq y \land y \preceq z \Rightarrow x \preceq z$；</li></ol></div></div></div><p>例如 $(Z, \preccurlyeq)$ 是偏序集，$(2^S, \subseteq)$ 也是偏序集。并且，偏序意味着集合中可能存在某两个元素，它们之间是不可比的。任意两个元素都可比的偏序集称为全序集。</p><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>上界与下界</div><div class=details-content><div class=admonition-content><p>对于偏序集 $(P, \preceq)$ 及其子集 $S \subseteq P$，如果 $\forall x \in S, \ x \preceq u$，则称 $u \in P$ 是 $S$ 的一个 <strong>上界（Upper Bound）</strong>；同时定义 $S$ 的 <strong>最小上界（Least Upper Bound，LUB）</strong> 为 $\bigvee S$，它使得对于 $S$ 的任意一个上界 $u$，有 $\bigvee S \succeq u$。如果 $\forall x \in S, \ l \preceq x$，则称 $l \in P$ 是 $S$ 的一个 <strong>下界（Lower Bound）</strong>；定义 $S$ 的 <strong>最大下界（Greatest Lower Bound, GLB）</strong> 为 $\bigwedge S$，它使得对于 $S$ 的任意一个下界 $l$，有 $l \preccurlyeq \bigwedge S$。</p><p>通常，如果 $S$ 只包含两个元素 $a$ 和 $b$，即 $S = \{a, b\}$，则 $\bigvee S$ 可写作 $a \vee b$，称为 $a$ 和 $b$ 的 <strong>联合（Join）</strong>；$\bigwedge S$ 可写作 $a \wedge b$，称为 $a$ 和 $b$ 的 <strong>交汇（Meet）</strong>。</p></div></div></div><p>并不是每一个偏序集都有最小上界或者最大下界，比如说 $(Z,\leq)$，子集 $Z_+$ 就没有最小上界。同时如果一个偏序集存在最小上界，则这个偏序集最小上界是唯一的；如果一个偏序集存在最大下界，则这个偏序集的最大下界也是唯一的。</p><h4 id=格 class=heading-element><span>格</span>
<a href=#%e6%a0%bc class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>格就是在偏序的基础上定义的，相关理论如下所示：</p><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>格</div><div class=details-content><div class=admonition-content><p>考虑偏序集 $(P, \preccurlyeq)$，如果 $\forall a, b \in P$，$a \vee b$ 和 $a \wedge b$ 都存在，则我们称 $(P, \geq)$ 为 <strong>格（Lattice）</strong>。</p></div></div></div><p>简单理解，格是每对元素都存在最小上界和最大下界的偏序集。</p><p>比如说 $(Z, \leq)$ 是格，其中 $\vee = \max$，$\wedge = \min$；$(2^S, \subseteq)$ 也是格，其中 $\vee = \cup$，$\wedge = \cap$。</p><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>半格</div><div class=details-content><div class=admonition-content><p>考虑偏序集 $(P, \preccurlyeq)$，</p><ul><li>如果 $\forall a, b \in P$，$a \vee b$ 存在，则称 $(P, \preccurlyeq)$ 为 <strong>联合半格（Joint Semilattice）</strong>;</li><li>如果 $\forall a, b \in P$，$a \wedge b$ 存在，则称 $(P, \preccurlyeq)$ 为 <strong>交汇半格（Meet Semilattice）</strong>。</li></ul><p>联合半格和交汇半格统称为 <strong>半格（Semilattice）</strong>。
如果 $\forall S \subseteq P$，$\bigvee S$ 和 $\bigwedge S$ 都存在，则称 $(P, \preccurlyeq)$ 为 <strong>全格（Complete Lattice)</strong>。每一个有限格 $(P, \preccurlyeq)$（$P$ 是有限集）都是一个全格。</p></div></div></div><p>简单理解，全格的所有子集都有最小上界和最大下界。由于 $(Z, \leq)$ 的子集 $Z_+$ 没有最小上界，因此它不是全格；与之不同的 $(2^S, \subseteq)$ 就是一个全格。</p><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>顶部和底部</div><div class=details-content><div class=admonition-content><p>每一个全格 $(P, \preceq)$ 都有一个序最大的元素 $\top = \bigvee P$ 称作 <strong>顶部（Top）</strong>，和一个序最小的元素 $\perp = \bigwedge P$ 称作 <strong>底部 （Bottom）</strong>。</p></div></div></div><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>积格</div><div class=details-content><div class=admonition-content><p>考虑偏序集 $L_1 = (P_1, \preceq_1), \ L_2 = (P_2, \preceq_2),\ \ldots,\ L_n = (P_n, \preceq_n)$，其中 $L_i = (P_i, \preceq_i), \ i = 1, 2, \ldots, n$ 的 LUB 运算为 $\bigvee_i$，GLB 运算为 $\bigwedge_i$，定义积格（Product）为 $L^n = (P, \preceq)$，满足：</p><ul><li>$P = P_1 \times P_2 \times \ldots \times P_n$</li><li>$(x_1, x_2, \ldots, x_n) \preceq (y_1, y_2, \ldots, y_n) \Leftrightarrow (x_1 \preceq y_1) \wedge (x_2 \preceq y_2) \wedge \ldots \wedge (x_n \preceq y_n)$</li><li>$(x_1, x_2, \ldots, x_n) \wedge (y_1, y_2, \ldots, y_n) = (x_1 \wedge y_1, x_2 \wedge y_2, \ldots, x_n \wedge y_n)$</li><li>$(x_1, x_2, \ldots, x_n) \vee (y_1, y_2, \ldots, y_n) = (x_1 \vee y_1, x_2 \vee y_2, \ldots, x_n \vee y_n)$</li></ul><p>这里积格是格。全格的积格还是全格。</p></div></div></div><h4 id=不动点 class=heading-element><span>不动点</span>
<a href=#%e4%b8%8d%e5%8a%a8%e7%82%b9 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>上述算法都是达到不动点就结束了，这就涉及到不动点理论。</p><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>单调函数</div><div class=details-content><div class=admonition-content><p>这里称一个函数 $f_{L \rightarrow L}$（$L$ 是格）是 <strong>单调的（Monotonic）</strong>，具有 <strong>单调性（Monotonicity）</strong>，如果 $\forall x, y \in L, x \preceq y \Rightarrow f(x) \preceq f(y)$。</p></div></div></div><p>这里格和格所在的那个集合一般是不严格区分的，也就是说，$L$ 既可以表示格，也可以表示定义格的那个集合。</p><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>相关知识</div><div class=details-content><div class=admonition-content><p><ul><li>如果 $f(\alpha) = \alpha$，则称 $\alpha$ 是一个函数 $f$ 的 <strong>不动点（Fixed Point）</strong>。</li><li>一个格的高度 $h$ 为从底部到顶部的最长路径。</li></ul></div></div></div><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>不动点定理</div><div class=details-content><div class=admonition-content><p>考虑一个全格 $(L, \preceq)$，如果 $f_{L \rightarrow L}$ 是单调的且 $L$ 是有限集，那么序最小的不动点（Least Fixed Point）可以通过如下的迭代序列找到：
$$
f(\perp), f(f(\perp)), \ldots, f^{h+1}(\perp)
$$
序最大的不动点 (Greatest Fixed Point) 可以通过如下的迭代序列找到：
$$
f(\top), f(f(\top)), \ldots, f^{h+1}(\top)
$$
其中，$h$ 是 $L$ 的高度。</p></div></div></div><p>上述可以通过鸽笼原理来进行证明。同时由此知道一个格上的单调函数一定能够对端点元素（$\top$ 和 $\perp$）迭代出不动点，并且上述 <strong>交汇</strong> $\wedge$ 和 <strong>联合</strong> $\vee$ 操作都是单调的。但是这里还不能因此说明迭代算法也有这样的性质，除非之后可以将迭代算法和不动点定理关联起来。</p><h4 id=分配性 class=heading-element><span>分配性</span>
<a href=#%e5%88%86%e9%85%8d%e6%80%a7 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>分配性</div><div class=details-content><div class=admonition-content><p>由上述定义可知，定义在格 $(L, \preceq)$ 上的单调函数 $f(x)$ 满足：
$$
f(x) \vee f(y) \preceq f(x \vee y), \quad f(x \wedge y) \preceq f(x) \wedge f(y)
$$
而如果 $f(x \vee y) = f(x) \vee f(y)$，$f(x \wedge y) = f(x) \wedge f(y)$，那么称定义在格 $(L, \preceq)$ 上的函数 $f(x)$ 满足分配性（Distributive）。</p></div></div></div><h3 id=单调框架 class=heading-element><span>单调框架</span>
<a href=#%e5%8d%95%e8%b0%83%e6%a1%86%e6%9e%b6 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><h4 id=迭代算法 class=heading-element><span>迭代算法</span>
<a href=#%e8%bf%ad%e4%bb%a3%e7%ae%97%e6%b3%95 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>本文对于常见的四种算法进行了描述，但是其他类型的数据流分析也由类似的迭代算法，它们都很相似。于是可以使用一种具有通用性的数据流分析算法来提供一种通用的数据流分析的解决方案。可以从另外一种角度，也就是上面说的数学角度来看待迭代算法：</p><ul><li>给定一个具有 $k$ 个结点的程序流程图（CFG），对于 CFG 中的每个结点 $n$，迭代算法的每一次迭代都会更新 $OUT[n]$。</li><li>设数据流分析的定义域为 $V$，那么可以定义一个 $k$ 元组（k-tuple）来表示每次迭代后的分析值：</li></ul><p>$$
(OUT[n_1], OUT[n_2], \ldots, OUT[n_k]) \in V \times V \times \ldots \times V = V^k
$$</p><ul><li><p>每次迭代可以视为将 $V^{k}$ 中的某个值映射为 $V^{k}$ 中的另一个值，通过状态转移方程和控制流约束式，这个过程可以抽象为一个函数 $F_{V^{k} \rightarrow V^{k}}$。</p></li><li><p>算法输出一系列的 $k$ 元组，直到某两个连续输出的 $k$ 元组完全相同时算法终止。</p></li></ul><p>因此算法的过程可以表示为下面的过程，其中 $v_i^{j}$ 表示第 $i$ 个结点第 $j$ 次迭代后的数据流值。</p><table><thead><tr><th>步骤</th><th>表达式</th></tr></thead><tbody><tr><td>初始化</td><td>$(\bot, \bot, \ldots, \bot) = X_0$</td></tr><tr><td>第 1 次迭代</td><td>$(v_1^{1}, v_2^{1}, \ldots, v_k^{1}) = X_1 = F(X_0)$</td></tr><tr><td>第 2 次迭代</td><td>$(v_1^{2}, v_2^{2}, \ldots, v_k^{2}) = X_2 = F(X_1)$</td></tr><tr><td>&mldr;</td><td>&mldr;</td></tr><tr><td>第 i 次迭代</td><td>$(v_1^{i}, v_2^{i}, \ldots, v_k^{i}) = X_i = F(X_{i-1})$</td></tr><tr><td>第 i+1 次迭代</td><td>$(v_1^{i}, v_2^{i}, \ldots, v_k^{i}) = X_{i+1} = F(X_i) = X_i$</td></tr></tbody></table><p>这里通过上述数学角度来审视迭代算法，因此在 i+1 此迭代时，也会因为鸽笼原理到达不动点。由此在上述过程中，在 $X_{i+1} = F(X_i) = X_i$ 时，抵达了不动点，算法也就是停止了，由此 $X_i$ 是函数 $F$ 的一个不动点。通过这个角度，可以将数据流分析中的迭代算法转化为对于格值的分析，但是还是存在一些疑问：</p><ul><li>算法是否保证终止？不动点一定存在吗？</li><li>不动点是否唯一？算法终止的不动点是否是最优的？</li><li>算法何时到达不动点？</li></ul><p>这里问题的解决就需要使用到下面的单调框架的知识。</p><h4 id=框架解释 class=heading-element><span>框架解释</span>
<a href=#%e6%a1%86%e6%9e%b6%e8%a7%a3%e9%87%8a class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>数据流分析中的单调框架是一种用于确保数据流分析算法的安全性、终止性和收敛性的通用框架。这个框架允许通过配置不同的参数来导出各种类型的数据流分析算法。</p><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>数据流分析框架</div><div class=details-content><div class=admonition-content><p>一个 <strong>数据流分析框架（D，L，F）</strong> 由以下三个部分组成：</p><ul><li><strong>D（Direction）</strong>：数据流的方向，表示正向或者逆向；</li><li><strong>L（Lattice）</strong>：一个包含值集 <em>V</em> 的域（即 <em>V</em> 的幂集）的格和一个交汇或者联合操作符；</li><li><strong>F（Function Family）</strong>：一个从 <em>V</em> 到 <em>V</em> 的转移函数族；</li></ul></div></div></div><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250112165505.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250112165505.png?size=small" data-sub-html="<h2>20250112165505</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250112165505.png alt=数据流与格 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250112165505.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250112165505.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250112165505.png?size=large 2x" data-title=20250112165505 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>数据流与格</figcaption></figure></p><p>对于每一个结点而言，数据流分析就是在某个格的值上迭代应用转移函数和交汇/联合操作的过程。因为这里结点的定义域是值集 $V$ 的幂集，它形成一个天然的全格 $(L, \subseteq)$，所以可以将数据流分析和格进行关联。</p><p>而对于整个控制流图（CFG）而言，数据流分析可以被视为在所有结点的格的积格上迭代应用转移函数和交汇/联合操作。假设有 $k$ 个结点，结合上述偏序集的概念，可以把每次迭代视为 $F_{L^{k} \rightarrow L^{k}}$，其中 $L^k$ 是一个全格。这里也就是指每次迭代，其实是所有结点对应的格值进行一次转换的过程。这里 $F$ 由两部分组成：</p><ul><li>一个部分是状态转移方程 $f_{L \rightarrow L}$，上述描述的三种算法都是单调的，因此在进行其他分析而设计状态转移方程时，需要保证其单调性。也就是说，一个设计糟糕的状态转移方程可能是不单调的，从而导致迭代算法无法终止，或者无法求出符合预期的结果。</li><li>另一个部分是交汇/联合操作函数 $f_{L \times L \rightarrow L}$，上述也指出了这两个操作都是单调的。</li></ul><p>由此可以确定函数 $F$ 是单调的，因此其也满足了不动点定理的条件。那么根据不动点定理，已经证明了这里的 $F$ 是单调的，就可以回答上述的三个问题。</p><ul><li>迭代算法一定会达到不动点。由不动点定理，在有限的格中，，迭代过程必然会在有限步骤内达到不动点；</li><li>不动点不一定是唯一的，但是通常关注的是序最小不动点（对于正向分析）或序最大不动点（对于逆向分析），这取决于分析的类型。这里不动点定理保证了最小不动点的存在，并且通过迭代可以找到这个不动点。</li><li>算法会在迭代过程中不断更新 $X_i$ 直到 $X_{i+1} = F(X_i) = X_i$，此时 $X_i$ 是 $F$ 的一个不动点。迭代次数最多为格的高度 $h$，最坏情况下，迭代次数为 $k \cdot h + 1$（最坏情况是在每次迭代中，k 个结点的格中只有一个格变化了一次，并且直到 $\top$ 才找到不动点，加一的最后一次用于确认所有的数据流值都不会发生变化了），其中 $k$ 是 CFG 的结点个数，$h$ 是定义域格的高度。</li></ul><h2 id=常量传播分析 class=heading-element><span>常量传播分析</span>
<a href=#%e5%b8%b8%e9%87%8f%e4%bc%a0%e6%92%ad%e5%88%86%e6%9e%90 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><h3 id=问题描述-3 class=heading-element><span>问题描述</span>
<a href=#%e9%97%ae%e9%a2%98%e6%8f%8f%e8%bf%b0-3 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>Constant Propagation Analysis</div><div class=details-content><div class=admonition-content><p>对于程序点 <em>p</em> 处的变量 <em>x</em>，分析 <em>x</em> 在 <em>p</em> 处是否为一个常量就是 <strong>常量传播分析（Constant Propagation Analysis）</strong>。</p></div></div></div><p>这里如果知道了某程序点处的某些变量一定是一个常量的话，就可以直接优化，将这个变量视为常量，从而减少内存的消耗（可以在编译的时候就完成一部分计算，并且有些常量并不需要分配储存它的内存空间）。</p><h3 id=问题分析-3 class=heading-element><span>问题分析</span>
<a href=#%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90-3 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><h4 id=数据抽象-3 class=heading-element><span>数据抽象</span>
<a href=#%e6%95%b0%e6%8d%ae%e6%8a%bd%e8%b1%a1-3 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>这里可以使用一个有序对 $(x,v)$ 的集合表示每个程序点处的抽象程序状态，其中 $x$ 是变量名，$v$ 是变量的常数值，$v$ 的取值可能为某个常数，<code>UNDEF</code>（Undefined）或 <code>NAC</code>（Not A Constant）。</p><h4 id=控制流约束 class=heading-element><span>控制流约束</span>
<a href=#%e6%8e%a7%e5%88%b6%e6%b5%81%e7%ba%a6%e6%9d%9f class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>基于上述数据抽象，可以定义值之间的交汇操作：</p><ul><li>$(x,v) \land (x,NAC)=(x,NAC)$：变量和任意常量交汇还是变量。因为这里采用必然性分析策略，只有当变量值确定为常量时，才认为它是常量；</li><li>$(x,\text{UNDEF}) \land (x,v)=(x,v)$：未初始化的变量 <code>UNDEF</code> 不在关注的范围内，出现 <code>Undefined</code> 错误应由 <code>Reaching Definitions</code> 负责，因此在交汇时可忽略 UNDEF；</li><li>$(x,v_1) \land (x,v_2) = \begin{cases}(x,v_1), &\text{if }v_1=v_2\\(x,\text{NAC}),&\text{otherwise}\end{cases}$<ul><li>若是 $v_1 = v_2$，结果为 $(x,v_1)$，表明在该程序点处，变量 $x$ 可以被视为常量 $v_1$；</li><li>若是 $v_1 \not ={v_2}$，结果为 $(x, \text{NAC})$，说明两个不同的值汇聚到某一点，该变量不是常量；</li></ul></li></ul><h4 id=状态转移方程 class=heading-element><span>状态转移方程</span>
<a href=#%e7%8a%b6%e6%80%81%e8%bd%ac%e7%a7%bb%e6%96%b9%e7%a8%8b class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>考虑语句 $s: x = &mldr;$，定义其状态转移方程为：</p><p>$$
F: OUT[s]=gen_s \cup (IN[s] - \{ (x ,\_ ) \})
$$</p><p>其中，$(x,\_)$ 是一个通配符，表示所有的以 $x$ 作为第一个元素的有序数对，也就是变量名为 $x$ 的变量。为了表示方便，下面用 $val(x)$ 来表示变量 $x$ 的值（它可能是常数，<code>UNDEF</code>或者<code>NAC</code>），定义 $gen_s$ 如下：</p><ul><li>如果 $s: x = c$（$c$ 是常量），则 $gen_s=\{(x,c)\}$；</li><li>如果 $s: x = y$，则 $gen_s = \{(x,val(y))\}$；</li><li>如果 $s: x = y \ op \ z$，则 $gen_s = \{(x,f(y,z))\}$，其中，
$$
f(y,z) = \begin{cases}
val(y) \ op \ val(z),&\text{if }y \text{ and }z \text{ are constants} \\
\text{NAC},&\text{if }y \text{ or }z \text{ is NAC} \\
\text{UNDEF},&\text{otherwise}
\end{cases}
$$</li><li>如果 $s$ 不是赋值语句，则 $OUT[s] = IN[s]$；</li></ul><blockquote><p>关于上述 $y \ op \ z$ 的操作，认为 <code>NAC / 0</code> 和 <code>NAC mod 0</code> 的结果都为 <code>UNDEF</code>。不过这些对于常量优化不重要，因为这些是程序逻辑错误，不是常量优化可以解决的。</p></blockquote><h4 id=总结 class=heading-element><span>总结</span>
<a href=#%e6%80%bb%e7%bb%93 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>由上述分析，可以得到该算法的相关信息：</p><div class="details admonition tip open"><div class="details-summary admonition-title"><i class="icon fa-fw fa-regular fa-lightbulb" aria-hidden=true></i>活跃变量分析<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content><p>对于程序点 <em>p</em> 处的变量 <em>x</em>，分析 <em>x</em> 在 <em>p</em> 处是否为一个常量就是 <strong>常量传播分析</strong>。如果知道某程序点处的某些变量一定是常量，则可以直接优化，将该变量视为常量，从而减少内存消耗（可以在编译时完成部分计算，并且某些常量不需要分配存储空间）。</p><ul><li>分析方向：正向分析</li><li>半格元素：有序对 $(x, v)$ 的集合，其中 $x$ 是变量名，$v$ 是变量的常数值（可能为常数、<code>UNDEF</code> 或 <code>NAC</code>）。</li><li>合并运算：上述控制流约束中的三种情况</li><li>最小元：所有变量映射到 UNDEF，表示初始状态下变量的值未知。</li><li>输出值：所有变量映射到 UNDEF，输入值是最小元，表示初始状态下没有任何信息。</li><li>转换函数：$OUT[s]=gen_s \cup (IN[s] - \{ (x ,\_ ) \})$<ul><li>对于赋值语句，更新变量的值。具体查阅上面的状态转移方程内容。</li><li>对于非赋值语句，变量的值保持不变。</li></ul></li></ul></div></div></div><h2 id=算法精度分析 class=heading-element><span>算法精度分析</span>
<a href=#%e7%ae%97%e6%b3%95%e7%b2%be%e5%ba%a6%e5%88%86%e6%9e%90 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>上述的四种数据流分析，前三者的转移方程满足分配性，而常量传播的转移方程不满足分配性，因此它们迭代算法的精度也不同。这里就涉及到算法的精度分析：</p><h3 id=mop-算法 class=heading-element><span>MOP 算法</span>
<a href=#mop-%e7%ae%97%e6%b3%95 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>路径概念</div><div class=details-content><div class=admonition-content><p>对于从程序入口沿着某条控制流到某个程序点 $s_i$ 处所经过的所有语句，可以记为 $P = \text{ENTRY} \to s_1 \to s_2 \to &mldr; \to s_i$ ，称序列 $s_1s_2&mldr;s_i$ 是到程序点 $(s_i, s_{i + 1})$ 的一条 <strong>路径（Path）</strong>。而若该路径上每个语句的状态转移方程为 $f_{s_i}$，则路径 $P$ 的状态转移方程为
$$
F_P = f_{s_i} \circ f_{s_{i - 1}} \circ &mldr; \circ f_{s_2} \circ f_{s_1}
$$</p></div></div></div><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>MOP</div><div class=details-content><div class=admonition-content><p>数据流分析 <strong>全路交汇（Meet-Over-All-Paths）</strong> 方法用于计算程序点 $(s_i, s_{i+1})$ 处的数据流值 $MOP[s_i]$，其计算步骤如下：</p><ul><li>确定从程序入口至 $s_i$ 的所有路径 $P$，并获取每条路径对应的状态转移方程 $F_P$，将这些路径的集合记作 $Paths(ENTRY, s_i)$；</li><li>对 $Paths(ENTRY, s_i)$ 中各路径的状态转移方程 $F_P$ 应用联合或交汇操作，以求得这些路径数据流值的最小上界或最大下界。其形式化表达为：
$$
MOP[s_i] = \bigvee_{\forall P \in Paths(ENTRY, s_i)} F_P(OUT[ENTRY])
$$
或
$$
MOP[s_i] = \bigwedge_{\forall P \in Paths(ENTRY, s_i)} F_P(OUT[ENTRY])
$$</li></ul></div></div></div><p>由于 CFG 中并不是每一条控制流都会被执行的，所以 MOP 算法并不是完全精确的。并且由于 MOP 算法需要考虑所有的路径，因此它也是不现实的。故而实际并不会使用 MOP 算法，而更多的把 MOP 当作是用于比较分析其他算法精度的标尺。</p><h3 id=mop-与迭代算法 class=heading-element><span>MOP 与迭代算法</span>
<a href=#mop-%e4%b8%8e%e8%bf%ad%e4%bb%a3%e7%ae%97%e6%b3%95 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>这里通过一个例子比较两个算法<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250113165104.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250113165104.png?size=small" data-sub-html="<h2>20250113165104</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250113165104.png alt=算法比较举例 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250113165104.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250113165104.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250113165104.png?size=large 2x" data-title=20250113165104 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>算法比较举例</figcaption></figure>如果采用迭代算法进行分析，最终得到：
$$
IN[s_4] = f_{s_3}(f_{s_1}(OUT[ENTRY]) \vee f_{s_2}(OUT[ENTRY]))
$$</p><p>如果采用 MOP 算法，最终得到：
$$
IN[s_4] = f_{s_3}(f_{s_1}(OUT[ENTRY])) \vee f_{s_3}(f_{s_2}(OUT[ENTRY]))
$$</p><p>从上述例子可以发现，迭代算法求的是 $F(x\vee y)$ ，而 MOP 算法求的是 $F(x) \vee F(y)$（如果是交汇操作也是类似的）。简单而言，迭代算法就是先进行交汇，然后再使用状态转移方程；而 MOP 算法是先把每条路径采用状态转移方程计算，最后再进行交汇操作。根据格上的分配性定理，可以看出 $F(x) \vee F(y) \preceq F(x\vee y)$ ，那么以 May Analysis 为例，迭代算法的精度不如MOP。</p><p>不过，当 $F(x)$ 满足分配性的时候，迭代算法的精度和 MOP 是一样的。上述四种数据流分析的前三种的状态转移方程就是满足分配行的，也就是说，在这些情景下，迭代算法可以达到 MOP 算法的精度，但是它的实现要比 MOP 简单得多。其实对于许多可以通过 $gen/kill$ 的视角来解决的问题，其状态转移都是满足分配性的。但是对于最后一种数据流分析，也就是常量传播分析，它的状态转移方程就不满足分配性，下面就是常量传播的一个例子：<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250113165843.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250113165843.png?size=small" data-sub-html="<h2>20250113165843</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250113165843.png alt=对比举例 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250113165843.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250113165843.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250113165843.png?size=large 2x" data-title=20250113165843 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>对比举例</figcaption></figure>对于上图，可以得到下面两个结果：</p><ul><li>$F(X \wedge Y) = \{(a, NAC), (b, NAC), (c, NAC)\}$</li><li>$F(X) \wedge F(Y) = \{(a, NAC), (b, NAC), (c, 10)\}$</li></ul><p>这里虽然 $F(X \wedge Y) \preceq F(X) \wedge F(Y)$，与单调性是契合的。但是 $F(X \wedge Y) \ne F(X) \wedge F(Y)$，它不满足分配性。因此其迭代算法的精度达不到 MOP 精度。</p><h2 id=工作表算法 class=heading-element><span>工作表算法</span>
<a href=#%e5%b7%a5%e4%bd%9c%e8%a1%a8%e7%ae%97%e6%b3%95 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250113172615.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250113172615.png?size=small" data-sub-html="<h2>20250113172615</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250113172615.png alt=迭代算法 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250113172615.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250113172615.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250113172615.png?size=large 2x" data-title=20250113172615 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>迭代算法</figcaption></figure><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250113172627.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250113172627.png?size=small" data-sub-html="<h2>20250113172627</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250113172627.png alt="WorkList 算法" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250113172627.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250113172627.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250113172627.png?size=large 2x" data-title=20250113172627 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>WorkList 算法</figcaption></figure></p><p>上述都是正向可能性分析的算法，但是后者工作表算法是对于前者迭代算法的优化。具体的优化就是使用一个集合存储下一次遍历中会发生变化的基本块，从而避免对已经达到不动点的基本块进行重复遍历。同时该 $WorkList$ 需要采用去重实现，防止出现重复的基本块导致不必要的重复计算。</p><p>此外，算法的最后一行仅将输出状态发生变化的基本块的后继（即下一轮输入状态会发生变化的基本块）加入工作表。这是因为只有输入状态发生变化时，输出状态才会相应变化，而 $gen_B$ 和 $kill_B$ 是预先计算的，它们固定不变。</p><p>本质上，该算法是图的广度优先遍历算法的变体，融入了剪枝逻辑，每轮仅遍历可能发生变化的节点，而将不发生变化的节点提前从遍历流程中剔除。</p><h2 id=widening--narrowing class=heading-element><span>Widening & Narrowing</span>
<a href=#widening--narrowing class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><div class="details admonition abstract open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-clipboard-list" aria-hidden=true></i>注意事项</div><div class=details-content><div class=admonition-content><p>下面的内容大部分来自于 <a href=https://blog-blockchain.xyz/pl/data-flow-analysis/ target=_blank rel="external nofollow noopener noreferrer">数据流分析基础</a>，它是对 <a href="https://www.bilibili.com/video/BV1Rt4y1s7tC/?spm_id_from=333.337.search-card.all.click" target=_blank rel="external nofollow noopener noreferrer">《软件分析技术》</a> 课程的相关内容的总结。</p></div></div></div><p>标准数据流分析有可能收敛得很慢，甚至有可能因为半格的高度无限导致不收敛。为了让结果收敛得更快，可以使用 <strong>加宽（Widening）</strong> 的方法。加宽之后结果也会随之变得不精确，这时候可以使用 <strong>变窄（Narrowing）</strong> 的方法，进一步让结果变精确。</p><h3 id=区间分析 class=heading-element><span>区间分析</span>
<a href=#%e5%8c%ba%e9%97%b4%e5%88%86%e6%9e%90 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>这里使用区间分析作为例子分析 Widening 和 Narrowing。</p><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>区间分析</div><div class=details-content><div class=admonition-content><p>区间分析是一种静态分析技术，用于确定程序中每个变量的取值范围。其核心思想是通过分析程序中的语句，逐步推导出每个变量的可能取值区间。区间分析通常采用正向分析的方式，从程序的入口开始，沿着控制流的方向逐步推导变量的区间，采用上近似。相关的信息如下：</p><ul><li>分析方向：正向分析</li><li>半格元素：程序中每个变量的区间</li><li>合并运算：每个变量的区间对应求并，<strong>区间的并</strong> 定义为
$$
[a,b] \sqcup [c,d] = [\min(a,c), \max(b,d)]
$$</li><li>最小元：每个变量都映射到 $L$ 上（$L$ 表示未定义或未知的区间，通常为 $[-\infty, +\infty]$），它表示初始状态下变量的取值范围未知</li><li>输入值：根据具体分析任务的输入上下界确定</li><li>转换函数：根据程序语句对区间进行计算</li></ul></div></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>b</span><span class=p>;</span> <span class=n>i</span> <span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span> <span class=o>=</span> <span class=n>a</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=n>a</span><span class=p>;</span></span></span></code></pre></td></tr></table></div></div><p>对于上面的程序，其结果就是 $a : [0, +\infty]$。根据这个程序可以知道，如果正向进行，那么变量的范围应当是逐渐扩大的。根据上述合并运算，该区间会发生变化。例如添加一个变量：
$$
[a, b] + [c, d] = [a + c, b + d] \\
[a, b] - [c, d] = [a - d, b - c]
$$</p><p>但是这样构成的半格高度是无限的，而且操作也不能保证单调性，因此提出了改进策略 —— 人为指定上下界。如果下界大于类型的最大值，那么为空值，程序异常；如果下界小于最大值，那么更新下界和上界，其中最大值之和与类型最大值取其中小者。</p><p>$$
\begin{cases}
[a, b] + [c, d] = \emptyset & a + c > \text{int\_max}\\
(a + c, \min(b + d, \text{int\_max})) & a + c \leq \text{int\_max}
\end{cases}
$$</p><h3 id=基础-windening class=heading-element><span>基础 Windening</span>
<a href=#%e5%9f%ba%e7%a1%80-windening class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>但是在数据流分析中，某些情况下状态空间可能非常大，导致分析过程收敛缓慢。例如，在区间分析中，变量的区间可能无限扩大。而 <strong>基础 Widening</strong> 是一种用于加速数据流分析收敛的技术。它的核心思想是通过 <strong>降低结果的精度</strong> 来减少分析的状态空间，从而加快分析的收敛速度。具体来说，Widening 通过引入一个 <strong>单调函数</strong> $w$，将原本的半格映射为一个新的、高度更低的格，从而减少分析过程中的状态数，即 $f \leftarrow w \circ f$。例如在上述区间分析中可以预定范围：</p><ul><li>定义有限集合：$B = \{ -\infty, 10, 20, 50, 100, +\infty \}$；</li><li>定义映射函数：$w: w([l, h]) = \big[ \max \{i \in B \mid i \leq l \}, \min \{i \in B \mid h \leq i \} \big]$，它将原始的区间映射为
$B$ 中的区间；</li></ul><p>这样就可以把区间 $[15, 75]$、$[11, 90]$ 等映射为 $[10, 100]$ 了，即 $w([15, 75]) = [10, 100]$。此时由于状态数大幅度减少，所以很大程度上加快了收敛速度。</p><p>再对于下面的代码对比是否应用基础 Windening 的区别：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>y</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>while</span><span class=p>(</span><span class=n>input</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span> <span class=o>=</span> <span class=mi>7</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span> <span class=o>=</span> <span class=n>x</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>y</span> <span class=o>=</span> <span class=n>y</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>这里有限集合为：$\{−\infty, 0, 1, 7, +\infty \}$，那么每次循环 <code>while(input)</code> 处语句的状态如下所示：<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250114174807.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250114174807.png?size=small" data-sub-html="<h2>20250114174807</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250114174807.png alt=结果对比 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250114174807.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250114174807.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250114174807.png?size=large 2x" data-title=20250114174807 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>结果对比</figcaption></figure></p><p>这里基础 Widening 的安全性指通过 Widening 技术得到的结果不会丢失原始分析的正确性，具体表现为 Widening 的结果必须是原始结果的 <strong>上近似</strong>，即满足 $w(x) \sqsubseteq x$，其中 $x$ 是原始分析的结果，$w(x)$ 是 Widening 后的结果。安全性得以保证的原因是 Widening 函数 $w$ 是单调的，即如果 $x \sqsubseteq y$，则 $w(x) \sqsubseteq w(y)$，因此 Widening 后的结果不会比原始结果更精确，但也不会丢失原始结果的正确性。例如，在区间分析中，若原始结果为 $[15, 75]$，Widening 后的结果为 $[10, 100]$，则 $[10, 100]$ 包含了 $[15, 75]$，从而确保了正确性。此外，Widening 的收敛性是指通过 Widening 技术，分析过程能够在有限的步骤内收敛到一个固定点。这是因为 Widening 函数 $w$ 将状态空间映射为一个有限的集合，且 $w$ 是单调的，避免了分析过程中的振荡或无限循环，从而保证了分析过程必然会在有限的步骤内收敛。</p><h3 id=一般-windening class=heading-element><span>一般 Windening</span>
<a href=#%e4%b8%80%e8%88%ac-windening class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p><strong>一般 Widening</strong> 是对基础 Widening 的改进，旨在在 <strong>精度</strong> 和 <strong>收敛速度</strong> 之间取得更好的平衡。与基础 Widening 不同，一般 Widening 不仅参考更新前的值，还参考更新后的值，从而更智能地猜测最终收敛的值。其核心思想是通过自定义的 <strong>Widening 算子</strong> $\nabla$，在保证安全性和收敛性的同时，提高分析的性能。</p><ul><li>定义 Widening 算子 $\nabla$，满足：$\text{DATA}_v \leftarrow \text{DATA}_v \nabla f_v(\text{MEET}_v)$。其中：<ul><li>$\text{DATA}_v$ 是节点 $v$ 的当前值；</li><li>$f_v$ 是节点 $v$ 的转换函数；</li><li>$\text{MEET}_v$ 是节点 $v$ 的前驱节点的交汇结果。</li></ul></li><li>Widening 算子 $\nabla$ 的具体规则由用户定义，通常基于对程序行为的经验或启发式规则。</li></ul><p>之后对于同样的代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>y</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>while</span><span class=p>(</span><span class=n>input</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span> <span class=o>=</span> <span class=mi>7</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span> <span class=o>=</span> <span class=n>x</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>y</span> <span class=o>=</span> <span class=n>y</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>就可以更改节点的交汇规则，这里的 $\top$ 表示格中最高层的元素。
$$
[a, b] \nabla \top = [a, b] \\
\top \nabla [c, d] = [c, d] \\
[a, b] \nabla [c, d] = [x, y] \quad \text{where} \\
x =
\begin{cases}
a & c \geq a \\
-\infty & c &lt; a
\end{cases} \\
y =
\begin{cases}
b & d \leq b \\
+\infty & d > b
\end{cases}
$$</p><p>由此可以将这些结果进行比对：<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250114181212.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250114181212.png?size=small" data-sub-html="<h2>20250114181212</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250114181212.png alt=结果比对 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250114181212.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250114181212.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250114181212.png?size=large 2x" data-title=20250114181212 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>结果比对</figcaption></figure></p><p>这里一般 Widening 的安全性通过确保 Widening 算子 $\nabla$ 满足 $(x \nabla y) \sqsubseteq x$ 且 $(x \nabla y) \sqsubseteq y$ 来保证，即 Widening 的结果是原始结果的上近似，因此不会丢失正确性。例如，在区间分析中，若 $x = [10, 20]$，$y = [15, 25]$，则 $x \nabla y$ 的结果可能是 $[10, 25]$，这包含了 $x$ 和 $y$ 的所有可能值。然而，一般 Widening 的收敛性难以通用保证，因为 Widening 算子 $\nabla$ 的行为与转换函数 $f_v$ 的趋势密切相关，且不一定在半格上保持单调性，可能导致分析过程振荡或无法收敛。特别是在多条路径交汇时，如果交汇操作是逐个进行的，处理前驱节点的顺序可能影响最终结果，进一步增加了不收敛的风险。尽管如此，通过合理设计 Widening 算子 $\nabla$，一般 Widening 在实践中通常能够在精度和收敛速度之间取得较好的平衡，从而提高数据流分析的性能。</p><h3 id=narrowing class=heading-element><span>Narrowing</span>
<a href=#narrowing class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p><strong>Narrowing</strong> 是一种用于提高 Widening 结果精度的技术。Widening 通过扩大区间来加速收敛，但可能导致结果过于粗略；而 Narrowing 则通过再次应用原始转换函数对 Widening 的结果进行修正，从而缩小区间，提高精度。Narrowing 的核心思想是在某些步骤中不再使用 Widening，而是直接应用原始转换函数，从而逐步逼近更精确的结果。</p><ul><li>定义 Narrowing 算子 $\Delta$，满足： $\text{DATA}_v \leftarrow \text{DATA}_v \Delta f_v(\text{MEET}_v)$。其中：<ul><li>$\text{DATA}_v$ 是节点 $v$ 的当前值。</li><li>$f_v$ 是节点 $v$ 的原始转换函数。</li><li>$\text{MEET}_v$ 是节点 $v$ 的前驱节点的交汇结果。</li></ul></li><li>Narrowing 算子 $\Delta$ 的具体规则由用户定义，通常用于缩小区间。</li></ul><p>对于下面的代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>y</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=mi>7</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=n>x</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>while</span><span class=p>(</span><span class=n>input</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span> <span class=o>=</span> <span class=mi>7</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span> <span class=o>=</span> <span class=n>x</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>y</span> <span class=o>=</span> <span class=n>y</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>Narrowing 就是在某一步就不采用 Widening 的方法，而是用原始的函数。例如下图 x 的值的区间在第 5 步突然缩小了：<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250114191338.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250114191338.png?size=small" data-sub-html="<h2>20250114191338</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250114191338.png alt="Narrowing 结果" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250114191338.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250114191338.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250114191338.png?size=large 2x" data-title=20250114191338 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>Narrowing 结果</figcaption></figure>而根据上面算子的定义，可以得到下面的规则。这里的含义就是已经收敛到的整数不进行变动，只重新计算被 Widening 扩展到无穷大的情况。
$$
[a, b] \Delta [c, d] = [x, y], \text{ where} \\
x =
\begin{cases}
a & a \neq -\infty \\
c & a = -\infty
\end{cases} \\
y =
\begin{cases}
b & b \neq +\infty \\
d & b = +\infty
\end{cases}
$$</p><p>这里 Narrowing 的安全性通过确保 Narrowing 算子 $\Delta$ 满足 $x \Delta y \sqsubseteq y$ 来保证（$x$ 是 Narrowing 前的值，$y$ 是 Narrowing 后的值），即 Narrowing 的结果是原始结果的下近似，因此不会丢失正确性。例如，在区间分析中，若 Widening 后的结果是 $[10, 100]$，Narrowing 后的结果可能是 $[20, 80]$，这仍然包含了实际的可能值。具体推导可以参考下图：<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250114192027.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250114192027.png?size=small" data-sub-html="<h2>20250114192027</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250114192027.png alt="Narrowing 的安全性" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250114192027.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250114192027.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250114192027.png?size=large 2x" data-title=20250114192027 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>Narrowing 的安全性</figcaption></figure>然而，Narrowing 的收敛性无法保证，即使收敛，也不能保证快速收敛。这是因为 Narrowing 的结果依赖于 Widening 的不动点，而 Widening 的不动点可能已经丢失了一些精度；同时，Narrowing 算子 $\Delta$ 的行为与转换函数 $f_v$ 的趋势密切相关，可能导致分析过程振荡或无法收敛。尽管如此，Narrowing 在 Widening 的基础上能够逐步缩小区间，提高精度，从而在精度和收敛速度之间取得更好的平衡。</p><h2 id=其余参考资料 class=heading-element><span>其余参考资料</span>
<a href=#%e5%85%b6%e4%bd%99%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><div class="details admonition quote open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-quote-right" aria-hidden=true></i>参考</div><div class=details-content><div class=admonition-content><p><ul><li><a href=https://static-analysis.cuijiacai.com/01-intro/ target=_blank rel="external nofollow noopener noreferrer">静态分析概述</a></li><li><a href=https://static-analysis.cuijiacai.com/03-dfa-ap/ target=_blank rel="external nofollow noopener noreferrer">数据流分析-应用</a></li><li><a href=https://static-analysis.cuijiacai.com/04-dfa-fd/ target=_blank rel="external nofollow noopener noreferrer">数据流分析-基础</a></li><li><a href=https://blog-blockchain.xyz/pl/data-flow-analysis/ target=_blank rel="external nofollow noopener noreferrer">（二）数据流分析基础</a></li></ul></div></div></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2025-01-14 18:18:02">更新于 2025.1.14&nbsp;
<a class=git-hash href=https://github.com/czTangt/blog.git/commit/4115f0d52308f43862bec66d1417698452eedd5f rel="external nofollow noopener noreferrer" target=_blank title="commit by czTangt(cz.tangt@gmail.com) 4115f0d52308f43862bec66d1417698452eedd5f: add content of Widening"><i class="fa-solid fa-hashtag fa-fw" aria-hidden=true></i>4115f0d</a></span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href="https://github.com/czTangt/blog.git/blob/main/content/posts%5cstaticAnalysis%5cdata_flow_analysis.md?plain=1" title=查看源码 target=_blank rel="external nofollow noopener noreferrer" class=link-to-source>查看源码</a></span><span><a href=https://github.com/czTangt/blog.git/edit/main/content/posts%5cstaticAnalysis%5cdata_flow_analysis.md title=编辑此页 target=_blank rel="external nofollow noopener noreferrer" class=link-to-edit>编辑此页</a></span><span><a href="https://github.com/czTangt/blog.git/issues/new?title=[BUG]%2003+Data+Flow+Analysis&amp;body=%7cField%7cValue%7c%0A%7c-%7c-%7c%0A%7cTitle%7c03+Data+Flow+Analysis%7c%0A%7cURL%7chttps://czTangt.github.io/blog/posts/staticanalysis/data-flow-analysis/%7c%0A%7cFilename%7chttps://github.com/czTangt/blog.git/blob/main/content/posts%5cstaticAnalysis%5cdata_flow_analysis.md?plain=1%7c" title=报告问题 target=_blank rel="external nofollow noopener noreferrer" class=link-to-report>报告问题</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 X" data-sharer=twitter data-url=https://czTangt.github.io/blog/posts/staticanalysis/data-flow-analysis/ data-title="03 Data Flow Analysis" data-hashtags="Static Analysis"><i class="fa-brands fa-x-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://czTangt.github.io/blog/posts/staticanalysis/data-flow-analysis/ data-hashtag="Static Analysis"><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://czTangt.github.io/blog/posts/staticanalysis/data-flow-analysis/ data-title="03 Data Flow Analysis"><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/blog/tags/static-analysis/ class=post-tag title="标签 - Static Analysis">Static Analysis</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/blog/>主页</a></span></section></div><div class=post-nav><a href=/blog/posts/staticanalysis/control-flow-analysis/ class=post-nav-item rel=prev title="02 Control Flow Analysis"><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>02 Control Flow Analysis</a></div></div></article><aside class=toc id=toc-auto aria-label=目录><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside></main><footer class=footer><div class=footer-container><div class="footer-line powered order-1">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.136.5"><img class=hugo-icon src=/blog/images/hugo.min.svg alt="Hugo logo"> Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.3.17-30a67c4b"><img class=fixit-icon src=/blog/images/fixit.min.svg alt="FixIt logo"> FixIt</a></div><div class="footer-line copyright order-2" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2024 - 2025</span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class="variant-numeric d-none">0%</span></div></div><a href=https://github.com/czTangt/blog title="View source on GitHub" target=_blank rel="external nofollow" class="github-corner left d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true" width="56" height="56"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><noscript><div class=noscript-warning>该网站在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/blog/lib/lightgallery/css/lightgallery-bundle.min.css><link rel=preload href=/blog/lib/katex/katex.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/blog/lib/katex/katex.min.css></noscript><link rel=stylesheet href=/blog/lib/cookieconsent/cookieconsent.min.css><script src=/blog/lib/autocomplete/autocomplete.min.js defer></script><script src=/blog/lib/fuse/fuse.min.js defer></script><script src=/blog/lib/lightgallery/lightgallery.min.js defer></script><script src=/blog/lib/lightgallery/plugins/thumbnail/lg-thumbnail.min.js defer></script><script src=/blog/lib/lightgallery/plugins/zoom/lg-zoom.min.js defer></script><script src=/blog/lib/sharer/sharer.min.js async defer></script><script src=/blog/lib/katex/katex.min.js defer></script><script src=/blog/lib/katex/auto-render.min.js defer></script><script src=/blog/lib/katex/mhchem.min.js defer></script><script src=/blog/lib/cookieconsent/cookieconsent.min.js defer></script><script src=/blog/js/codeblock.js defer></script><script src=https://libs.baidu.com/jquery/2.1.4/jquery.min.js defer></script><script>window.config={code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:10},comment:{enable:!1},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},lightgallery:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{distance:100,findAllMatches:!1,fuseIndexURL:"/blog/search.json",highlightTag:"em",ignoreFieldNorm:!1,ignoreLocation:!1,isCaseSensitive:!1,location:0,maxResultLength:10,minMatchCharLength:2,noResultsFound:"没有找到结果",snippetLength:30,threshold:.3,type:"fuse",useExtendedSearch:!1},version:"v0.3.17-30a67c4b"}</script><script src=/blog/js/theme.min.js defer></script></body></html>