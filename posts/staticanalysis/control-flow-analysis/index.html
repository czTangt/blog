<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>02 Control Flow Analysis - czTang</title><meta name=author content="czTang"><meta name=description content="记录一下对于控制流分析的理解。
"><meta name=keywords content='Static Analysis'><meta itemprop=name content="02 Control Flow Analysis"><meta itemprop=description content="记录一下对于控制流分析的理解。"><meta itemprop=datePublished content="2024-12-22T10:33:32+08:00"><meta itemprop=dateModified content="2024-12-22T20:40:49+08:00"><meta itemprop=wordCount content="5181"><meta itemprop=keywords content="Static Analysis"><meta property="og:url" content="https://czTangt.github.io/blog/posts/staticanalysis/control-flow-analysis/"><meta property="og:site_name" content="czTang"><meta property="og:title" content="02 Control Flow Analysis"><meta property="og:description" content="记录一下对于控制流分析的理解。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-22T10:33:32+08:00"><meta property="article:modified_time" content="2024-12-22T20:40:49+08:00"><meta property="article:tag" content="Static Analysis"><meta name=twitter:card content="summary"><meta name=twitter:title content="02 Control Flow Analysis"><meta name=twitter:description content="记录一下对于控制流分析的理解。"><meta name=application-name content="FixIt"><meta name=apple-mobile-web-app-title content="FixIt"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel=icon href=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410312135963.svg><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical type=text/html href=https://czTangt.github.io/blog/posts/staticanalysis/control-flow-analysis/ title="02 Control Flow Analysis - czTang"><link rel=prev type=text/html href=https://czTangt.github.io/blog/posts/programming/java/ title="Some about Java"><link rel=next type=text/html href=https://czTangt.github.io/blog/posts/staticanalysis/data-flow-analysis/ title="03 Data Flow Analysis"><link rel=stylesheet href=/blog/css/config.min.css><link rel=stylesheet href=/blog/css/style.min.css><link rel=preload href=/blog/lib/fontawesome-free/all.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/blog/lib/fontawesome-free/all.min.css></noscript><link rel=preload href=/blog/lib/animate/animate.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/blog/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"02 Control Flow Analysis","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/czTangt.github.io\/blog\/posts\/staticanalysis\/control-flow-analysis\/"},"genre":"posts","keywords":"Static Analysis","wordcount":5181,"url":"https:\/\/czTangt.github.io\/blog\/posts\/staticanalysis\/control-flow-analysis\/","datePublished":"2024-12-22T10:33:32+08:00","dateModified":"2024-12-22T20:40:49+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"czTang"},"description":""}</script><script src=/blog/js/head/color-scheme.min.js></script></head><body data-header-desktop=sticky data-header-mobile=auto><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=left><div class=header-title><a href=/blog/ title=czTang><span class=header-title-pre><i class='fa fa-coffee'>&nbsp</i></span><span class=header-title-text>czTang</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/blog/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 归档</a></li><li class=menu-item><a class=menu-link href=/blog/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/blog/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/blog/about/><i class="fa-solid fa-user fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/blog/ title=czTang><span class=header-title-pre><i class='fa fa-coffee'>&nbsp</i></span><span class=header-title-text>czTang</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/blog/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 归档</a></li><li class=menu-item><a class=menu-link href=/blog/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/blog/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/blog/about/><i class="fa-solid fa-user fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=fi-container><aside class="aside-collection animate__animated animate__fadeIn animate__faster" aria-label=合集><div class="details collection-details open"><div class="details-summary collection-summary"><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i>
<span class=collection-name title=合集>Static Analysis</span>
<span class=collection-count>3</span><i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class="details-content collection-content"><nav><ul class=collection-list><li class=collection-item><a href=/blog/posts/staticanalysis/understanding/ title="01 Understanding Static Analysis">01 Understanding Static Analysis</a></li><li class=collection-item><span class=active title="02 Control Flow Analysis">02 Control Flow Analysis</span></li><li class=collection-item><a href=/blog/posts/staticanalysis/data-flow-analysis/ title="03 Data Flow Analysis">03 Data Flow Analysis</a></li></ul><div class=collection-nav-simple><a href=/blog/posts/staticanalysis/understanding/ class=collection-nav-item rel=prev title="01 Understanding Static Analysis"><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i></a><span class=text-secondary>2/3</span><a href=/blog/posts/staticanalysis/data-flow-analysis/ class=collection-nav-item rel=next title="03 Data Flow Analysis"><i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></nav></div></div></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>02 Control Flow Analysis</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/czTangt title=作者 target=_blank rel="external nofollow noopener noreferrer author" class=author><img class=avatar src=/blog/images/avatar.jpg alt=czTang height=16 width=16>&nbsp;czTang</a></span><span class=post-included-in>&nbsp;收录于 <a href=/blog/categories/static-analysis/ class=post-category title="分类 - Static Analysis"><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> Static Analysis</a> 和 <a href=/blog/collections/static-analysis/ class=post-collection title="合集 - Static Analysis"><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i> Static Analysis</a></span></div><div class=post-meta-line><span title="发布于 2024-12-22 10:33:32"><i class="fa-solid fa-calendar-days fa-fw me-1" aria-hidden=true></i><time datetime=2024.12.22>2024.12.22</time></span>&nbsp;<span title="更新于 2024-12-22 20:40:49"><i class="fa-regular fa-calendar-check fa-fw me-1" aria-hidden=true></i><time datetime=2024.12.22>2024.12.22</time></span>&nbsp;<span title="5181 字"><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 5200 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 11 分钟</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#控制流分析>控制流分析</a><ul><li><a href=#基本块>基本块</a></li><li><a href=#基本块的首领>基本块的首领</a></li><li><a href=#基本块的界定>基本块的界定</a></li><li><a href=#局部优化>局部优化</a></li></ul></li><li><a href=#基于-dag-的优化>基于 DAG 的优化</a><ul><li><a href=#公共子表达式消除>公共子表达式消除</a></li><li><a href=#死代码消除>死代码消除</a></li></ul></li><li><a href=#窥孔优化>窥孔优化</a><ul><li><a href=#消除冗余加载和存储指令>消除冗余加载和存储指令</a></li><li><a href=#控制流优化>控制流优化</a></li><li><a href=#消除级联跳转指令>消除级联跳转指令</a></li><li><a href=#代数化简和强度消减>代数化简和强度消减</a><ul><li><a href=#使用机器习语>使用机器习语</a></li></ul></li></ul></li><li><a href=#局部寄存器优化>局部寄存器优化</a><ul><li><a href=#spilling>Spilling</a></li></ul></li><li><a href=#其余参考资料>其余参考资料</a></li></ul></nav></div></div><div class=content id=content><p>记录一下对于控制流分析的理解。</p><div class="details admonition abstract open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-clipboard-list" aria-hidden=true></i>注意事项</div><div class=details-content><div class=admonition-content><p>下面的内容大部分来自于 <a href=https://www.cnblogs.com/zhouronghua/p/16220701.html target=_blank rel="external nofollow noopener noreferrer">程序分析与优化 - 2 控制流图</a>，它是对 <a href="https://www.youtube.com/playlist?list=PLC-dUCVQghfdu7AG5f_p4oRyKgjDuoAWU" target=_blank rel="external nofollow noopener noreferrer">《DCC888》</a> 课程中相关内容的总结。重点围绕 LLVM 中端优化器（Optimizer）的优化技术进行阐述与介绍。</p></div></div></div><h2 class=heading-element id=控制流分析><span>控制流分析</span>
<a href=#%e6%8e%a7%e5%88%b6%e6%b5%81%e5%88%86%e6%9e%90 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><div class="details admonition abstract open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-clipboard-list" aria-hidden=true></i>注意事项</div><div class=details-content><div class=admonition-content><p>以下内容主要参考了 <a href=https://static-analysis.cuijiacai.com/02-ir/#_2-2-%E6%8E%A7%E5%88%B6%E6%B5%81%E5%88%86%E6%9E%90 target=_blank rel="external nofollow noopener noreferrer">程序的中间表示</a> 的内容，主要说明控制流图的构建方法。</p></div></div></div><p><strong>控制流分析（Control Flow Analysis, CFA）</strong> 通常是指构建 <strong>控制流图（Control Flow Graph，CFG）</strong> 的过程。上篇文章使用 Soot 和 LLVM 得到了中间表示 IR，之后使用 IR 转化为了控制流图，而下图也是这样的过程，转化的方法就是划分基本块。</p><p><figure><a class=lightgallery href=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241222104429.png title=20241222104429 data-thumbnail=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241222104429.png data-sub-html="<h2>控制流图构建</h2><p>20241222104429</p>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241222104429.png alt=控制流图构建></a><figcaption class=image-caption>20241222104429</figcaption></figure></p><h3 class=heading-element id=基本块><span>基本块</span>
<a href=#%e5%9f%ba%e6%9c%ac%e5%9d%97 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>CFG 是静态分析的基础，而在上图可以看出，将 IR 按照相应规则划分为数个指令快，之后采用箭头显示控制就构成了 CFG。这里的指令块就被称为基本块。</p><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>基本块</div><div class=details-content><div class=admonition-content><p>记一个程序 <em>P</em> 在 <strong>IR 表示下</strong> 的指令序列为 $P = \{a_1, a_2, &mldr;, a_n\}$，这里 P 是一个有序集，那么</p><ul><li>$IN_i = \{a_j | next(a_j) = a_i\}$，其中 $next(a_j)$ 表示控制流中 $a_j$ 的下一条指令；</li><li>$OUT_i = \{a_j \mid prev(a_j) = a_i\}$，其中 $prev(a_j)$ 表示 $a_j$ 的上一条指令。</li></ul><p>如果连续的指令序列 $a_p, a_{p+1}, a_{p+2}, &mldr;, a_q$ 满足如下性质：
$$
\forall i \in [p+1, q], IN_i = {a_{i-1}} \land \forall i \in [p, q-1], OUT_i = {a_{i+1}}
$$
并且 $a_{p-1}, a_p, &mldr;, a_{q-1}, a_q$ 和 $a_p, a_{p+1}, &mldr;, a_q, a_{q+1}$ 都不满足上述性质，则称 $\{a_p, a_{p+1}, &mldr;, a_q\}$ 为 <strong>基本块（Basic Block）</strong>。</p></div></div></div><p>简单而言，基本块就是满足以下性质的最长指令序列：</p><ol><li>程序的控制流只能从首指令进入，不能存在跳转指令跳入执行基本块中的某行指令。</li><li>程序的控制流只能从尾指令流出，只有最后一条指令允许包含离开基本快的分支或者挂机指令。</li></ol><p>由上面的定义，可以知道跳转指令会将一个完成的程序切割为几个基本快，所以只需要将基本快的分割点找到，那么整个程序就可以按照分割点划分为数个基本块了。而这个分割点就是 <strong>基本块的首领（leader）</strong>。</p><h3 class=heading-element id=基本块的首领><span>基本块的首领</span>
<a href=#%e5%9f%ba%e6%9c%ac%e5%9d%97%e7%9a%84%e9%a6%96%e9%a2%86 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>基本块首领</div><div class=details-content><div class=admonition-content><p>对于 IR 表示下的程序 $P = \{a_1, a_2, &mldr;, a_n\}$，考虑某个基本块 $B = \{a_p, a_{p+1}, &mldr;, a_{q-1}, a_q\}$，称 $a_p$ 为 $P$ 的基本块 $B$ 的 <strong>首领（Leader）</strong>，而程序 $P$ 中所有的首领组成的集合为 $L$，则<br>$$
L = \{a_1\} \cup \{a_i \mid type(a_i) = jump \land target(a_i) \} \cup \{a_{i+1} \mid type(a_i) = jump\}
$$
其中，$type(a_i)$ 表示指令 $a_i$ 的类型，$jump$ 类型是跳转指令，包括 <strong>条件跳转（Conditional Jump）</strong> 和 <strong>无条件跳转（Unconditional Jump）</strong>。 $target(a_i)$ 仅用于 $a_i$ 是跳转指令的时候，表示 $a_i$ 的目标指令。</p></div></div></div><p>简单而言，首领就是每个基本块的首指令，其可以分为三种类型：</p><ol><li>整个程序的首指令。</li><li>跳转指令（包括条件跳转和无条件跳转）的目标指令。</li><li>紧邻跳转指令（包括条件跳转和无条件跳转）的下一条指令。</li></ol><h3 class=heading-element id=基本块的界定><span>基本块的界定</span>
<a href=#%e5%9f%ba%e6%9c%ac%e5%9d%97%e7%9a%84%e7%95%8c%e5%ae%9a class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>基本块的界定</div><div class=details-content><div class=admonition-content><p>对于程序 $P = \{a_1, a_2, &mldr;, a_n\}$ 而言，其所有的首领构成的集合为 $L$，则
$$
a_p \in L \land a_{q+1} \in L \land \forall a_i (i \in [p+1, q]), a_i \notin L \iff \{a_p, a_{p+1}, &mldr;, a_{q-1}, a_q\}
$$
得到的指令序列就是一个基本块。</p></div></div></div><p>简单而言，基本块的首领就是基本块之间的分割线，从一个基本块的首领到紧接着的下一个基本块的首领之前的所有指令组成了一个基本块。</p><h3 class=heading-element id=局部优化><span>局部优化</span>
<a href=#%e5%b1%80%e9%83%a8%e4%bc%98%e5%8c%96 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>在 Basic Block 作用域内部的优化被称为 <strong>局部优化（Local Optimization）</strong>，也就是将优化限制在单个基本块的上下文中，例如 <strong>基于 DAG 的优化（DAG based optimizations）</strong>、<strong>窥孔优化（Peephole optimizations）</strong>、<strong>局部寄存器分配（Local register allocation）</strong>。而基于整个程序的控制流图进行的优化被称为 <strong>全局优化（Global Optimization）</strong>，静态分析的优化大部分为全局优化，这里就对局部优化进行介绍。</p><h2 class=heading-element id=基于-dag-的优化><span>基于 DAG 的优化</span>
<a href=#%e5%9f%ba%e4%ba%8e-dag-%e7%9a%84%e4%bc%98%e5%8c%96 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>代码优化技术是需要直接分析一整个程序的 CFG，所以一般不怎么使用 DAG 的方式来进行数据结构的优化。但是下面介绍的两种优化方法不仅仅只是使用在 DAG 优化中，而在静态分析中也有很大的作用，所以这里只对优化方式进行简单介绍。这里 <a href=https://zh.wikipedia.org/wiki/%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE target=_blank rel="external nofollow noopener noreferrer">DAG</a> 就是指 <strong>有向无环图（Directed Acyclic Graph）</strong>，在图论中，如果一个有向图从任意顶点触发无法经过若干条边回到该点，则这个图是一个有向无环图，DAG 如下图所示：<figure><a class=lightgallery href=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241222151645.png title=20241222151645 data-thumbnail=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241222151645.png data-sub-html="<h2>有向无环图</h2><p>20241222151645</p>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241222151645.png alt=有向无环图></a><figcaption class=image-caption>20241222151645</figcaption></figure></p><p>而对于上述程序而言，DAG 的构造涉及程序指令的含义：</p><ol><li>每个输入值对应 DAG 中的一个结点，例如 <code>a = b + c</code>，这里的 b，c 就是输入值，需要作为结点出现。</li><li>基本块中的每行指令生成一个结点，例如 <code>a = b + c</code>，会产生 <code>+,a</code> 这样的结点。</li><li>如果指令 $S$ 用到了指令 $S_1, \ldots ,S_n$ 中的变量，则需要一条从 $S_1，i \in \{1, \ldots, n\}$ 到 $S$ 的边。</li><li>基本块中定义但未在基本块中使用的变量称为输出值，这些值可能会被后续基本块使用，因此为输出值。</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=n>b</span> <span class=o>+</span> <span class=n>c</span>
</span></span><span class=line><span class=cl><span class=n>b</span> <span class=o>=</span> <span class=n>a</span> <span class=o>-</span> <span class=n>d</span>
</span></span><span class=line><span class=cl><span class=n>c</span> <span class=o>=</span> <span class=n>b</span> <span class=o>+</span> <span class=n>c</span>
</span></span><span class=line><span class=cl><span class=n>d</span> <span class=o>=</span> <span class=n>a</span> <span class=o>-</span> <span class=n>d</span></span></span></code></pre></td></tr></table></div></div><p>对于上面的基本快指令，会生成下面的 DAG：<figure><a class=lightgallery href=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241222152350.png title=20241222152350 data-thumbnail=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241222152350.png data-sub-html="<h2>程序的 DAG</h2><p>20241222152350</p>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241222152350.png alt="程序的 DAG"></a><figcaption class=image-caption>20241222152350</figcaption></figure></p><h3 class=heading-element id=公共子表达式消除><span>公共子表达式消除</span>
<a href=#%e5%85%ac%e5%85%b1%e5%ad%90%e8%a1%a8%e8%be%be%e5%bc%8f%e6%b6%88%e9%99%a4 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>对于上述程序，可以直观看到 <code>a - d</code> 被利用了两次，并且其返回的结果不变，因此可以将其视为公共子表达式，从而进行 <strong>公共子表达式消除（Common subexpression elimination）</strong>。它们的值相同，那么其赋值对象 b 和 d 就是别名关系，于是可以直接使用上面计算的结果 b 直接赋值给 d，不必再进行表达式的计算。而 <code>b + c</code> 就不可以再次利用，因为两个表达式之间存在 <code>b = a - d</code>，它对表达式的其中一个变量进行了重新赋值，因此不是相同表达式。</p><p>在实际应用过程中，采用 <strong>值标记</strong> 方法来计算相同子表达式：</p><ul><li>对于 DAG 的每个结点关联一个 <strong>签名（$lb, v_1, \ldots, v_n$）</strong>，其中 $lb$ 是该结点的标签，$v_i(1 \leq i \leq n)$ 是该节点的所有子结点。<ul><li>将签名中的子结点序列作为 hash 函数的 key；</li><li>hash 函数的值就是该变量的值标记</li></ul></li><li>当有新的结点加入 DAG 时，先根据它的所有子结点计算出一个 hash 值，<ul><li>如果已经存在，直接返回该 hash 值对应的索引；</li><li>如果找不到，则创建该结点。</li></ul></li></ul><p>根据上面的方法，生成的值标记的 hash 表如下，可以看出最后一列显然是不必要的：</p><table><thead><tr><th>表达式</th><th>b</th><th>c</th><th>d</th><th>a = b + c</th><th>b = a - d</th><th>c = b + c</th><th><del>d = a - d</del></th></tr></thead><tbody><tr><td>hash key</td><td>b</td><td>c</td><td>d</td><td>(+,1, 2)</td><td>(-,4,3)</td><td>(+,5, 2)</td><td><del>(-,4,3)</del></td></tr><tr><td>value number</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td><del>5</del></td></tr></tbody></table><p>总的而言，上述方法就是在构建 DAG 的每一条语句的结点时，如果语句之前未出现过，则构建新的结点，如果是出现过相同 hash 的结点，则直接将新的结点指向之前那个相同hash 的结点。因此就可以把下图中的 <code>-,d</code> 结点直接删除，然后标识 <code>d</code> 变量的数据就和 <code>-,b</code> 结点的数据一样。<figure><a class=lightgallery href=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241222161800.png title=20241222161800 data-thumbnail=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241222161800.png data-sub-html="<h2>公共子表达式消除</h2><p>20241222161800</p>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241222161800.png alt=公共子表达式消除></a><figcaption class=image-caption>20241222161800</figcaption></figure></p><p>为了找到更多的 CSE（Common SubExpressions），需要指定更多的定理：</p><ul><li>交换律：对 $+$ 运算符，$x + y$ 和 $y + x$ 等同。</li><li>特性转换：$x&lt;y$ 一般转换成 $t = x - y; \ t &lt; 0$。</li><li>结合律: 对 $a = b + c;$，$t = c + d;$，$e = t + b;$ 等同于 $a = b + c;$，$e = a + d;$。</li><li>算术特性转换：$x + 0 = 0 + x = x;$，$x * 1 = 1 * x = x;$，$x - 0 = x;$，$x / 1 = x;$。</li><li>计算强度降维转换：$x^2 = x * x;$，$2 * x = x + x;$，$x / 2 = x * 0.5$。</li><li>常量折叠：在编译阶段计算表达式的值，并将表达式替换成对应的值。这个也是后面数据流分析中主要介绍的方法。</li></ul><h3 class=heading-element id=死代码消除><span>死代码消除</span>
<a href=#%e6%ad%bb%e4%bb%a3%e7%a0%81%e6%b6%88%e9%99%a4 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p><strong>死代码（Dead Code）</strong> 是指程序中不可达的代码，即不会被执行的代码，或者是执行结果永远不会被其他计算过程用到的代码。对于 DAG 而言，满足下面两个消除条件就可以将相应代码进行删除：</p><ol><li>结点没有后继结点，即没有父结点，例如 root node。</li><li>该结点不是输出结点。</li></ol><p>那么由上面的条件，如果下图中的 <code>-,d</code> 不是输出值，那么就可以进行删除。同时该清除过程也是多轮迭代，直至不动点才停止的。如果下面 <code>+,c</code> 不是输出值，那么它也会被删除，然后在后面的迭代中，会发现 <code>-,b</code> 也满足清除条件。它也会被清除，再次迭代后发现和上次没有变化，视为达到了不动点，迭代停止，获得了死代码清除的结果。<figure><a class=lightgallery href=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241222163054.png title=20241222163054 data-thumbnail=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241222163054.png data-sub-html="<h2>死代码消除</h2><p>20241222163054</p>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241222163054.png alt=死代码消除></a><figcaption class=image-caption>20241222163054</figcaption></figure></p><h2 class=heading-element id=窥孔优化><span>窥孔优化</span>
<a href=#%e7%aa%a5%e5%ad%94%e4%bc%98%e5%8c%96 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>窥孔是指程序中存在的一个小的滑动窗口，<strong>窥孔优化（Peephole Optimization）</strong> 是指优化器在分析指令序列时，每次只检查一个固定大小的滑动窗口内的指令。随着窗口不断滑动，如果发现符合某种优化模式的指令序列，则执行优化。常见的优化模式包括冗余指令消除、控制流优化、代数简化、以及机器特定指令的替换等。</p><h3 class=heading-element id=消除冗余加载和存储指令><span>消除冗余加载和存储指令</span>
<a href=#%e6%b6%88%e9%99%a4%e5%86%97%e4%bd%99%e5%8a%a0%e8%bd%bd%e5%92%8c%e5%ad%98%e5%82%a8%e6%8c%87%e4%bb%a4 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>load R0, m
</span></span><span class=line><span class=cl>store m, R0</span></span></code></pre></td></tr></table></div></div><p>在同一个基本块中，如果上述加载和存储指令相连且没有对值进行任何修改，则可以直接删除整个指令序列，因为它们对程序状态没有实际影响，从而避免无意义的操作，提升执行效率。</p><h3 class=heading-element id=控制流优化><span>控制流优化</span>
<a href=#%e6%8e%a7%e5%88%b6%e6%b5%81%e4%bc%98%e5%8c%96 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl># original
</span></span><span class=line><span class=cl>goto L1
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>L1: goto L2
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># optimized
</span></span><span class=line><span class=cl>goto L2
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>L1: goto L2
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># faulty optimization
</span></span><span class=line><span class=cl>goto L2
</span></span><span class=line><span class=cl>...</span></span></code></pre></td></tr></table></div></div><p>在上述的情况中，L1 只存在一条跳转语句，所以开始的跳转语句可以直接跳转到最终的标签语句处。而后面直接将 L1 标签语句删除的做法不被窥孔优化支持，因为窥孔只能看一个滑动窗口内的指令，它不能保证是否其他地方会使用这个 L1 标签，所以它不会被优化删除。</p><h3 class=heading-element id=消除级联跳转指令><span>消除级联跳转指令</span>
<a href=#%e6%b6%88%e9%99%a4%e7%ba%a7%e8%81%94%e8%b7%b3%e8%bd%ac%e6%8c%87%e4%bb%a4 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl># original
</span></span><span class=line><span class=cl>if debug == 1 goto L1
</span></span><span class=line><span class=cl>goto L2
</span></span><span class=line><span class=cl>L1: ...       goto end
</span></span><span class=line><span class=cl>L2: ...
</span></span><span class=line><span class=cl>end: ...
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># optimized
</span></span><span class=line><span class=cl>if debug != 1 goto L2
</span></span><span class=line><span class=cl>L1: ...       goto end
</span></span><span class=line><span class=cl>L2: ...
</span></span><span class=line><span class=cl>end: ...</span></span></code></pre></td></tr></table></div></div><p>对于上述不在同一个基本块的情况，也可以应用窥孔优化。从代码中可以看出，if 语句后对 L1 和 L2 添加了跳转语句，但实际上可以将满足 if 条件时执行的语句直接放在 if 语句之后，无需额外的跳转，从而简化控制流逻辑。</p><h3 class=heading-element id=代数化简和强度消减><span>代数化简和强度消减</span>
<a href=#%e4%bb%a3%e6%95%b0%e5%8c%96%e7%ae%80%e5%92%8c%e5%bc%ba%e5%ba%a6%e6%b6%88%e5%87%8f class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>代数恒等式可以简化 DAG，同时也可以被窥孔优化器用来消除一些语句。如下就将一些冗余的操作直接优化为简洁的表达。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>x = x + 0;
</span></span><span class=line><span class=cl>x = x + 1;</span></span></code></pre></td></tr></table></div></div><p>同时窥孔优化支持强度消减，也就是把代价较高的运算替换为目标机器上代价较小的等价运算。例如，将除数为常数的浮点除法替换为常量为倒数的乘法，将幂函数替换为移位运算符。运算强度排序为：除法 > 乘法 > 减法 > 移位/加法。</p><h4 class=heading-element id=使用机器习语><span>使用机器习语</span>
<a href=#%e4%bd%bf%e7%94%a8%e6%9c%ba%e5%99%a8%e4%b9%a0%e8%af%ad class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>许多计算机体系结构中，都有一些常见操作的有效指令，使用机器特有的指令可以显著减少运行时间。例如自增或自减指令。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-nasm data-lang=nasm><span class=line><span class=cl><span class=nf>add1</span> <span class=kc>$</span><span class=mi>1</span><span class=p>,</span> <span class=o>%</span><span class=nb>edi</span>
</span></span><span class=line><span class=cl><span class=c1>;加 1 的操作可以替换为下面的自增指令</span>
</span></span><span class=line><span class=cl><span class=nf>inc1</span> <span class=o>%</span><span class=nb>edi</span></span></span></code></pre></td></tr></table></div></div><h2 class=heading-element id=局部寄存器优化><span>局部寄存器优化</span>
<a href=#%e5%b1%80%e9%83%a8%e5%af%84%e5%ad%98%e5%99%a8%e4%bc%98%e5%8c%96 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>寄存器是处理器中存取速度最快的存储单元，但数量有限，例如在 32 位 x86 架构中，只有 8 个可用寄存器。由于寄存器运算的速度远快于内存操作，现代处理器的运行速度通常比内存快一个数量级以上，因此，将程序中使用最频繁的变量直接映射到寄存器中，可以显著提升性能。但是这种优化方式通常需要编译器对整个函数或程序进行全局分析，才能实现高效的寄存器分配。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>allocate</span><span class=p>(</span><span class=n>Block</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>Inst</span> <span class=nl>i</span> <span class=p>:</span> <span class=n>b</span><span class=p>.</span><span class=nf>instructions</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>Operand</span> <span class=nl>o</span> <span class=p>:</span> <span class=n>i</span><span class=p>.</span><span class=nf>operands</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>o</span> <span class=n>is</span> <span class=n>in</span> <span class=n>memory</span> <span class=n>m</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>r</span> <span class=o>=</span> <span class=nf>find_reg</span><span class=p>(</span><span class=n>i</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>                <span class=n>assign</span> <span class=n>r</span> <span class=n>to</span> <span class=n>o</span> 
</span></span><span class=line><span class=cl>                <span class=n>add</span> <span class=s>&#34;r = load m&#34;</span> <span class=n>before</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>Operand</span> <span class=nl>o</span> <span class=p>:</span> <span class=n>i</span><span class=p>.</span><span class=nf>operands</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=n>is</span> <span class=n>the</span> <span class=n>last</span> <span class=n>use</span> <span class=n>of</span> <span class=n>o</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=n>the</span> <span class=k>register</span> <span class=n>bound</span> <span class=n>to</span> <span class=n>o</span> <span class=n>to</span> <span class=n>the</span> <span class=n>list</span> <span class=n>of</span> <span class=n>free</span> <span class=n>registers</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>v</span> <span class=o>=</span> <span class=n>i</span><span class=p>.</span><span class=n>definition</span> 
</span></span><span class=line><span class=cl>        <span class=n>r</span> <span class=o>=</span> <span class=nf>find_reg</span><span class=p>(</span><span class=n>i</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>        <span class=n>assign</span> <span class=n>r</span> <span class=n>to</span> <span class=n>v</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>上述就是一个进行局部寄存器分配优化的伪代码，其主要目的是通过将变量映射到寄存器来提高程序的执行效率。它首先由 <code>if (o is in memory m)</code> 语句判断当前指令是否需要从内存中加载数据，如果是，那么就执行 <code>find_reg(i)</code> 来查找寄存器 r，用来存储当前操作数 o。这个函数会根据当前指令和上下文来选择一个适合的寄存器。之后在当前指令 i 前插入一条 <code>r = load m</code> 的指令，用于将内存中的数据加载到寄存器 r 中。</p><p>而后面的循环则是通过 <code>if (i is the last use of o)</code> 判断当前操作数 o 是否是其最后一次使用。如果是，那么当前寄存器分配的寄存器 r 可以释放，即将寄存器 r 归还给空闲寄存器列表，表明该寄存器可以重新使用。</p><p>最后的语句则是使用 <code>find_reg(i)</code> 来查找寄存器，从而将寄存器 r 分配给当前指令定义的值 v，使得该值的结果存储在寄存器中。</p><h3 class=heading-element id=spilling><span>Spilling</span>
<a href=#spilling class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>find_reg</span><span class=p>(</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>there</span> <span class=n>is</span> <span class=n>free</span> <span class=k>register</span> <span class=n>r</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>r</span> 
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span> <span class=c1>// spilling
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>let</span> <span class=n>v</span> <span class=n>be</span> <span class=n>the</span> <span class=n>latest</span> <span class=n>variable</span> <span class=n>to</span> <span class=n>be</span> <span class=n>used</span> <span class=n>after</span> <span class=n>i</span><span class=p>,</span> <span class=n>that</span> <span class=n>is</span> <span class=n>in</span> <span class=n>a</span> <span class=k>register</span> 
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>v</span> <span class=n>does</span> <span class=n>not</span> <span class=n>have</span> <span class=n>a</span> <span class=n>memory</span> <span class=n>slot</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>let</span> <span class=n>m</span> <span class=n>be</span> <span class=n>a</span> <span class=n>fresh</span> <span class=n>memory</span> <span class=n>slot</span> 
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>let</span> <span class=n>m</span> <span class=n>be</span> <span class=n>the</span> <span class=n>memory</span> <span class=n>slot</span> <span class=n>assigned</span> <span class=n>to</span> <span class=n>v</span> 
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>add</span> <span class=s>&#34;store v m&#34;</span> <span class=n>right</span> <span class=n>after</span> <span class=n>the</span> <span class=n>definition</span> <span class=n>of</span> <span class=n>v</span> 
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>r</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>上图就是 <code>find_reg(i)</code> 函数的实现，可以看出它根据指令 i 的需求来选择一个合适的寄存器来存储变量或操作数。如果没有可用的寄存器，它会寻找最合适的寄存器或内存位置来存储数据，并返回一个寄存器或内存位置供指令使用。在这里包含一个操作 <strong>Spilling</strong>，它是一个变量映射到内存的过程。因为物理机器的寄存器的个数有限，所以当寄存器不够用时，就需要将之前保存在寄存器里面的内容映射会内存。</p><p>对于上述代码，首先检查是否存在空闲寄存器，若是存在就直接返回这个寄存器。否则就是执行 spilling 操作，进行寄存器的回收。这里的 v 是指当前指令 i 执行之后，存储在寄存器中且最晚会被使用的变量。对于这个寄存器的回收采用的就是 <strong>Belady&rsquo;s Algorithm</strong>，也就是 <strong>最远未来使用（LRU）</strong> 策略。</p><p>之后进行后续操作，回收寄存器的变量如果没有内存空间，那么就创建一个内存空间分配给回收寄存器后的变量 v。最后之后插入 <code>store v m</code> 指令，表示把变量 v 存储到了 m 的内存空间。这样，变量 v 的值就从寄存器中存回内存，确保它的值不会丢失，并且寄存器可以被其他变量使用。</p><p>上文提起 <strong>局部寄存器分配（Local Register Allocation）</strong> 通常需要编译器对整个函数或程序进行全局分析，才能实现高效的寄存器分配。这是因为在分配时，需要关注一个变量是否会在一个基本块之后使用，因为一个基本块不能包含一整个函数，所以寄存器的分配起码需要在函数范围上进行使用才能真正实现优化。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>a = load m0
</span></span><span class=line><span class=cl>b = load m1
</span></span><span class=line><span class=cl>c = a + b
</span></span><span class=line><span class=cl>d = 4 * c
</span></span><span class=line><span class=cl>e = b + 1
</span></span><span class=line><span class=cl>f = e + a
</span></span><span class=line><span class=cl>g = d / e
</span></span><span class=line><span class=cl>h = f - g
</span></span><span class=line><span class=cl>ret h</span></span></code></pre></td></tr></table></div></div><p>对于只有两个寄存器的机器，实现上述的指令运算的过程如下图所示：<figure><a class=lightgallery href=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241222200418.png title=20241222200418 data-thumbnail=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241222200418.png data-sub-html="<h2>寄存器分配示例</h2><p>20241222200418</p>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241222200418.png alt=寄存器分配示例></a><figcaption class=image-caption>20241222200418</figcaption></figure></p><h2 class=heading-element id=其余参考资料><span>其余参考资料</span>
<a href=#%e5%85%b6%e4%bd%99%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><div class="details admonition quote open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-quote-right" aria-hidden=true></i>参考</div><div class=details-content><div class=admonition-content><ul><li><a href=http://www.xiaohe7.com/Compiler/dcc888/lecture02/ target=_blank rel="external nofollow noopener noreferrer">Lecture02 Coutrol Flow Graphs</a></li><li><a href="https://www.bilibili.com/video/BV1n7411G737/?spm_id_from=333.1387.upload.video_card.click" target=_blank rel="external nofollow noopener noreferrer">Enflame编译优化培训(基于DCC888) 第二课</a></li></ul></div></div></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2024-12-22 20:40:49">更新于 2024.12.22&nbsp;<a class=git-hash href=https://github.com/czTangt/blog.git/commit/82046a1042e579a70ab736ef5c15a568d0f47a53 rel="external nofollow noopener noreferrer" target=_blank title="add new post of data flow analysis&#10&#10Commit: 82046a1042e579a70ab736ef5c15a568d0f47a53 [82046a1]&#10Author: czTangt&#10Date: 2024-12-22 20:40:49"><i class="fa-solid fa-hashtag fa-fw" aria-hidden=true></i>82046a1</a></span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href="https://github.com/czTangt/blog.git/blob/main/content/posts/staticAnalysis/control_flow_analysis.md?plain=1" title=查看源码 target=_blank rel="external nofollow noopener noreferrer" class=link-to-source>查看源码</a></span><span><a href=https://github.com/czTangt/blog.git/edit/main/content/posts/staticAnalysis/control_flow_analysis.md title=编辑此页 target=_blank rel="external nofollow noopener noreferrer" class=link-to-edit>编辑此页</a></span><span><a href="https://github.com/czTangt/blog.git/issues/new?title=[BUG]%2002+Control+Flow+Analysis&amp;body=%7cField%7cValue%7c%0A%7c-%7c-%7c%0A%7cTitle%7c02+Control+Flow+Analysis%7c%0A%7cURL%7chttps://czTangt.github.io/blog/posts/staticanalysis/control-flow-analysis/%7c%0A%7cFilename%7chttps://github.com/czTangt/blog.git/blob/main/content/posts/staticAnalysis/control_flow_analysis.md?plain=1%7c" title=报告问题 target=_blank rel="external nofollow noopener noreferrer" class=link-to-report>报告问题</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 X" data-sharer=twitter data-url=https://czTangt.github.io/blog/posts/staticanalysis/control-flow-analysis/ data-title="02 Control Flow Analysis" data-hashtags="Static Analysis"><i class="fa-brands fa-x-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://czTangt.github.io/blog/posts/staticanalysis/control-flow-analysis/ data-hashtag="Static Analysis"><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://czTangt.github.io/blog/posts/staticanalysis/control-flow-analysis/ data-title="02 Control Flow Analysis"><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/blog/tags/static-analysis/ class=post-tag title="标签 - Static Analysis">Static Analysis</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/blog/>主页</a></span></section></div><div class=post-nav><a href=/blog/posts/programming/java/ class=post-nav-item rel=prev title="Some About Java"><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>Some About Java</a><a href=/blog/posts/staticanalysis/data-flow-analysis/ class=post-nav-item rel=next title="03 Data Flow Analysis">03 Data Flow Analysis<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article><aside class=toc id=toc-auto aria-label=目录><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside></main><footer class=footer><div class=footer-container><div class="footer-line powered order-1">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.150.0"><img class=hugo-icon src=/blog/images/hugo.min.svg alt="Hugo logo"> Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.4.0-alpha.1"><img class=fixit-icon src=/blog/images/fixit.min.svg alt="FixIt logo"> FixIt</a></div><div class="footer-line copyright order-2" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2024 - 2025</span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class="variant-numeric d-none">0%</span></div></div><a href=https://github.com/czTangt/blog title="View source on GitHub" target=_blank rel="external nofollow" class="github-corner left d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true" width="56" height="56"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentColor" class="octo-body"/></svg></a><div id=mask></div><noscript><div class=noscript-warning>该网站在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/blog/lib/lightgallery/css/lightgallery-bundle.min.css><link rel=stylesheet href=/blog/lib/cookieconsent/cookieconsent.min.css><script src=/blog/lib/autocomplete/autocomplete.min.js defer></script><script src=/blog/lib/fuse/fuse.min.js defer></script><script src=/blog/lib/lightgallery/lightgallery.min.js defer></script><script src=/blog/lib/lightgallery/plugins/thumbnail/lg-thumbnail.min.js defer></script><script src=/blog/lib/lightgallery/plugins/zoom/lg-zoom.min.js defer></script><script src=/blog/lib/sharer/sharer.min.js async defer></script><script src=/blog/js/lib/mathjax.min.js async defer></script><script src=/blog/lib/cookieconsent/cookieconsent.min.js defer></script><script src=/blog/js/codeblock.js defer></script><script src=https://libs.baidu.com/jquery/2.1.4/jquery.min.js defer></script><script>window.config={code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:10},comment:{enable:!1},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},lightgallery:!0,search:{distance:100,findAllMatches:!1,fuseIndexURL:"/blog/search.json",highlightTag:"em",ignoreFieldNorm:!1,ignoreLocation:!1,isCaseSensitive:!1,location:0,maxResultLength:10,minMatchCharLength:2,noResultsFound:"没有找到结果",snippetLength:30,threshold:.3,type:"fuse",useExtendedSearch:!1},version:"v0.4.0-alpha.1"}</script><script src=/blog/js/theme.min.js defer></script></body></html>