<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>Compilers Course - czTang</title><meta name=author content="czTang">
<meta name=description content="记录一下对于南大软院编译原理课程的学习。
"><meta name=keywords content='Course,compile'><meta itemprop=name content="Compilers Course"><meta itemprop=description content="记录一下对于南大软院编译原理课程的学习。"><meta itemprop=datePublished content="2024-10-31T20:08:19+08:00"><meta itemprop=dateModified content="2025-04-15T00:18:37+08:00"><meta itemprop=wordCount content="13232"><meta itemprop=keywords content="Course,Compile"><meta property="og:url" content="https://czTangt.github.io/blog/posts/course/compilers-course/"><meta property="og:site_name" content="czTang"><meta property="og:title" content="Compilers Course"><meta property="og:description" content="记录一下对于南大软院编译原理课程的学习。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-31T20:08:19+08:00"><meta property="article:modified_time" content="2025-04-15T00:18:37+08:00"><meta property="article:tag" content="Course"><meta property="article:tag" content="Compile"><meta name=twitter:card content="summary"><meta name=twitter:title content="Compilers Course"><meta name=twitter:description content="记录一下对于南大软院编译原理课程的学习。"><meta name=application-name content="FixIt"><meta name=apple-mobile-web-app-title content="FixIt"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel=icon href=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410312135963.svg><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical type=text/html href=https://czTangt.github.io/blog/posts/course/compilers-course/ title="Compilers Course - czTang"><link rel=prev type=text/html href=https://czTangt.github.io/blog/posts/programming/python/ title="Some about Python"><link rel=next type=text/html href=https://czTangt.github.io/blog/posts/config/git/ title="Some about Git"><link rel=stylesheet href=/blog/css/style.min.css><link rel=preload href=/blog/lib/fontawesome-free/all.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/blog/lib/fontawesome-free/all.min.css></noscript><link rel=preload href=/blog/lib/animate/animate.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/blog/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Compilers Course","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/czTangt.github.io\/blog\/posts\/course\/compilers-course\/"},"genre":"posts","keywords":"Course, compile","wordcount":13232,"url":"https:\/\/czTangt.github.io\/blog\/posts\/course\/compilers-course\/","datePublished":"2024-10-31T20:08:19+08:00","dateModified":"2025-04-15T00:18:37+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"czTang"},"description":""}</script><script src=/blog/js/head/color-scheme.min.js></script></head><body data-header-desktop=sticky data-header-mobile=auto><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=left><div class=header-title><a href=/blog/ title=czTang><span class=header-title-pre><i class='fa fa-coffee'>&nbsp</i></span><span class=header-title-text>czTang</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/blog/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 归档</a></li><li class=menu-item><a class=menu-link href=/blog/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/blog/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/blog/about/><i class="fa-solid fa-user fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/blog/ title=czTang><span class=header-title-pre><i class='fa fa-coffee'>&nbsp</i></span><span class=header-title-text>czTang</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/blog/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 归档</a></li><li class=menu-item><a class=menu-link href=/blog/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/blog/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/blog/about/><i class="fa-solid fa-user fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=container><aside class="aside-collection animate__animated animate__fadeIn animate__faster" aria-label=合集><div class="details collection-details open"><div class="details-summary collection-summary"><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i>
<span class=collection-name title=合集>Course</span>
<span class=collection-count>2</span><i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class="details-content collection-content"><nav><ul class=collection-list><li class=collection-item><span class=active title="Compilers Course">Compilers Course</span></li><li class=collection-item><a href=/blog/posts/course/compilers-lab/ title="Compilers Lab">Compilers Lab</a></li></ul><div class=collection-nav-simple><i class="fa-solid fa-angle-left fa-fw collection-nav-item text-secondary" aria-hidden=true></i><span class=text-secondary>1/2</span><a href=/blog/posts/course/compilers-lab/ class=collection-nav-item rel=next title="Compilers Lab"><i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></nav></div></div></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>Compilers Course</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/czTangt title=作者 target=_blank rel="external nofollow noopener noreferrer author" class=author><img loading=lazy src=/blog/images/avatar.jpg alt=czTang data-title=czTang width=20 height=20 class=avatar style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'>&nbsp;czTang</a></span><span class=post-included-in>&nbsp;收录于 <a href=/blog/categories/course/ class=post-category title="分类 - Course"><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> Course</a> 和 <a href=/blog/collections/course/ class=post-collection title="合集 - Course"><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i> Course</a></span></div><div class=post-meta-line><span title="发布于 2024-10-31 20:08:19"><i class="fa-solid fa-calendar-days fa-fw me-1" aria-hidden=true></i><time datetime=2024.10.31>2024.10.31</time></span>&nbsp;<span title="更新于 2025-04-15 00:18:37"><i class="fa-regular fa-calendar-check fa-fw me-1" aria-hidden=true></i><time datetime=2025.4.15>2025.4.15</time></span>&nbsp;<span title="13232 字"><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 13300 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 27 分钟</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#lexer-re-automata>Lexer Re Automata</a><ul><li><a href=#正则表达式与自动机理论>正则表达式与自动机理论</a><ul><li><a href=#课程目标>课程目标</a></li><li><a href=#编程语言介绍>编程语言介绍</a></li></ul></li><li><a href=#re>RE</a><ul><li><a href=#语法>语法</a></li><li><a href=#语义>语义</a></li><li><a href=#符号>符号</a></li></ul></li><li><a href=#自动机>自动机</a><ul><li><a href=#nfa>NFA</a><ul><li><a href=#语法-1>语法</a></li><li><a href=#语义-1>语义</a></li></ul></li><li><a href=#dfa>DFA</a><ul><li><a href=#语法-2>语法</a></li><li><a href=#语义-2>语义</a></li></ul></li></ul></li><li><a href=#相互转换>相互转换</a><ul><li><a href=#re---nfa>RE -> NFA</a></li><li><a href=#nfa---dfa>NFA -> DFA</a><ul><li><a href=#原理>原理</a></li><li><a href=#形式化描述子集构造法>形式化描述子集构造法</a></li></ul></li><li><a href=#dfa最小化>DFA最小化</a><ul><li><a href=#方法>方法</a></li><li><a href=#注意>注意</a></li></ul></li><li><a href=#dfa---词法分析器>DFA -> 词法分析器</a></li></ul></li></ul></li><li><a href=#parser-cfg-ll-lr>Parser Cfg LL LR</a><ul><li><a href=#cfg>CFG</a><ul><li><a href=#语法-3>语法</a></li><li><a href=#语义-3>语义</a></li></ul></li><li><a href=#ll1-语法分析算法>LL(1) 语法分析算法</a><ul><li><a href=#自顶向下>自顶向下</a></li><li><a href=#递归下降>递归下降</a></li><li><a href=#基于预测分析表>基于预测分析表</a><ul><li><a href=#first-集合>FIRST 集合</a></li><li><a href=#follow-集合>FOLLOW 集合</a></li><li><a href=#构建预测分析表>构建预测分析表</a></li><li><a href=#综合例子>综合例子</a></li></ul></li><li><a href=#适用于-ll1-文法>适用于 LL(1) 文法</a></li></ul></li><li><a href=#adaptive-ll-语法分析算法>Adaptive LL(*) 语法分析算法</a></li><li><a href=#lr0-语法分析算法>LR(0) 语法分析算法</a><ul><li><a href=#语法分析树>语法分析树</a></li><li><a href=#推导与归约>推导与归约</a><ul><li><a href=#归约过程>归约过程</a></li><li><a href=#lr-分析表的构建>LR 分析表的构建</a><ul><li><a href=#状态>状态</a></li><li><a href=#句柄>句柄</a></li><li><a href=#增广文法>增广文法</a></li><li><a href=#状态机转换>状态机转换</a></li><li><a href=#构建分析表>构建分析表</a></li></ul></li></ul></li><li><a href=#文法定义>文法定义</a></li><li><a href=#其余>其余</a></li></ul></li></ul></li><li><a href=#semantics-symboltable-ag>Semantics SymbolTable Ag</a><ul><li><a href=#symbol-table>Symbol Table</a></li><li><a href=#语义分析>语义分析</a><ul><li><a href=#语法制导定义>语法制导定义</a><ul><li><a href=#s-属性定义>S 属性定义</a></li><li><a href=#l-属性定义>L 属性定义</a></li><li><a href=#例子>例子</a><ul><li><a href=#属性文法计算后缀表达式>属性文法计算后缀表达式</a></li><li><a href=#数组类型文法举例>数组类型文法举例</a></li><li><a href=#属性文法计算有符号二进制数>属性文法计算有符号二进制数</a></li></ul></li></ul></li><li><a href=#语法制导的翻译方案>语法制导的翻译方案</a></li></ul></li></ul></li><li><a href=#llvm-ir-control>LLVM IR Control</a><ul><li><a href=#llvm>LLVM</a><ul><li><a href=#介绍>介绍</a></li><li><a href=#ir>IR</a><ul><li><a href=#ir-生成>IR 生成</a></li><li><a href=#不同优化等级的控制流>不同优化等级的控制流</a></li></ul></li></ul></li><li><a href=#中间代码生成>中间代码生成</a><ul><li><a href=#表达式翻译>表达式翻译</a><ul><li><a href=#非布尔表达式翻译>非布尔表达式翻译</a></li><li><a href=#数组引用翻译>数组引用翻译</a></li></ul></li><li><a href=#控制流翻译easy>控制流翻译（easy）</a><ul><li><a href=#if-条件语句>if 条件语句</a></li><li><a href=#if-else-语句>if else 语句</a></li><li><a href=#while-循环语句>while 循环语句</a></li><li><a href=#break-语句>break 语句</a></li><li><a href=#短路求值>短路求值</a></li></ul></li><li><a href=#控制流翻译hard>控制流翻译（hard）</a><ul><li><a href=#if-语句>if 语句</a></li><li><a href=#if-else-语句-1>if else 语句</a></li><li><a href=#while-循环语句-1>while 循环语句</a></li><li><a href=#布尔表达式>布尔表达式</a></li></ul></li><li><a href=#backpatch>backpatch</a><ul><li><a href=#m-属性>M 属性</a></li><li><a href=#n-属性>N 属性</a></li></ul></li></ul></li></ul></li><li><a href=#codegen-riscv-isel-ra>Codegen Riscv Isel Ra</a><ul><li><a href=#riscv>riscv</a></li><li><a href=#代码转换>代码转换</a></li><li><a href=#指令选择>指令选择</a><ul><li><a href=#介绍-1>介绍</a></li><li><a href=#树匹配>树匹配</a></li></ul></li><li><a href=#寄存器分配>寄存器分配</a></li></ul></li></ul></nav></div></div><div class=content id=content><p>记录一下对于南大软院编译原理课程的学习。</p><h2 id=lexer-re-automata class=heading-element><span>Lexer Re Automata</span>
<a href=#lexer-re-automata class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><blockquote><p>这里记录词法分析，正则表达式，自动机的相关知识。</p></blockquote><h3 id=正则表达式与自动机理论 class=heading-element><span>正则表达式与自动机理论</span>
<a href=#%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f%e4%b8%8e%e8%87%aa%e5%8a%a8%e6%9c%ba%e7%90%86%e8%ae%ba class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><h4 id=课程目标 class=heading-element><span>课程目标</span>
<a href=#%e8%af%be%e7%a8%8b%e7%9b%ae%e6%a0%87 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>这里讲解怎么写一个自动化词法分析器生成器。根据前面的理论，我们使用 ANTLR4 来<strong>生成词法分析器</strong>，其实质上是我们使用 ANTLR4 利用正则表达式（regular expression -> RE）的规则来进行生成词法分析器。同时我们还学习了利用 java 来<strong>手写词法分析器</strong>，实质就是在使用 java 代码模拟状态转移图，它也就是自动机。那么我们来看 ANTLR4 原理，他就是把 <code>.g4</code> 文件转化为 <code>.java</code> 文件，也就是把正则表达式转化为了自动机，然后通过模拟自动机就可以得到词法分析器了。
因此我们的目标就是通过正则表达式来直接得到得到一个词法分析器。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410201955612.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410201955612.png?size=small" data-sub-html="<h2>compile</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410201955612.png alt=conversion srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410201955612.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410201955612.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410201955612.png?size=large 2x" data-title=compile style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>conversion</figcaption></figure></p><p>由上图，我们构建词法分析器就是把 RE 转化为 DFA（有穷状态自动机 Deterministic FInite Automata），然后再转化为词法分析器，但是这个过程往往是困难的，所以我们采用简略的方法，通过先转化为 NFA（不确定的又穷状态自动机Nondeteeministic Finite Automata），再转化为 DFA，再进行后续的操作。</p><h4 id=编程语言介绍 class=heading-element><span>编程语言介绍</span>
<a href=#%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80%e4%bb%8b%e7%bb%8d class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p><strong>语言是字符串构成的集合。</strong> 根据这句高度抽象的结论，我们会一层层进行解剖。</p><ul><li>字符<ul><li>字母表 $\Sigma$ 是一个有限的符号集合，符号没有意义，它的语义是后来自己赋予的。</li></ul></li><li>字符串<ul><li>字符表 $\Sigma$ 上的<strong>串(s)</strong> 是由 $\Sigma$ 中符号构成的一个<strong>有穷</strong>序列。</li><li>其中 $\epsilon$ 是空串，我们定义它为零，即 $|\epsilon| = 0$</li></ul></li><li>字符串之间存在运算<ul><li><strong>连接</strong>运算， $x = day, y = houce, xy = dayhouce, \epsilon s = s \epsilon = s$</li><li><strong>指数</strong>运算，$s^{0} \triangleq \epsilon$，$s^{i} \triangleq ss^{i-1}, i>0$，这里存在上标就是连接的意思</li></ul></li><li>语言<ul><li>语言是给定字母表 $\Sigma$ 上一个任意的<strong>可数</strong>的串集合。</li><li>$\empty$，这一个是空集，什么语言都没有；${ \epsilon }$，这个里面有一个语言，不过是个空串</li><li>举例：id：${a,b,c,d,a1}$；ws：${blank, tab, newline }$，if：${ if }$</li><li>我们知道语言是串的集合，正因为是集合，所以我们可以通过集合操作<strong>构造</strong>新的语言</li></ul></li></ul><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410202146130.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410202146130.png?size=small" data-sub-html="<h2>compile</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410202146130.png alt=rules srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410202146130.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410202146130.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410202146130.png?size=large 2x" data-title=compile style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>rules</figcaption></figure></p><h3 id=re class=heading-element><span>RE</span>
<a href=#re class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>每个正则表达式 r 对应一个正则语言 <strong>L(r)</strong>。正则表达式是<strong>语法</strong>（ID：<code>[a-zA-Z][a-zA-Z0-9]*</code>），正则语言是<strong>语义</strong>（<code>{a1,a2,ab,……}</code>）</p><h4 id=语法 class=heading-element><span>语法</span>
<a href=#%e8%af%ad%e6%b3%95 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>给定字母表，$\Sigma$ 上的正则表达式由且仅由以下规则定义：</p><ol><li>$\epsilon$ 是正则表达式</li><li>$\forall a \in \Sigma$，a 是正则表达式</li><li>如果 r 是正则表达式，则 (r) 是正则表达式</li><li>如果 r 与 s 是正则表达式，则 r | s，rs，r* 也是正则表达式</li><li>运算优先级：$() \succ * \succ 连接 \succ |$ ，例子：$(a) \mid ((b)^{*} (c)) \equiv a | b^{*} c$</li></ol><h4 id=语义 class=heading-element><span>语义</span>
<a href=#%e8%af%ad%e4%b9%89 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>正则表达式对应的正则语言 $L(r)$</p><ol><li>$L(\epsilon) = { \epsilon}$</li><li>$L(a) = a, \forall a \in \Sigma$</li><li>$L((r)) = L(r)$</li><li>$L(r|s)=L(r) \cup L(s)\quad L(rs)=L(r)L(s)\quad L(r^{*})=(L(r))^{*}$</li></ol><h4 id=符号 class=heading-element><span>符号</span>
<a href=#%e7%ac%a6%e5%8f%b7 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410202205123.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410202205123.png?size=small" data-sub-html="<h2>compile</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410202205123.png alt=symbol srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410202205123.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410202205123.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410202205123.png?size=large 2x" data-title=compile style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>symbol</figcaption></figure></p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410202206620.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410202206620.png?size=small" data-sub-html="<h2>compile</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410202206620.png alt=symbol srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410202206620.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410202206620.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410202206620.png?size=large 2x" data-title=compile style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>symbol</figcaption></figure></p><h3 id=自动机 class=heading-element><span>自动机</span>
<a href=#%e8%87%aa%e5%8a%a8%e6%9c%ba class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><h4 id=nfa class=heading-element><span>NFA</span>
<a href=#nfa class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><h5 id=语法-1 class=heading-element><span>语法</span>
<a href=#%e8%af%ad%e6%b3%95-1 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>非确定性有穷自动机 $\mathcal{A}$ 是一个五元组 $\mathcal{A} = (\Sigma, S, s_0, \delta, F)$</p><ol><li>字母表 $\Sigma (\epsilon \notin \Sigma)$</li><li>有穷的<strong>状态集合</strong> $S$</li><li><strong>唯一</strong>的初始状态 $s_0 \in S$，这里的唯一不是强求，因为可以转化为唯一形态，转化方法就是前面再添加ige初始状态，然后通过 ${\epsilon }$ 边转移到原始初始状态即可。</li><li><strong>状态转移函数</strong> $\delta$，$\delta: S \times (\Sigma \cup {\epsilon}) \rightarrow 2^S$</li><li>接受状态集合 $F \subseteq S$，下图的 3 就是接受状态</li></ol><ul><li>这里非确定一个就是指接受统一字符的状态转移不唯一，如下图的 0 号节点，它接受字符 a 可以跑到两个状态上去；另一个就是可能存在 ${ \epsilon }$ 边，在没有字符驱动的情况下自发的跑到另外一个状态。</li></ul><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410202223241.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410202223241.png?size=small" data-sub-html="<h2>compile</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410202223241.png alt="state transfer" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410202223241.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410202223241.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410202223241.png?size=large 2x" data-title=compile style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>state transfer</figcaption></figure></p><p>上面的状态转移图没有规定如果碰到其他的字符该怎么处理，所以下图就约定所有没有对应出边的字符默认指向 空状态 $\empty$，也就是 $(\Sigma \cup {\epsilon})$，它表示达到自身，也意味着一个死状态。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410202251440.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410202251440.png?size=small" data-sub-html="<h2>compile</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410202251440.png alt="state transfer" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410202251440.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410202251440.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410202251440.png?size=large 2x" data-title=compile style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>state transfer</figcaption></figure></p><h5 id=语义-1 class=heading-element><span>语义</span>
<a href=#%e8%af%ad%e4%b9%89-1 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>有穷自动机是一类及其简单的计算装置，它可以识别（接收/拒绝）$\Sigma$ 上的字符串</p><ul><li>接收<ul><li>（非确定性）有穷自动机 $\mathcal{A}$ 接受字符串 x，当且仅当存在一条从开始状态 $s_0$ 到<strong>某个</strong>接受状态 $f \in F$ 、标号为 x 的路径。</li><li>对于上面的状态转移图，只有 3 是接受状态，因此 $aabb \in L(\mathcal{a}), ababab \notin L(\mathcal{A})$</li><li>因此，$\mathcal{A}$ 定义了一种语言 $L(\mathcal{A})$：它能接受的所有字符串构成的集合。所以根据上方状态转移图，可以得到自动机语言：$L(\mathcal{A}) = L((a|b)^*abb)$
由上面的语义，我们可以得到自动机的两个基本问题</li></ul></li><li>Membership 问题：给定字符串 $x$，$x \in L(\mathcal{A})?$</li><li>$L(\mathcal{A})$ 究竟是什么？</li></ul><h4 id=dfa class=heading-element><span>DFA</span>
<a href=#dfa class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><h5 id=语法-2 class=heading-element><span>语法</span>
<a href=#%e8%af%ad%e6%b3%95-2 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>确定性有穷自动机 $\mathcal{A}$ 是一个五元组 $\mathcal{A} = (\Sigma, S, s_0, \delta, F)$</p><ol><li>字母表 $\Sigma (\epsilon \notin \Sigma)$</li><li>有穷的<strong>状态集合</strong> $S$</li><li><strong>唯一</strong>的初始状态 $s_0 \in S$，这个唯一是一定需要的</li><li><strong>状态转移函数</strong> $\delta$，$\delta: S \times \Sigma \rightarrow S$</li><li>接受状态集合 $F \subseteq S$，下图的 3 就是接受状态</li></ol><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410202317792.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410202317792.png?size=small" data-sub-html="<h2>compile</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410202317792.png alt="state transfer" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410202317792.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410202317792.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410202317792.png?size=large 2x" data-title=compile style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>state transfer</figcaption></figure></p><p>这里的约定就是：所有没有对应出边的字符串默认指向一个“<strong>死状态</strong>”</p><h5 id=语义-2 class=heading-element><span>语义</span>
<a href=#%e8%af%ad%e4%b9%89-2 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>上图的自动机语言还是 $L(\mathcal{A}) = L((a|b)^*abb)$，也就是上面的 NFA 和下面的 DFA 等价的。因此可以看出 NFA 适合去表达一个语言，容易得出语言是什么；而 DFA 则是因为状态的转移确定，适合写词法分析器。即 NFA 简介易于理解，便于描述语言 $L(\mathcal{A})$；DFA易于判断$x \in L(\mathcal{A})$，适合产生词法分析器。那么转换就是 $RE \Rightarrow NFA \Rightarrow DFA \Rightarrow$ 词法分析器。</p><h3 id=相互转换 class=heading-element><span>相互转换</span>
<a href=#%e7%9b%b8%e4%ba%92%e8%bd%ac%e6%8d%a2 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>这里就是根据下面这张图，使得正则表达式和自动机之间相互转换。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410201955612.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410201955612.png?size=small" data-sub-html="<h2>compile</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410201955612.png alt=conversion srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410201955612.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410201955612.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410201955612.png?size=large 2x" data-title=compile style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>conversion</figcaption></figure></p><h4 id=re---nfa class=heading-element><span>RE -> NFA</span>
<a href=#re---nfa class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>采用 Thompson 构造法，使得 $r \Rightarrow NFA$，要求 $L(N(r)) = L(r)$，即两个语言等价。这里就是对于正则表达式语法的每个规则来定义自动机，然后最后将这些自动机按规则进行组合就得到了 NFA。
$N(r)$ 的性质以及 Thompson 构造法复杂度分析</p><ol><li>$N(r)$ 的开始状态和接受状态均唯一</li><li>开始状态没有入边，接受状态没有出边</li><li>$N(r)$ 的状态数 $|S| &lt; 2 \times |r|$（$|r|: r$ 中运算符和运算分量的总和）</li><li>每个状态最多有两个 $\epsilon \text{-}$ 入边与两个 $\epsilon \text{-}$ 出边</li><li>$\forall a \in \Sigma$，每个状态最多有一个 $a \text{-}$ 入边与一个 $a\text{-}$ 出边
自动机构造如下：</li></ol><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410210950686.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410210950686.png?size=small" data-sub-html="<h2>compile</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410210950686.png alt=Thompson srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410210950686.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410210950686.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410210950686.png?size=large 2x" data-title=compile style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>Thompson</figcaption></figure></p><h4 id=nfa---dfa class=heading-element><span>NFA -> DFA</span>
<a href=#nfa---dfa class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><h5 id=原理 class=heading-element><span>原理</span>
<a href=#%e5%8e%9f%e7%90%86 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>采用子集构造法，也就是用 DFA 模拟 NFA。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410210952811.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410210952811.png?size=small" data-sub-html="<h2>compile</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410210952811.png alt=子集构造法 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410210952811.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410210952811.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410210952811.png?size=large 2x" data-title=compile style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>子集构造法</figcaption></figure></p><p>下面就是从 NFA 到 DFA 的构造对应表，有了这张表就有了自动机。之所以是子集构造法，是因为构造出来的 DFA 对应于 NFA 的一个状态子集。同时这里因为在 NFA 中 10 是接受状态，所以在 DFA 中，对应的 E 也是接收状态。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410210959201.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410210959201.png?size=small" data-sub-html="<h2>compile</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410210959201.png alt=构造对应表 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410210959201.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410210959201.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410210959201.png?size=large 2x" data-title=compile style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>构造对应表</figcaption></figure></p><h5 id=形式化描述子集构造法 class=heading-element><span>形式化描述子集构造法</span>
<a href=#%e5%bd%a2%e5%bc%8f%e5%8c%96%e6%8f%8f%e8%bf%b0%e5%ad%90%e9%9b%86%e6%9e%84%e9%80%a0%e6%b3%95 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>这里根据上图的转化，会得到两个重要的公式：</p><ul><li>$\epsilon$ 闭包：从状态 s 开始，只通过 $\epsilon \text{-}$ 转移可达的状态集合<ul><li>$\epsilon\text{-closure}(s)={t\in S_N|s\xrightarrow{\epsilon^*}t}$，这个公式的含义就是把 NFA 中的初始状态归结于 DFA 中的初始状态。上图中 NFA 的 ${0,1,2,4,7}$，它是初始状态，在 NFA 中，从 0 开始，通过 $\epsilon$ 边进行连接的状态在 DFA 中都是初始状态。之后进行扩展操作 $\epsilon \text{-closure(T)} = \bigcup_{s \in T}\epsilon \text{-closure(s)}$，这个就是把上面的初始状态都添加在一起，转化为了集合形式，即状态集合，它为下面的 move 公式提供操作变量。</li><li>$\text{move(T,a)} = \bigcup_{s\in T} \delta(s,a)$，这个公式就是根据集合的当前状态，然后根据转移函数 $\delta$，逐个查看集合中每个元素在<strong>同一个字符</strong>作用的目标元素是什么，最后将目标元素添加到新集合中，这个集合就是 DFA 中的下一个状态。
之后就可以形式化描述子集构造法：子集构造法($N \rightarrow D$) 的<strong>原理</strong>：
$$
\begin{array}{l}
N: (\Sigma_N, S_N, n_0, \delta_N, F_N) \\
D: (\Sigma_D, S_D, d_0, \delta_D, F_D) \\
\Sigma_{D} = \Sigma_{N} \\
S_{D} \subseteq 2^{S_{N}} \quad (\forall s_{D} \in S_{D} : s_{D} \subseteq S_{N})
\end{array}
$$</li></ul></li><li>初始状态：$d_{0} = \epsilon \text{-closure}(n_{0})$</li><li>状态转移：$\forall a \in \Sigma_{D} : \delta_{D}(s_{D}, a) = \epsilon\text{-closure}(\operatorname{move}(s_{D}, a))$</li><li>接受状态集：$F_{\mathcal{D}} = { s_{D} \in S_{\mathcal{D}} \mid \exists f \in F_N \colon f \in s_{D} }$
子集构造法的复杂度分析：（$|S_N=n|$，下面的符号就是算法分析中的分析符号）
$$\left|S_{D}\right| = \Theta\left(2^{n}\right) = O\left(2^{n}\right) \cap \Omega\left(2^{n}\right)$$
<strong>对于任何算法</strong>，最坏情况下，$|S_{D}| = \Omega\left(2^{n}\right)$。</li></ul><h4 id=dfa最小化 class=heading-element><span>DFA最小化</span>
<a href=#dfa%e6%9c%80%e5%b0%8f%e5%8c%96 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><h5 id=方法 class=heading-element><span>方法</span>
<a href=#%e6%96%b9%e6%b3%95 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>我们还是查看之前使用 NFA -> DFA 的转换图来看，下面的 DFA 就是使用子集构造法将 NFA 转化而来的，毫无疑问，与上面的图相比，它不是最小的，所以这里需要探究的就是如何将 DFA 转化为最小化的形式。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410211050216.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410211050216.png?size=small" data-sub-html="<h2>compile</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410211050216.png alt=conversion srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410211050216.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410211050216.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410211050216.png?size=large 2x" data-title=compile style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>conversion</figcaption></figure></p><p>这里<strong>DFA最小化算法</strong>基本思想：<strong>等价</strong>的状态可以合并。对于等价而言，如果存在某个能区分状态 s 与 t 的字符串，则称 s 与 t 是<strong>可区分的</strong>；否则，称 s 与 t 是<strong>等价的</strong>。这里的字符串 x 区分状态 s 与 t，就是指如果分别从 s 与 t 出发，沿着标号为 x 的路径到达的两个状态中只有一个是接受状态，则称<strong>区分</strong>了状态 s 与 t，也就是s 与 t 不等价。
所以状态等价就是说，对于两个状态而言，在<strong>任意同一个字符</strong>的驱动下从当前状态进行转换，转换后的状态也是等价的。它可以用下面的公式进行表示：
$$
\begin{array}{l}
s \sim t \iff \forall a \in \Sigma. \left( (s \xrightarrow{a} s&rsquo;) \land (t \xrightarrow{a} t&rsquo;) \implies (s&rsquo; \sim t&rsquo;) \right)\\
s \nsim t \iff \exists a \in \Sigma. \left( (s \xrightarrow{a} s&rsquo;) \land (t \xrightarrow{a} t&rsquo;) \land (s&rsquo; \nsim t&rsquo;) \right)
\end{array}
$$
基于该定义，不断<strong>合并</strong>等价的状态，直到无法合并为止。但是我们的定义是一个递归的，不知道一开始要从什么地方入手，同时我们又得到所有的接受状态并不是等价的。所以这里采取的办法就是划分，利用反例公式 $s \nsim t \Longleftrightarrow \exists a \in \Sigma. ( s \xrightarrow{a} s&rsquo; ) \land ( t \xrightarrow{a} t&rsquo; ) \land ( s&rsquo; \nsim t&rsquo; )$ 进行划分，而非合并。也就是首先根据接受状态与非接受状态必定不等价先划分为两类 $\Pi = {F, S \setminus F}$，然后在这个基础上根据上面的反例公式进行分裂，直至再也无法<strong>划分</strong>为止，这里就到达了<strong>不动点</strong>，之后就是将同一等价类里的状态<strong>合并</strong>。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410211200842.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410211200842.png?size=small" data-sub-html="<h2>compile</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410211200842.png alt=划分步骤 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410211200842.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410211200842.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410211200842.png?size=large 2x" data-title=compile style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>划分步骤</figcaption></figure></p><p>上面就是分裂的过程，在 $\Pi_0$ 到 $\Pi_1$ 的过程中，${A,B,C}$ 和 ${D}$ 在经过 b 进行传递的状态是不等价的，此时 D 转移到 E 上了，E 输出 $S \setminus F$，所以不等价。之后的操作也是这样挑选字符看转移后的状态处于哪一个集合中，如果不在本身的集合，那么就是不等价，需要进行分裂。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410211203861.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410211203861.png?size=small" data-sub-html="<h2>compile</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410211203861.png alt=合并 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410211203861.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410211203861.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410211203861.png?size=large 2x" data-title=compile style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>合并</figcaption></figure></p><p>上图就是最后的分裂之后再合并得到最小化 DFA 的转换。</p><h5 id=注意 class=heading-element><span>注意</span>
<a href=#%e6%b3%a8%e6%84%8f class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><ul><li>需要注意处理"<strong>死状态</strong>"，也就是指向 ${ \empty}$ 的一些没有画出来的边，在进行分裂时需要添加上，即${F, S \setminus F, { \empty }}$</li><li>刚刚的算法不适用于 NFA 最小化，NFA最小化问题是 PSPACE-complete 的，复杂度很高。</li></ul><h4 id=dfa---词法分析器 class=heading-element><span>DFA -> 词法分析器</span>
<a href=#dfa---%e8%af%8d%e6%b3%95%e5%88%86%e6%9e%90%e5%99%a8 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>这里对于词法分析器的构造，需要注意一下几个要求，然后按照之前使用 java 模拟的方法进行构造即可：</p><ul><li>需要满足<strong>最前优先匹配</strong>和<strong>最长优先匹配</strong>，与此同时，因为需要生成词法分析器的特定目的，所以要保留各个 NFA 的<strong>接受状态</strong>的信息，表明匹配的是什么正则表达式</li><li>需要<strong>消除</strong> &ldquo;死状态&rdquo;，避免词法分析器徒劳消耗输入流。如果加上死状态，那么词法分析器就有可能走这条路径，然后会进行一直匹配，最后匹配出的也是死状态，妨碍正确匹配。</li><li>进行模拟的过程如下图所示，和之前 java 模拟的过程一样。</li></ul><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410211302285.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410211302285.png?size=small" data-sub-html="<h2>compile</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410211302285.png alt=模拟过程 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410211302285.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410211302285.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410211302285.png?size=large 2x" data-title=compile style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>模拟过程</figcaption></figure></p><ul><li>最后需要注意初始划分需要考虑不同的<strong>词法单元</strong>。之前的划分按照接受状态和非接受状态进行划分，但是这里需要写词法分析器，所以最后的接收状态对应了不同的词法单元，所以也需要进一步划分为不同的集合。</li></ul><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410211304789.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410211304789.png?size=small" data-sub-html="<h2>compile</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410211304789.png alt=特定词法单元 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410211304789.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410211304789.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410211304789.png?size=large 2x" data-title=compile style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>特定词法单元</figcaption></figure></p><h2 id=parser-cfg-ll-lr class=heading-element><span>Parser Cfg LL LR</span>
<a href=#parser-cfg-ll-lr class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><blockquote><p>这里记录上下文无关文法、LL、LR 算法相关知识。</p></blockquote><h3 id=cfg class=heading-element><span>CFG</span>
<a href=#cfg class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><h4 id=语法-3 class=heading-element><span>语法</span>
<a href=#%e8%af%ad%e6%b3%95-3 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>Definition(Context-Free Grammar, 上下文无关文法)，上下文无关文法 G 是一个四元组 <code>G = (T, N, S, P)</code>：</p><ul><li>T 是 <strong>终结符号</strong>（Terminal）集合，对应于词法分析器产生的词法单元</li><li>N 是 <strong>非终结符号</strong>（Non-terminal）集合</li><li>S 是 <strong>开始</strong>（Start）符号（$S \in N $且唯一）</li><li>P 是 <strong>产生式</strong>（Production）集合</li></ul><p>$$
A \in N \rightarrow \alpha \in (T \cup N)^*
$$</p><p><strong>头部/左部</strong>（Head）A：<strong>单个</strong>非终结符</p><p><strong>体部/右部</strong>（Body）$\alpha$：终结符与非终结符构成的串，也可以是空串$\epsilon$</p><h4 id=语义-3 class=heading-element><span>语义</span>
<a href=#%e8%af%ad%e4%b9%89-3 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>上下文无关文法 G 定义了一个语言 L(G)。语言是串的集合，从文法得到串的过程就是<strong>推导</strong>（Derivation）。推导就是将某个产生式的左边<code>替换</code>成它的右边，每一步推导需要选择替换哪个非终结符号，以及使用哪个产生式。对于下面的推导式而言，E 就是非终结符，id 就是终结符，目的就是从左边推到为右边，得到只包含终结符的式子。
$$
E \rightarrow E + E \mid E * E \mid (E) \mid -E \mid \text{id}
$$</p><p>对于推导也存在区分，如果一直选择最左边的非终结符进行推导，就称为 Leftmost Derivation，如下所示：
$$
E \implies -E \implies -(E) \implies -(E + E) \implies \pmb{-(\text{id} + E)} \implies -(\text{id} + \text{id})
$$
如果一直选择最右边的非终结符进行推导，就称为 Rightmost Derivation，如下所示
$$
E \implies -E \implies -(E) \implies -(E + E) \implies \pmb{-(E + \text{id})} \implies -(\text{id} + \text{id})
$$</p><p>由上述推导规则可以得到相关简单表示：
$$
\begin{align}
E &\implies -E \text{ : 经过一步推导得出} \\
E &\xRightarrow{\text{+}} -(\text{id} + E) \text{ : 经过一步或多步推导得出} \\
E &\xRightarrow{\text{*}} -(\text{id} + E) \text{ : 经过零步或多步推导得出}
\end{align}
$$</p><p>在推导的过程中，除了最左边的 program 和最后边的 文法写的程序，中间产物都被称为句型（Sentential Form），即 如果 $S \xRightarrow{*} \alpha$，且 $\alpha \in (T \cup N)^*$，则称 $\alpha$ 是文法 G 的一个<strong>句型</strong>。而最右边的结果被称为句子（Sentence），即 如果 $S \xRightarrow{*} w$，且 $w \in T^*$，则称 $w$ 是文法 G 的一个<strong>句子</strong>。</p><p>那么此时就可以定义文法 G 生成的语言 L(G) 了，即 文法 G 的语言 L(G) 是它能推导出的<strong>所有句子</strong>构成的集合 $L(G) = { w \mid S \xRightarrow{*} w }$。</p><h3 id=ll1-语法分析算法 class=heading-element><span>LL(1) 语法分析算法</span>
<a href=#ll1-%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90%e7%ae%97%e6%b3%95 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>自顶向下的、递归下降的、基于预测分析表的、适用于 LL(1) 文法的 LL(1) 语法分析器。</p><h4 id=自顶向下 class=heading-element><span>自顶向下</span>
<a href=#%e8%87%aa%e9%a1%b6%e5%90%91%e4%b8%8b class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>这里指语法分析树从上往下进行构建，<strong>根节点</strong>是文法的起始符号 <code>S</code>，<strong>叶节点</strong>是词法单元流 <code>w$</code>，仅包含终结符号与特殊的文件结束符 <code>$(EOF)</code>，<strong>中间节点</strong>表示对某个非终结符应用某个产生式进行推导。那么这里的问题就是选择哪个非终结符，以及选择哪个产生式。这里对于 LL(1) 而言，第一个 L 就是表示从左向右读入词法单元；第二个 L 表示在推导的每一步，LL(1) 总是选择最左边的非终结符进行展开。即构建最左推导；1 表示只需向前看一个输入符号便可确定使用哪条产生式。</p><h4 id=递归下降 class=heading-element><span>递归下降</span>
<a href=#%e9%80%92%e5%bd%92%e4%b8%8b%e9%99%8d class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>这里指实现方式，就是为每个非终结符写一个递归函数，内部按需调用其它非终结符对应的递归函数，下降一层。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241115124335.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241115124335.png?size=small" data-sub-html="<h2>20241115124335</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241115124335.png alt=递归下降的典型实现框架 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241115124335.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241115124335.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241115124335.png?size=large 2x" data-title=20241115124335 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>递归下降的典型实现框架</figcaption></figure></p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241115125451.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241115125451.png?size=small" data-sub-html="<h2>20241115125451</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241115125451.png alt=递归下降过程 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241115125451.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241115125451.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241115125451.png?size=large 2x" data-title=20241115125451 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>递归下降过程</figcaption></figure></p><h4 id=基于预测分析表 class=heading-element><span>基于预测分析表</span>
<a href=#%e5%9f%ba%e4%ba%8e%e9%a2%84%e6%b5%8b%e5%88%86%e6%9e%90%e8%a1%a8 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>设计预测分析表就是源于上述递归下降过程的一个问题，在上图展开非终结符 S 的过程中，为什么前两次玄策了 $S \implies (S + F)$，而第三次选择了 $S \implies F$？这里就是因为它们面对的当前词法单元不同。由此根据不同的词法单元，形成了一张预测分析表，之后就可以使用预测分析表来确定产生式。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241115130059.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241115130059.png?size=small" data-sub-html="<h2>20241115130059</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241115130059.png alt=预测分析表 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241115130059.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241115130059.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241115130059.png?size=large 2x" data-title=20241115130059 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>预测分析表</figcaption></figure></p><p>这里指明了每个<strong>非终结符</strong>在面对不同的<strong>词法单元或文件结束符</strong>时，该选择哪个<strong>产生式</strong>（按编号进行索引）或者<strong>报错</strong>（空单元格）。下面就是递归下降、基于预测分析表的实现方法，这里根据预测分析表，从左往右逐个字符进行匹配。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241116153444.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241116153444.png?size=small" data-sub-html="<h2>20241116153444</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241116153444.png alt=实现方法 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241116153444.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241116153444.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241116153444.png?size=large 2x" data-title=20241116153444 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>实现方法</figcaption></figure></p><p>那么如何得到这个预测分析表呢，就需要先知道两个概念。</p><h5 id=first-集合 class=heading-element><span>FIRST 集合</span>
<a href=#first-%e9%9b%86%e5%90%88 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>$FIRST(\alpha)$ 是可从 $\alpha$ 推导得到的句型的<strong>首终结符号</strong>的集合。即对于任意的（产生式的右部）$\alpha \in (N \cup T)^*$：
$$
\text{FIRST}(\alpha) = \{ t \in T \cup \{ \epsilon \} \mid \alpha \overset{*}{\Rightarrow} \textcolor{red}{t} \beta \lor \alpha \overset{*}{\Rightarrow} \epsilon \}
$$
因此对于这个集合而言，考虑非终结符 $A$ 的所有产生式 $A \rightarrow \alpha_1, \quad A \rightarrow \alpha_2, \quad \ldots, \quad A \rightarrow \alpha_m$，如果它们对应的 $FIRST(\alpha)$ 集合互不相交，则只需查看当前输入词法单元，即可确定选择哪个产生式（或报错）。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241116162747.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241116162747.png?size=small" data-sub-html="<h2>20241116162747</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241116162747.png alt="符号 X 的 FIRST 集合计算" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241116162747.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241116162747.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241116162747.png?size=large 2x" data-title=20241116162747 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>符号 X 的 FIRST 集合计算</figcaption></figure></p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241116162828.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241116162828.png?size=small" data-sub-html="<h2>20241116162828</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241116162828.png alt="符号串 $X\beta$ 的 FIRST 集合计算" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241116162828.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241116162828.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241116162828.png?size=large 2x" data-title=20241116162828 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>符号串 $X\beta$ 的 FIRST 集合计算</figcaption></figure></p><p>具体可以看下面的例子：</p><ul><li>后面跟的为终结符</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>A-&gt;aB<span class=p>|</span>ε
</span></span><span class=line><span class=cl>A-&gt;c
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>First<span class=o>(</span>A<span class=o>)</span> <span class=o>=</span> <span class=o>{</span>a，ε，c<span class=o>}</span></span></span></code></pre></td></tr></table></div></div><ul><li>后面跟的为非终结符</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 情况一</span>
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>A-&gt;Ba
</span></span><span class=line><span class=cl>B-&gt;b
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>First<span class=o>(</span>A<span class=o>)</span> <span class=o>=</span> <span class=o>{</span>b<span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 情况二</span>
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>A-&gt;Bc
</span></span><span class=line><span class=cl>B-&gt;b<span class=p>|</span>ε
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>First<span class=o>(</span>A<span class=o>)</span> <span class=o>=</span> <span class=o>{</span>b, c<span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 情况三</span>
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>A-&gt;BC
</span></span><span class=line><span class=cl>B-&gt;b<span class=p>|</span>ε
</span></span><span class=line><span class=cl>C-&gt;c<span class=p>|</span>ε
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>First<span class=o>(</span>A<span class=o>)</span> <span class=o>=</span> <span class=o>{</span>b, c, ε<span class=o>}</span></span></span></code></pre></td></tr></table></div></div><h5 id=follow-集合 class=heading-element><span>FOLLOW 集合</span>
<a href=#follow-%e9%9b%86%e5%90%88 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>$FOLLOW(A)$ 是可能在某些句型中<strong>紧跟在 $A$ 右边的终结符</strong>的集合。即对于任意的（产生式的左部）非终结符$A \in N$：</p><p>$$
\text{FOLLOW}(A) = \{ t \in T \cup \{ \text{\$} \} \mid \exists s.\ S \overset{*}{\Rightarrow} s \triangleq \beta A \textcolor{red}{t} \gamma \}
$$</p><p>这里的 $\$$ 就是文法开始符，只在第一个字符的 $FOLLOW$ 集合中进行添加。考虑产生式 $A \rightarrow \alpha$，如果从 $\alpha$ 可能推导出空串（$\textcolor{red}{\alpha \overset{*}{\Rightarrow} \epsilon}$），则只有当当前词法单元 $t \in FOLLOW(A)$，才可以选择该产生式。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241117110404.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241117110404.png?size=small" data-sub-html="<h2>20241117110404</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241117110404.png alt="符号 X 的 FOLLOW 集合计算" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241117110404.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241117110404.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241117110404.png?size=large 2x" data-title=20241117110404 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>符号 X 的 FOLLOW 集合计算</figcaption></figure></p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241117110432.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241117110432.png?size=small" data-sub-html="<h2>20241117110432</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241117110432.png alt="符号串 $X\beta$ 的 FOLLOW 集合计算" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241117110432.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241117110432.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241117110432.png?size=large 2x" data-title=20241117110432 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>符号串 $X\beta$ 的 FOLLOW 集合计算</figcaption></figure></p><h5 id=构建预测分析表 class=heading-element><span>构建预测分析表</span>
<a href=#%e6%9e%84%e5%bb%ba%e9%a2%84%e6%b5%8b%e5%88%86%e6%9e%90%e8%a1%a8 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>根据上述对于 FIRST集合 和 FOLLOW集合 的描述，可以计算给定文法 G 的预测分析表：对应每条产生式 $A \rightarrow \alpha$ 与终结符 $\textcolor{blue}{t}$，如果
$$
t \in \text{FIRST}(\alpha) \\
\alpha^* \Rightarrow \epsilon \land t \in \text{FOLLOW}(A)
$$
则在表格 $[\textcolor{red}{A}, \textcolor{blue}{t}]$ 中填入 $A \rightarrow \alpha$（编号）。</p><h5 id=综合例子 class=heading-element><span>综合例子</span>
<a href=#%e7%bb%bc%e5%90%88%e4%be%8b%e5%ad%90 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>对于下面的例子，可以得到它们的 FIRST 和 FOLLOW 集合。
$$
X \rightarrow Y \\
X \rightarrow \alpha \\
Y \rightarrow \epsilon \\
Y \rightarrow c \\
Z \rightarrow d \\
Z \rightarrow XYZ
$$</p><table><thead><tr><th>FIRST集合</th><th>FOLLOW集合</th></tr></thead><tbody><tr><td>$FIRST(X) = \{a, c, \epsilon \}$</td><td></td></tr><tr><td>$FIRST(Y) = \{c, \epsilon \}$</td><td>$FOLLOW(X) = \{a, c, d, \$ \}$</td></tr><tr><td>$FITST(Z) = \{a, c, d \}$</td><td>$FOLLOW(Y) = \{a, c, d, \$ \}$</td></tr><tr><td>$FITST(XYZ) = \{a, c, d \}$</td><td>$FOLLOW(Z) = \empty$</td></tr><tr><td>$FITST(YZ) = \{a, c, d \}$</td><td></td></tr></tbody></table><p>关于 FIRST 和 FOLLOW 的更多讲解和例子可以看 <a href=https://blog.csdn.net/weixin_44445120/article/details/115681574 target=_blank rel="external nofollow noopener noreferrer">这篇文章</a>。之后根据上面信息，可以构建相应的预测分析表。也可以看 <a href="https://www.bilibili.com/video/BV1Cu411m7VX?spm_id_from=333.788.videopod.sections&amp;vd_source=17ac9da9453dbd6d64b9616668574c5f" target=_blank rel="external nofollow noopener noreferrer">这个视频</a> 来学习两个集合的构造方法。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241117121918.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241117121918.png?size=small" data-sub-html="<h2>20241117121918</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241117121918.png alt=预测分析表 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241117121918.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241117121918.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241117121918.png?size=large 2x" data-title=20241117121918 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>预测分析表</figcaption></figure></p><h4 id=适用于-ll1-文法 class=heading-element><span>适用于 LL(1) 文法</span>
<a href=#%e9%80%82%e7%94%a8%e4%ba%8e-ll1-%e6%96%87%e6%b3%95 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>这里主要说明它的局限性。对于上面预测分析表的构建，需要定义 LL(1) 文法，即如果文法 G 的预测分析表是<strong>无冲突</strong>的，则 G 是 LL(1)文法。无冲突就是每个单元格里只有一个产生式（编号）即<strong>仅根据当前 token 即可递推 production</strong>。那么根据这个无冲突的预测分析表，对于当前选择的非终结符，仅根据输入中当前的词法单元（LL(1)）即可确定需要使用哪条产生式。这里根据 LL(1) 文法的定义就可以看到其局限性，它需要的就是预测分析表是无冲突的，其他情况就不适用这个文法了。</p><h3 id=adaptive-ll-语法分析算法 class=heading-element><span>Adaptive LL(*) 语法分析算法</span>
<a href=#adaptive-ll-%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90%e7%ae%97%e6%b3%95 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>看 <a href="https://www.bilibili.com/video/BV1eA4m1w7tm/?spm_id_from=333.999.0.0&amp;vd_source=17ac9da9453dbd6d64b9616668574c5f" target=_blank rel="external nofollow noopener noreferrer">视频</a> 和 <a href=https://github.com/courses-at-nju-by-hfwei/compilers-papers-we-love/blob/master/parsing/ANTLR/PLDI2014%20Adaptive%20LL%28Star%29%20Parsing%20The%20Power%20of%20Dynamic%20Analysis%20%28ALLStar%29.pdf target=_blank rel="external nofollow noopener noreferrer">论文</a> 理解吧。</p><p>记录一下别人的 <a href=https://pfmiles.github.io/blog/concept-and-implementation-of-ll-star/ target=_blank rel="external nofollow noopener noreferrer">博客1</a>，<a href=https://ling-yuchen.github.io/2022/12/04/NJU-Compiler-Principle/#06-%E7%AC%A6%E5%8F%B7%E8%A1%A8 target=_blank rel="external nofollow noopener noreferrer">博客2</a>。第二篇是视频的笔记，虽然它只是截图保存🐶。</p><h3 id=lr0-语法分析算法 class=heading-element><span>LR(0) 语法分析算法</span>
<a href=#lr0-%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90%e7%ae%97%e6%b3%95 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209084935.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209084935.png?size=small" data-sub-html="<h2>20241209084935</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209084935.png alt=相关文法 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209084935.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209084935.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209084935.png?size=large 2x" data-title=20241209084935 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>相关文法</figcaption></figure></p><p>对于 LL(k) 而言，它的缺陷就是在<strong>仅看到右部的前 k 个词法单元</strong>时就必须预测要使用哪条产生式。那么相对应的，LR(k) 的优势就是看到某个产生式的<strong>整个右部</strong>对应的词法单元之后再做决定。</p><p>那么 LR 语法分析器的特点就是自底向上、不断归约、基于句柄识别自动机，适用于 LR 文法。</p><h4 id=语法分析树 class=heading-element><span>语法分析树</span>
<a href=#%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90%e6%a0%91 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>这里的语法分析树是自底向上进行构建的，<strong>根节点</strong>是文法的起始符号 S；每个<strong>中间非终结符节点</strong>表示使用它的某条产生式进行归约；<strong>叶节点</strong>是词法单元流 $w$$，它仅包含终结符号与特殊的文本结束符 $$$。</p><h4 id=推导与归约 class=heading-element><span>推导与归约</span>
<a href=#%e6%8e%a8%e5%af%bc%e4%b8%8e%e5%bd%92%e7%ba%a6 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>下图就是推导与归约的示例，我们首先进行自顶向下的最右推导，之后直接沿着反方向进行归约。因此这里的 LR 语法分析器中的 L 就是<strong>从左向右</strong>扫描输入；R 就是构建<strong>反向最右</strong>推导。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241207161648.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241207161648.png?size=small" data-sub-html="<h2>20241207161648</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241207161648.png alt=推导与归约1 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241207161648.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241207161648.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241207161648.png?size=large 2x" data-title=20241207161648 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>推导与归约1</figcaption></figure></p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241207161823.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241207161823.png?size=small" data-sub-html="<h2>20241207161823</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241207161823.png alt=推导与归约2 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241207161823.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241207161823.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241207161823.png?size=large 2x" data-title=20241207161823 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>推导与归约2</figcaption></figure></p><p>由上图可以看出，这里的最右推导就是指对于一个产生式，最先解析右侧的的非终结符，使其转化为终结符，然后再解析左侧的非终结符。因此反方向的归约从左到右进行识别，如果识别到产生式完整的右部，那么就转化为产生式的左部，这样持续进行，最终把终结符推导为最后的 E。</p><p>这里之所以采用最右推导是为了效率，若是最左推导，那么归约就是从右往左了。这样构造的话，非终结符必须全部输入完成才会进行解析，因为这里是从后往前。而采用最右推导，那么归约就是从前往后了，这样在读入输入的时候就可以进行归约构建，增强效率。</p><h5 id=归约过程 class=heading-element><span>归约过程</span>
<a href=#%e5%bd%92%e7%ba%a6%e8%bf%87%e7%a8%8b class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>归约如下图所示。上边缘就是需要进行归约的部分，剩余的输入就是还没有读入的部分，这里就是一遍读入一遍进行归约。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208160256.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208160256.png?size=small" data-sub-html="<h2>20241208160256</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208160256.png alt=归约概念 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208160256.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208160256.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208160256.png?size=large 2x" data-title=20241208160256 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>归约概念</figcaption></figure></p><p>下面就是归约的过程，通过栈结构将左侧的子树进行压栈，如果栈的栈顶部分满足产生式，可以推导出左半部分，那么就移除右半部分，将左半部分压栈。否则从左往右读入输入进行压栈。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208203532.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208203532.png?size=small" data-sub-html="<h2>20241208203532</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208203532.png alt=归约过程 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208203532.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208203532.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208203532.png?size=large 2x" data-title=20241208203532 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>归约过程</figcaption></figure></p><p>那么现在的问题就是对于这个栈结构，什么时候进行归约，又是按哪条产生式进行归约？例如上面：为什么第二个 F 以 T * F 整体被归约为 T？那么回答就是，这与栈的当前状态 “T * F” 相关。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208205131.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208205131.png?size=small" data-sub-html="<h2>20241208205131</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208205131.png alt="LR 分析表" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208205131.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208205131.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208205131.png?size=large 2x" data-title=20241208205131 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>LR 分析表</figcaption></figure></p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208205234.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208205234.png?size=small" data-sub-html="<h2>20241208205234</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208205234.png alt=分析表解析 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208205234.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208205234.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208205234.png?size=large 2x" data-title=20241208205234 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>分析表解析</figcaption></figure></p><p>这里需要注意，对于归约和 GOTO 语句而言，若是进行了归约，那么就存在着出栈的操作，此时对于 GOTO 语句的状态就不是当前的状态，而是上一次的状态，因为出栈引起了状态的变化。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208205501.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208205501.png?size=small" data-sub-html="<h2>20241208205501</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208205501.png alt=移入与归约 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208205501.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208205501.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208205501.png?size=large 2x" data-title=20241208205501 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>移入与归约</figcaption></figure></p><h5 id=lr-分析表的构建 class=heading-element><span>LR 分析表的构建</span>
<a href=#lr-%e5%88%86%e6%9e%90%e8%a1%a8%e7%9a%84%e6%9e%84%e5%bb%ba class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>这里展示了 LR(0) 句柄识别有穷状态自动机，我们之后要做的就是解释这个状态集怎么转化为分析表的。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208214009.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208214009.png?size=small" data-sub-html="<h2>20241208214009</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208214009.png alt=句柄识别有穷状态自动机 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208214009.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208214009.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208214009.png?size=large 2x" data-title=20241208214009 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>句柄识别有穷状态自动机</figcaption></figure></p><h6 id=状态 class=heading-element><span>状态</span>
<a href=#%e7%8a%b6%e6%80%81 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h6><p>首先我们需要知道状态是什么，对于这个分析表，状态是语法分析树的上边缘，存储在栈中。由此我们可以的到下面的结论。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208213456.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208213456.png?size=small" data-sub-html="<h2>20241208213456</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208213456.png alt=状态定义 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208213456.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208213456.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208213456.png?size=large 2x" data-title=20241208213456 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>状态定义</figcaption></figure></p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208213657.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208213657.png?size=small" data-sub-html="<h2>20241208213657</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208213657.png alt=项集和项集族 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208213657.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208213657.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208213657.png?size=large 2x" data-title=20241208213657 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>项集和项集族</figcaption></figure></p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208214205.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208214205.png?size=small" data-sub-html="<h2>20241208214205</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208214205.png alt=点的含义 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208214205.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208214205.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208214205.png?size=large 2x" data-title=20241208214205 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>点的含义</figcaption></figure>由上图，<code>·</code> 表示我们当前看的位置。一开始，栈为空，期望输入是 <code>E</code> 可以展开得到的一个句子并以 <code>$</code> 结束。输入以 <code>E</code> 开始，意味着它可能以 <code>E</code> 的任何一个右部开始。</p><h6 id=句柄 class=heading-element><span>句柄</span>
<a href=#%e5%8f%a5%e6%9f%84 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h6><p>根据下图我们可以知道句柄的概念，之后就需要知道句柄可能在哪里出现，有之前的操作我们可以看出，句柄在栈顶位置，所以这里就需要我们设计出一种满足“句柄总是出现在栈顶”性质的 LR 语法分析器。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208210929.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208210929.png?size=small" data-sub-html="<h2>20241208210929</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208210929.png alt=句柄概念 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208210929.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208210929.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208210929.png?size=large 2x" data-title=20241208210929 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>句柄概念</figcaption></figure></p><h6 id=增广文法 class=heading-element><span>增广文法</span>
<a href=#%e5%a2%9e%e5%b9%bf%e6%96%87%e6%b3%95 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h6><p>这里我们需要进行的就是添加一个文法帮助我们进行转换。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208214717.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208214717.png?size=small" data-sub-html="<h2>20241208214717</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208214717.png alt=增广文法 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208214717.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208214717.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208214717.png?size=large 2x" data-title=20241208214717 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>增广文法</figcaption></figure></p><h6 id=状态机转换 class=heading-element><span>状态机转换</span>
<a href=#%e7%8a%b6%e6%80%81%e6%9c%ba%e8%bd%ac%e6%8d%a2 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h6><p>由一开始的自动机就可以看出，这里通过 <code>·</code> 点的移动来进行状态的转换，根据产生式的内容进行转移。</p><p>$$
J = \text{GOTO}(I, X) = \text{CLOSURE}(\{[A \to \alpha X \cdot \beta ] \mid [A \to \alpha \cdot X \beta] \})
$$</p><p>接受状态：
$$
F = \{ I \in C \mid \exists [A \to \alpha \cdot] \in I \}
$$
此时，产生式 $ A \ to \alpha$ 的完整右部出现在栈顶</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220006.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220006.png?size=small" data-sub-html="<h2>20241208220006</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220006.png alt=状态转移 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220006.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220006.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220006.png?size=large 2x" data-title=20241208220006 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>状态转移</figcaption></figure></p><h6 id=构建分析表 class=heading-element><span>构建分析表</span>
<a href=#%e6%9e%84%e5%bb%ba%e5%88%86%e6%9e%90%e8%a1%a8 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h6><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220036.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220036.png?size=small" data-sub-html="<h2>20241208220036</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220036.png alt=分析表构造规则 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220036.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220036.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220036.png?size=large 2x" data-title=20241208220036 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>分析表构造规则</figcaption></figure></p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220046.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220046.png?size=small" data-sub-html="<h2>20241208220046</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220046.png alt=分析表构造规则 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220046.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220046.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220046.png?size=large 2x" data-title=20241208220046 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>分析表构造规则</figcaption></figure></p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220056.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220056.png?size=small" data-sub-html="<h2>20241208220056</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220056.png alt=分析表构造规则 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220056.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220056.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220056.png?size=large 2x" data-title=20241208220056 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>分析表构造规则</figcaption></figure></p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220105.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220105.png?size=small" data-sub-html="<h2>20241208220105</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220105.png alt=分析表构造规则 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220105.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220105.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220105.png?size=large 2x" data-title=20241208220105 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>分析表构造规则</figcaption></figure></p><h4 id=文法定义 class=heading-element><span>文法定义</span>
<a href=#%e6%96%87%e6%b3%95%e5%ae%9a%e4%b9%89 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220128.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220128.png?size=small" data-sub-html="<h2>20241208220128</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220128.png alt=文法定义 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220128.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220128.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220128.png?size=large 2x" data-title=20241208220128 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>文法定义</figcaption></figure></p><p>这里的无冲突，就是指每一个空位上只有一个规则，而上图可见是冲突的，它不是 LR(0) 文法。这里的 <code>0</code> 指的就是归约时无需向前看，<code>·</code> 移动到什么地方就进行归约判断。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220406.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220406.png?size=small" data-sub-html="<h2>20241208220406</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220406.png alt=自动机与栈 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220406.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220406.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241208220406.png?size=large 2x" data-title=20241208220406 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>自动机与栈</figcaption></figure></p><h4 id=其余 class=heading-element><span>其余</span>
<a href=#%e5%85%b6%e4%bd%99 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>余下的 <code>LSR(1)</code>、<code>LR(1)</code>、<code>LALR(1)</code> 算法都是面对移入归约冲突、归越归约冲突的不同改进。具体可以看课程。</p><h2 id=semantics-symboltable-ag class=heading-element><span>Semantics SymbolTable Ag</span>
<a href=#semantics-symboltable-ag class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><blockquote><p>这里记录符号表、语义属性相关知识。</p></blockquote><h3 id=symbol-table class=heading-element><span>Symbol Table</span>
<a href=#symbol-table class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>符号主要指变量名、函数名、类型名、标签名。在语义分析中需要进行符号检查，即检查程序是否会出现符号乱用的情况，例如前一句将符号 symbol 定义为变量，之后又把它当作函数来进行函数调用了。而符号表就是用于<strong>保存各种符号相关信息</strong>的<strong>数据结构</strong>，它不仅在前端语法分析之后会发挥作用，还会在后端的生成中间代码的过程进行使用。下面就是一个符号表的示例。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241123100301.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241123100301.png?size=small" data-sub-html="<h2>20241123100301</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241123100301.png alt=符号表 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241123100301.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241123100301.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241123100301.png?size=large 2x" data-title=20241123100301 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>符号表</figcaption></figure></p><p>但是对于符号检查而言，最为困难的就是作用域了。&ldquo;领域特定语言&rdquo;（DSL），例如简单的键值对，它们通常只有单作用域（全局作用域），而对于我们真正要分析的“通用程序设计语言”（GPL），它通常就需要嵌套作用域了，这时就需要不同的哈希表来进行符号存储了，由此每个符号表代表了一个作用域，不同的作用域需要通过树结构来维护。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241123100713.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241123100713.png?size=small" data-sub-html="<h2>20241123100713</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241123100713.png alt=多作用域符号表 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241123100713.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241123100713.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241123100713.png?size=large 2x" data-title=20241123100713 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>多作用域符号表</figcaption></figure></p><p>下面就是每个作用域需要提供的接口：<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241123100840.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241123100840.png?size=small" data-sub-html="<h2>20241123100840</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241123100840.png alt=作用域接口 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241123100840.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241123100840.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241123100840.png?size=large 2x" data-title=20241123100840 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>作用域接口</figcaption></figure></p><p>符号表相关的类层次结构设计如下，它是 Lab3 的一部分，表示了符号表的设计。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241123101136.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241123101136.png?size=small" data-sub-html="<h2>20241123101136</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241123101136.png alt=符号表类层次结构 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241123101136.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241123101136.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241123101136.png?size=large 2x" data-title=20241123101136 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>符号表类层次结构</figcaption></figure></p><h3 id=语义分析 class=heading-element><span>语义分析</span>
<a href=#%e8%af%ad%e4%b9%89%e5%88%86%e6%9e%90 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>这里讲述的就是属性文法，它指的就是为上下文无关文法赋予语义，分析的就是如何基于上下文无关文法做上下文相关分析。</p><p>因此得出在语法分析过程中实现属性文法，就是通过在推导过程中嵌入语义动作，例如 $B \rightarrow X \{ \textcolor{red}{a} \} Y$。语义动作嵌入的位置决定了何时执行该动作，<strong>基本思想</strong>就是一个动作在它左边的所有文法符号都处理过之后立刻执行。在 antlr4 中，使用参数的形式来表示继承属性，使用返回值来表示综合属性。</p><h4 id=语法制导定义 class=heading-element><span>语法制导定义</span>
<a href=#%e8%af%ad%e6%b3%95%e5%88%b6%e5%af%bc%e5%ae%9a%e4%b9%89 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>SDD（语法制导定义，Syntax-Directed Definition）是一个上下文无关文法的<strong>属性</strong>及<strong>规则</strong>的结合。</p><ul><li>每个文法符号都可以关联多个属性</li><li>每个产生式都可以关联一组规则</li></ul><p>SDD 唯一确定了语法分析树上每个非终结符节点的属性值，但它没有规定以什么方式、什么顺序计算这些属性值。顺序是根据不同的语法分析器的情况而言的，比如 antlr4 是深度优先遍历，那么它呃顺序也就是这个了。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128082043.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128082043.png?size=small" data-sub-html="<h2>20241128082043</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128082043.png alt="antlr 遍历" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128082043.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128082043.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128082043.png?size=large 2x" data-title=20241128082043 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>antlr 遍历</figcaption></figure></p><h5 id=s-属性定义 class=heading-element><span>S 属性定义</span>
<a href=#s-%e5%b1%9e%e6%80%a7%e5%ae%9a%e4%b9%89 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128082311.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128082311.png?size=small" data-sub-html="<h2>20241128082311</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128082311.png alt="综合属性和 S 属性" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128082311.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128082311.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128082311.png?size=large 2x" data-title=20241128082311 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>综合属性和 S 属性</figcaption></figure></p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128082354.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128082354.png?size=small" data-sub-html="<h2>20241128082354</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128082354.png alt=属性依赖关系 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128082354.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128082354.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128082354.png?size=large 2x" data-title=20241128082354 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>属性依赖关系</figcaption></figure>由上图可以看出 S 属性的含义。本质而言，他就是父节点的信息需要依赖于子节点的传递，只有子节点首先处理完得到了结果，才能传递给父节点进行使用。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128082440.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128082440.png?size=small" data-sub-html="<h2>20241128082440</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128082440.png alt="S 属性性质" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128082440.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128082440.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128082440.png?size=large 2x" data-title=20241128082440 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>S 属性性质</figcaption></figure></p><h5 id=l-属性定义 class=heading-element><span>L 属性定义</span>
<a href=#l-%e5%b1%9e%e6%80%a7%e5%ae%9a%e4%b9%89 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128082645.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128082645.png?size=small" data-sub-html="<h2>20241128082645</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128082645.png alt=集成属性 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128082645.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128082645.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128082645.png?size=large 2x" data-title=20241128082645 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>集成属性</figcaption></figure>由上图，$T^{&rsquo;}$ 有一个综合属性 <code>syn</code> 与一个继承属性 <code>inh</code>。这里继承属性 $T^{&rsquo;}.inh$ 用于在表达式中从左向右传递中间计算结果。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128082706.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128082706.png?size=small" data-sub-html="<h2>20241128082706</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128082706.png alt="L 属性" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128082706.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128082706.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128082706.png?size=large 2x" data-title=20241128082706 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>L 属性</figcaption></figure>上述的定义就是排除依赖右兄弟节点的情况，因为这种情况对于深度优先建立的语法分析树而言是不可能实现的。</p><h5 id=例子 class=heading-element><span>例子</span>
<a href=#%e4%be%8b%e5%ad%90 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><h6 id=属性文法计算后缀表达式 class=heading-element><span>属性文法计算后缀表达式</span>
<a href=#%e5%b1%9e%e6%80%a7%e6%96%87%e6%b3%95%e8%ae%a1%e7%ae%97%e5%90%8e%e7%bc%80%e8%a1%a8%e8%be%be%e5%bc%8f class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h6><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128083433.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128083433.png?size=small" data-sub-html="<h2>20241128083433</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128083433.png alt=后缀表示 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128083433.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128083433.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128083433.png?size=large 2x" data-title=20241128083433 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>后缀表示</figcaption></figure></p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128083912.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128083912.png?size=small" data-sub-html="<h2>20241128083912</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128083912.png alt="后缀表达 S 属性" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128083912.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128083912.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128083912.png?size=large 2x" data-title=20241128083912 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>后缀表达 S 属性</figcaption></figure>这里是子节点向父节点传递信息，所以使用综合属性。</p><h6 id=数组类型文法举例 class=heading-element><span>数组类型文法举例</span>
<a href=#%e6%95%b0%e7%bb%84%e7%b1%bb%e5%9e%8b%e6%96%87%e6%b3%95%e4%b8%be%e4%be%8b class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h6><p>综合信息的流向是从下向上传递信息，继承信息流向是从左向右、从上到下传递信息。所以为了把二者进行结合，那么就先通过<strong>继承属性</strong>从左向右、从上到下传递信息，再通过<strong>综合属性</strong>从下向上传递信息。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128084323.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128084323.png?size=small" data-sub-html="<h2>20241128084323</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128084323.png alt=数组类型 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128084323.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128084323.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128084323.png?size=large 2x" data-title=20241128084323 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>数组类型</figcaption></figure></p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128085801.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128085801.png?size=small" data-sub-html="<h2>20241128085801</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128085801.png alt=信息传递 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128085801.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128085801.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128085801.png?size=large 2x" data-title=20241128085801 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>信息传递</figcaption></figure></p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128090225.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128090225.png?size=small" data-sub-html="<h2>20241128090225</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128090225.png alt=代码实现 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128090225.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128090225.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128090225.png?size=large 2x" data-title=20241128090225 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>代码实现</figcaption></figure>上图绿色为继承属性，把 int 从左往右，从上往下传递；红色为综合属性，把类型信息从下往上传递。</p><h6 id=属性文法计算有符号二进制数 class=heading-element><span>属性文法计算有符号二进制数</span>
<a href=#%e5%b1%9e%e6%80%a7%e6%96%87%e6%b3%95%e8%ae%a1%e7%ae%97%e6%9c%89%e7%ac%a6%e5%8f%b7%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%95%b0 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h6><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128093221.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128093221.png?size=small" data-sub-html="<h2>20241128093221</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128093221.png alt=有符号二进制数 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128093221.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128093221.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128093221.png?size=large 2x" data-title=20241128093221 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>有符号二进制数</figcaption></figure></p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128093306.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128093306.png?size=small" data-sub-html="<h2>20241128093306</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128093306.png alt="L 属性定义" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128093306.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128093306.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128093306.png?size=large 2x" data-title=20241128093306 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>L 属性定义</figcaption></figure></p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128093320.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128093320.png?size=small" data-sub-html="<h2>20241128093320</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128093320.png alt=语法树传递信息 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128093320.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128093320.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128093320.png?size=large 2x" data-title=20241128093320 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>语法树传递信息</figcaption></figure></p><h4 id=语法制导的翻译方案 class=heading-element><span>语法制导的翻译方案</span>
<a href=#%e8%af%ad%e6%b3%95%e5%88%b6%e5%af%bc%e7%9a%84%e7%bf%bb%e8%af%91%e6%96%b9%e6%a1%88 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128093446.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128093446.png?size=small" data-sub-html="<h2>20241128093446</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128093446.png alt=SDT srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128093446.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128093446.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128093446.png?size=large 2x" data-title=20241128093446 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>SDT</figcaption></figure></p><p>SDD 只是一个理念，我们之后的例子都是进行 SDT 的操作，也就是真实实现。</p><h2 id=llvm-ir-control class=heading-element><span>LLVM IR Control</span>
<a href=#llvm-ir-control class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><blockquote><p>这里记录 llvm、ir 相关知识。</p></blockquote><h3 id=llvm class=heading-element><span>LLVM</span>
<a href=#llvm class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><h4 id=介绍 class=heading-element><span>介绍</span>
<a href=#%e4%bb%8b%e7%bb%8d class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><div class="alert alert-note"><p class=alert-title><svg class="icon" viewBox="0 0 16 16" width="16" height="16"><path d="M0 8a8 8 0 1116 0A8 8 0 010 8zm8-6.5a6.5 6.5.0 100 13 6.5 6.5.0 000-13zM6.5 7.75A.75.75.0 017.25 7h1a.75.75.0 01.75.75v2.75h.25a.75.75.0 010 1.5h-2a.75.75.0 010-1.5h.25v-2h-.25a.75.75.0 01-.75-.75zM8 6a1 1 0 110-2 1 1 0 010 2z"/></svg>注意</p><p>The LLVM Project is a collection of modular and reusable compiler and tool-chain technologies. Despite its name, LLVM has little to do with traditional virtual machines. The name “LLVM” itself is not an acronym; it is the full name of the project.</p></div><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128101801.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128101801.png?size=small" data-sub-html="<h2>20241128101801</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128101801.png alt="LLVM IR" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128101801.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128101801.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128101801.png?size=large 2x" data-title=20241128101801 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>LLVM IR</figcaption></figure></p><h4 id=ir class=heading-element><span>IR</span>
<a href=#ir class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128101824.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128101824.png?size=small" data-sub-html="<h2>20241128101824</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128101824.png alt=IR srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128101824.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128101824.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128101824.png?size=large 2x" data-title=20241128101824 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>IR</figcaption></figure></p><h5 id=ir-生成 class=heading-element><span>IR 生成</span>
<a href=#ir-%e7%94%9f%e6%88%90 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>使用 <code>clang -S -emit-llvm -fno-discard-value-names xxx.c -o xxx.ll -O1 -g0</code> 将 c 代码转化为 IR 的形式。</p><ul><li><code>-S</code>：生成汇编代码（IR）作为输出，而不是直接生成二进制文件或可执行文件</li><li><code>-emit-llvm</code>：生成 LLVM 中间表示（IR），而不是目标平台的汇编代码。<code>-S</code> 都是和它一起进行使用</li><li><code>-fno-discard-value-names</code>：在生成的 IR 中不丢弃值的名称（如变量名和函数名），保留符号信息，便于调式或分析</li><li><code>-o xxx.ll</code>：指定生成人类可读的 <code>.ll</code> 形式文件，而不是 bitcode 形式的 <code>.bc</code> 形式文件</li><li><code>-O1</code>：优化级别设置，<code>-O1</code> 表示中等优化级别</li><li><code>-g0</code>：控制调试信息的级别，它表示不包含调试信息</li></ul><p>之后会形成下面形式的代码。它是<strong>强类型</strong>，同时为<strong>三地址码</strong>和<strong>静态单赋值</strong>形式。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128103522.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128103522.png?size=small" data-sub-html="<h2>20241128103522</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128103522.png alt=.ll文件 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128103522.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128103522.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128103522.png?size=large 2x" data-title=20241128103522 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>.ll文件</figcaption></figure></p><p>这里静态单赋值就是每个寄存器只被定义一次，也就是它只在左侧出现一遍，右侧没有限制。这样在软件上就可以实现无限制个数的寄存器了，同时对于变量定义的寻找也更为简便。下面就是 SSA 的转换，要使控制流满足 SSA，那么需要使用 $\phi$ 函数来根据控制流决定选择 y1 还是 y2。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128103929.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128103929.png?size=small" data-sub-html="<h2>20241128103929</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128103929.png alt=SSA转换 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128103929.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128103929.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128103929.png?size=large 2x" data-title=20241128103929 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>SSA转换</figcaption></figure></p><h5 id=不同优化等级的控制流 class=heading-element><span>不同优化等级的控制流</span>
<a href=#%e4%b8%8d%e5%90%8c%e4%bc%98%e5%8c%96%e7%ad%89%e7%ba%a7%e7%9a%84%e6%8e%a7%e5%88%b6%e6%b5%81 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>都是对于下面的代码通过上述命令生成不同优化等级的 IR 代码。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>factorial</span><span class=p>(</span><span class=kt>int</span> <span class=n>val</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>val</span> <span class=o>==</span> <span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>val</span> <span class=o>*</span> <span class=nf>factorial</span><span class=p>(</span><span class=n>val</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>下面就是没有优化的 CFG 图，可以看出它有一个开辟空间的操作，同时左右分支都把结果传到了 <code>%2</code> 这个寄存器之中，然后返回基本块姐可以直接使用这个进行返回。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128104340.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128104340.png?size=small" data-sub-html="<h2>20241128104340</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128104340.png alt="无优化 CFG" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128104340.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128104340.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128104340.png?size=large 2x" data-title=20241128104340 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>无优化 CFG</figcaption></figure></p><p>而下面就是 o1 优化的 CFG 图，它使用了 $\phi$ 函数来对分支进行处理，若是从 <code>%3</code> 基本块跳转来的，那么返回值使用 <code>%6</code>；若是从 <code>%1</code> 基本块跳转来的，返回值使用 <code>1</code>。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128110222.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128110222.png?size=small" data-sub-html="<h2>20241128110222</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128110222.png alt="o1 优化 CFG" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128110222.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128110222.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128110222.png?size=large 2x" data-title=20241128110222 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>o1 优化 CFG</figcaption></figure></p><p>然后对于下面的代码，不同优化等级的 IR 代码列举如下。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>factorial</span><span class=p>(</span><span class=kt>int</span> <span class=n>val</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>temp</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>val</span><span class=p>;</span> <span class=n>i</span> <span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>temp</span> <span class=o>*=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>这里没有优化的话，就会出现开辟空间的操作（下面的 <code>alloca</code>），然后因此涉及 <code>load</code> 和 <code>store</code> 操作。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128111138.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128111138.png?size=small" data-sub-html="<h2>20241128111138</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128111138.png alt=无优化版本 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128111138.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128111138.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128111138.png?size=large 2x" data-title=20241128111138 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>无优化版本</figcaption></figure></p><p>而若是采用了 o1 优化，那么上述开辟空间和加载等就没有了，整个代码都很简洁，多出了 $\phi$ 函数的操作。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128111155.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128111155.png?size=small" data-sub-html="<h2>20241128111155</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128111155.png alt="o1 优化版本" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128111155.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128111155.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241128111155.png?size=large 2x" data-title=20241128111155 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>o1 优化版本</figcaption></figure></p><h3 id=中间代码生成 class=heading-element><span>中间代码生成</span>
<a href=#%e4%b8%ad%e9%97%b4%e4%bb%a3%e7%a0%81%e7%94%9f%e6%88%90 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><h4 id=表达式翻译 class=heading-element><span>表达式翻译</span>
<a href=#%e8%a1%a8%e8%be%be%e5%bc%8f%e7%bf%bb%e8%af%91 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><h5 id=非布尔表达式翻译 class=heading-element><span>非布尔表达式翻译</span>
<a href=#%e9%9d%9e%e5%b8%83%e5%b0%94%e8%a1%a8%e8%be%be%e5%bc%8f%e7%bf%bb%e8%af%91 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>这里如图所示，<code>E.code</code> 表示翻译后的中间代码，<code>E.addr</code> 表示原本的变量和生成的中间变量。下面的流程就是通过构建语法树，然后自底向上匹配规则，逐一生成中间变量，同时也就生成了中间代码。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203110615.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203110615.png?size=small" data-sub-html="<h2>20241203110615</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203110615.png alt=表达式翻译 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203110615.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203110615.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203110615.png?size=large 2x" data-title=20241203110615 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>表达式翻译</figcaption></figure></p><h5 id=数组引用翻译 class=heading-element><span>数组引用翻译</span>
<a href=#%e6%95%b0%e7%bb%84%e5%bc%95%e7%94%a8%e7%bf%bb%e8%af%91 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>下面就是数组引用的中间代码翻译流程，我们首先就是需要对声明进行解析，这样我们才能得到数组的宽度。之后才会对于 i，j 进行解析，运用公式得到最后的地址。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203111953.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203111953.png?size=small" data-sub-html="<h2>20241203111953</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203111953.png alt=数组引用翻译 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203111953.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203111953.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203111953.png?size=large 2x" data-title=20241203111953 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>数组引用翻译</figcaption></figure></p><p>对于数组声明就采用之前的翻译制导方案，通过继承属性和综合属性来传递相关信息，最后形成数组类型。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203112109.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203112109.png?size=small" data-sub-html="<h2>20241203112109</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203112109.png alt=语法制导翻译 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203112109.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203112109.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203112109.png?size=large 2x" data-title=20241203112109 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>语法制导翻译</figcaption></figure></p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203112252.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203112252.png?size=small" data-sub-html="<h2>20241203112252</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203112252.png alt=翻译规则 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203112252.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203112252.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203112252.png?size=large 2x" data-title=20241203112252 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>翻译规则</figcaption></figure></p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203112310.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203112310.png?size=small" data-sub-html="<h2>20241203112310</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203112310.png alt=翻译语法树 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203112310.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203112310.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203112310.png?size=large 2x" data-title=20241203112310 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>翻译语法树</figcaption></figure></p><p>这里主要关注 <code>getelementptr</code>，它对于数组元素进行解包获取内部信息。对于这里的参数 <code>[2 x [3 x i32]]</code> 是 <code>base type</code>，<code>[2 x [3 x i32]]* %2</code> 是数组的首地址，同时返回一个指向元素的指针，所以后面需要进行 load 操作。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203113752.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203113752.png?size=small" data-sub-html="<h2>20241203113752</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203113752.png alt=翻译后中间代码 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203113752.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203113752.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203113752.png?size=large 2x" data-title=20241203113752 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>翻译后中间代码</figcaption></figure></p><h4 id=控制流翻译easy class=heading-element><span>控制流翻译（easy）</span>
<a href=#%e6%8e%a7%e5%88%b6%e6%b5%81%e7%bf%bb%e8%af%91easy class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>这里就是对于下面的产生式进行翻译，转化为中间代码的形式。同时使用的是 Visitor 方式，因为我们这里需要及时输出生成的中间代码，避免频繁的字符串拼接操作，而使用 Listener 模式会有上面的问题，直接进行 Attributed Grammar 方式则会很麻烦。</p><p>同时这里为简单模式的翻译，它只需要使用综合属性，各个非终结符的分工、合作明确。所以产生的代码也相对冗杂。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203172019.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203172019.png?size=small" data-sub-html="<h2>20241203172019</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203172019.png alt=产生式翻译 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203172019.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203172019.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203172019.png?size=large 2x" data-title=20241203172019 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>产生式翻译</figcaption></figure></p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203185911.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203185911.png?size=small" data-sub-html="<h2>20241203185911</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203185911.png alt=翻译规则 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203185911.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203185911.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203185911.png?size=large 2x" data-title=20241203185911 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>翻译规则</figcaption></figure></p><h5 id=if-条件语句 class=heading-element><span>if 条件语句</span>
<a href=#if-%e6%9d%a1%e4%bb%b6%e8%af%ad%e5%8f%a5 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>下面就是对于 if 条件语句的翻译规则。总结起来就是我们首先需要标记两个标签 true 和 false，然后看 if 中的 cond 来分配这两个标签到 if 中的语句块和 if 结尾，这样我们就实现了对于 if 语句的翻译。</p><p>最终生成的 IR 也是如下面的类型：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># 源代码
</span></span><span class=line><span class=cl>if (true) {
</span></span><span class=line><span class=cl>    a = b;
</span></span><span class=line><span class=cl>    b = c;
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># 翻译代码
</span></span><span class=line><span class=cl>br true b.true1 b.false2
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>b.true1:
</span></span><span class=line><span class=cl>a = b
</span></span><span class=line><span class=cl>c = c
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>b.false2:</span></span></code></pre></td></tr></table></div></div><h5 id=if-else-语句 class=heading-element><span>if else 语句</span>
<a href=#if-else-%e8%af%ad%e5%8f%a5 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>而对于 if else 形式的，需要在上面的基础上添加一个 end 的标签，这样比如在 true 的语句执行完之后，直接到 if 之后的语句，而不是 else 语句。</p><p>最终生成的 IR 也是如下面的类型：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># 源代码
</span></span><span class=line><span class=cl>if (true) {
</span></span><span class=line><span class=cl>    a = b;
</span></span><span class=line><span class=cl>    if (true) {
</span></span><span class=line><span class=cl>        c = d;
</span></span><span class=line><span class=cl>    } else {
</span></span><span class=line><span class=cl>        e = g;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>} else {
</span></span><span class=line><span class=cl>    d = f;
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># 翻译代码
</span></span><span class=line><span class=cl>br true b.true1 b.false2
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>b.true1:
</span></span><span class=line><span class=cl>a = b
</span></span><span class=line><span class=cl>br true b.true4 b.false5
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>b.true4:
</span></span><span class=line><span class=cl>c = d
</span></span><span class=line><span class=cl>br end.6
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>b.false5:
</span></span><span class=line><span class=cl>e = g
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>b.end6:
</span></span><span class=line><span class=cl>br b.end3
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>b.false2:
</span></span><span class=line><span class=cl>d = f
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>b.end3:</span></span></code></pre></td></tr></table></div></div><h5 id=while-循环语句 class=heading-element><span>while 循环语句</span>
<a href=#while-%e5%be%aa%e7%8e%af%e8%af%ad%e5%8f%a5 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>对于 while 循环，我们需要设置一个 begin 的标签，这样我们才可以在满足循环条件的前提下从头开始执行代码。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># 源代码
</span></span><span class=line><span class=cl>while (true) {
</span></span><span class=line><span class=cl>    a = b;
</span></span><span class=line><span class=cl>    if (true) {
</span></span><span class=line><span class=cl>        c = d;
</span></span><span class=line><span class=cl>    } else {
</span></span><span class=line><span class=cl>        e = f;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>a = c;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># 翻译代码
</span></span><span class=line><span class=cl>begin1:
</span></span><span class=line><span class=cl>br true b.true2 b.false3
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>b.true2:
</span></span><span class=line><span class=cl>a = b
</span></span><span class=line><span class=cl>br true b.true4 b.false5
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>b.true4:
</span></span><span class=line><span class=cl>c = d
</span></span><span class=line><span class=cl>br b.end6
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>b.false5:
</span></span><span class=line><span class=cl>e = f
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>b.end6:
</span></span><span class=line><span class=cl>br begin1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>b.false3:
</span></span><span class=line><span class=cl>a = c</span></span></code></pre></td></tr></table></div></div><h5 id=break-语句 class=heading-element><span>break 语句</span>
<a href=#break-%e8%af%ad%e5%8f%a5 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>这里 break 语句的翻译难点就在于它只会跳出离他最近的一层循环，所以我们需要追踪它会跳到哪一个标签处。面对这种情况，我们采用栈结构来存储相关标签。如下图所示，我们在内外层 while 处分别压入相关标签，面对 break 时就跳到栈顶的标签处，这样就实现了只跳出离它最近一层的功能。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203191735.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203191735.png?size=small" data-sub-html="<h2>20241203191735</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203191735.png alt="break 栈展示" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203191735.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203191735.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203191735.png?size=large 2x" data-title=20241203191735 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>break 栈展示</figcaption></figure></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># 源代码
</span></span><span class=line><span class=cl>while (true) {
</span></span><span class=line><span class=cl>    while (false) {
</span></span><span class=line><span class=cl>        if (true) {
</span></span><span class=line><span class=cl>            break; # 这里的 break 只会跳出 while
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        a = b;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    a = c;
</span></span><span class=line><span class=cl>    break;
</span></span><span class=line><span class=cl>    a = d;
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>a = e;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># 翻译代码
</span></span><span class=line><span class=cl>begin1:
</span></span><span class=line><span class=cl>br true b.true2 b.false3
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>b.true2:
</span></span><span class=line><span class=cl>begin4:
</span></span><span class=line><span class=cl>br false b.true5 b.false6
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>b.true5:
</span></span><span class=line><span class=cl>br true b.true7 b.false8
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>b.true7:
</span></span><span class=line><span class=cl>br b.false6
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>b.false8:
</span></span><span class=line><span class=cl>a = b
</span></span><span class=line><span class=cl>br begin4
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>b.false6:
</span></span><span class=line><span class=cl>a = c
</span></span><span class=line><span class=cl>br b.flase3
</span></span><span class=line><span class=cl>a = d
</span></span><span class=line><span class=cl>br begin1
</span></span><span class=line><span class=cl>b.false3:
</span></span><span class=line><span class=cl>a = e</span></span></code></pre></td></tr></table></div></div><h5 id=短路求值 class=heading-element><span>短路求值</span>
<a href=#%e7%9f%ad%e8%b7%af%e6%b1%82%e5%80%bc class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>短路求值和 if else 语句很像，例如 <code>||</code>，前面的正确后，要标记正确并跳转到最后，前面失败，那么就看后面的正误来跳转。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># 源代码
</span></span><span class=line><span class=cl>while (true || false) {
</span></span><span class=line><span class=cl>    a = b;
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>a = c;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># 翻译代码
</span></span><span class=line><span class=cl>begin1:
</span></span><span class=line><span class=cl>br true or.true2 or.false3
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>or.false3:
</span></span><span class=line><span class=cl>t1 = false
</span></span><span class=line><span class=cl>br or.end4
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>or.true2:
</span></span><span class=line><span class=cl>t1 = true
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>or.end4:
</span></span><span class=line><span class=cl>br t1 b.true5 b.false6
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>b.true5:
</span></span><span class=line><span class=cl>a = b
</span></span><span class=line><span class=cl>br begin1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>b.false6:
</span></span><span class=line><span class=cl>a = c</span></span></code></pre></td></tr></table></div></div><h4 id=控制流翻译hard class=heading-element><span>控制流翻译（hard）</span>
<a href=#%e6%8e%a7%e5%88%b6%e6%b5%81%e7%bf%bb%e8%af%91hard class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>这里为困难模式，和简单模式相比，它直接用布尔表达式改变控制流，无需计算最终逻辑值，即将不同非终结符的作用混杂在一起。因此它需要从父节点获取更具体的跳转目标，缩短跳转路径。为此父节点要为子节点准备跳转指令的目标标签，子节点就通过继承属性确定跳转目标。</p><h5 id=if-语句 class=heading-element><span>if 语句</span>
<a href=#if-%e8%af%ad%e5%8f%a5 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>如下图所示，在困难模式下 $B.false = S_{1}.next = S.next$，这样通过将不同非终结符设置的标签根据位置组合成一个的做法简化了生成的代码。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203190101.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203190101.png?size=small" data-sub-html="<h2>20241203190101</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203190101.png alt=相关操作 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203190101.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203190101.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203190101.png?size=large 2x" data-title=20241203190101 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>相关操作</figcaption></figure></p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203190022.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203190022.png?size=small" data-sub-html="<h2>20241203190022</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203190022.png alt="if 语句" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203190022.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203190022.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203190022.png?size=large 2x" data-title=20241203190022 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>if 语句</figcaption></figure></p><h5 id=if-else-语句-1 class=heading-element><span>if else 语句</span>
<a href=#if-else-%e8%af%ad%e5%8f%a5-1 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203190642.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203190642.png?size=small" data-sub-html="<h2>20241203190642</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203190642.png alt=相关操作 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203190642.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203190642.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203190642.png?size=large 2x" data-title=20241203190642 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>相关操作</figcaption></figure></p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203190659.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203190659.png?size=small" data-sub-html="<h2>20241203190659</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203190659.png alt="if else 语句" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203190659.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203190659.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203190659.png?size=large 2x" data-title=20241203190659 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>if else 语句</figcaption></figure></p><h5 id=while-循环语句-1 class=heading-element><span>while 循环语句</span>
<a href=#while-%e5%be%aa%e7%8e%af%e8%af%ad%e5%8f%a5-1 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203191130.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203191130.png?size=small" data-sub-html="<h2>20241203191130</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203191130.png alt=相关操作 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203191130.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203191130.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203191130.png?size=large 2x" data-title=20241203191130 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>相关操作</figcaption></figure></p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203191139.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203191139.png?size=small" data-sub-html="<h2>20241203191139</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203191139.png alt="while 循环语句" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203191139.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203191139.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203191139.png?size=large 2x" data-title=20241203191139 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>while 循环语句</figcaption></figure></p><h5 id=布尔表达式 class=heading-element><span>布尔表达式</span>
<a href=#%e5%b8%83%e5%b0%94%e8%a1%a8%e8%be%be%e5%bc%8f class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203192731.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203192731.png?size=small" data-sub-html="<h2>20241203192731</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203192731.png alt=布尔表达式 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203192731.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203192731.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241203192731.png?size=large 2x" data-title=20241203192731 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>布尔表达式</figcaption></figure></p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241205091529.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241205091529.png?size=small" data-sub-html="<h2>20241205091529</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241205091529.png alt=具体例子 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241205091529.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241205091529.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241205091529.png?size=large 2x" data-title=20241205091529 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>具体例子</figcaption></figure></p><h4 id=backpatch class=heading-element><span>backpatch</span>
<a href=#backpatch class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241205104349.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241205104349.png?size=small" data-sub-html="<h2>20241205104349</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241205104349.png alt=技术介绍 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241205104349.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241205104349.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241205104349.png?size=large 2x" data-title=20241205104349 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>技术介绍</figcaption></figure></p><p>根据以下的规则，综合属性 $B.truelist$ 保存需要跳转到 $B.true$ 标签的指令，综合属性 $B.falselist$ 保存需要跳转到 $B.false$ 标签的指令，综合属性 $S/L.nextlist$ 保存需要跳转到 $S/L.next$ 标签的指令。</p><p>之后就是为左部非终结符 $B$ 计算综合属性 $B.truelist$ 与 $B.falselist$，为左部非终结符 $S/L$ 计算综合属性 $S/L.nextlist$，并考虑每个综合属性，为已能确定目标地址的跳转指令进行<strong>回填</strong>。下面只有 (3) 与 (7) 的 gen 生成了新的代码，控制流语句主要目的就是 <strong>控制</strong> 流。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241205104559.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241205104559.png?size=small" data-sub-html="<h2>20241205104559</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241205104559.png alt=相关规则 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241205104559.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241205104559.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241205104559.png?size=large 2x" data-title=20241205104559 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>相关规则</figcaption></figure></p><p>由上面的做法，需要为回填操作添加多的属性来获取信息，由此就有了 M 属性和 N 属性。</p><h5 id=m-属性 class=heading-element><span>M 属性</span>
<a href=#m-%e5%b1%9e%e6%80%a7 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>M 属性就是获取下一个 code 的第一条语句的位置，这样我们就可以得到相关的位置信息了，之后我们就可以根据这个信息来进行回填。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241205105504.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241205105504.png?size=small" data-sub-html="<h2>20241205105504</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241205105504.png alt="M 属性示例" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241205105504.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241205105504.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241205105504.png?size=large 2x" data-title=20241205105504 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>M 属性示例</figcaption></figure></p><h5 id=n-属性 class=heading-element><span>N 属性</span>
<a href=#n-%e5%b1%9e%e6%80%a7 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>N 属性就是添加一条 goto 语句，一开始就是为了解决 if else 的跳转到最后的情况。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241205110021.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241205110021.png?size=small" data-sub-html="<h2>20241205110021</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241205110021.png alt="N 相关规则" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241205110021.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241205110021.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241205110021.png?size=large 2x" data-title=20241205110021 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>N 相关规则</figcaption></figure></p><h2 id=codegen-riscv-isel-ra class=heading-element><span>Codegen Riscv Isel Ra</span>
<a href=#codegen-riscv-isel-ra class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><blockquote><p>这里记录 riscv、isel、ra 的相关知识。</p></blockquote><h3 id=riscv class=heading-element><span>riscv</span>
<a href=#riscv class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>这里主要就是讲述了 riscv 的汇编语法，通过写汇编语言并执行来加强对于 riscv 的熟悉。因此这里没什么笔记，需要的时候再去查找 riscv 的相关汇编语法。</p><p>贴一下 <a href=http://staff.ustc.edu.cn/~llxx/cod/reference_books/RISC-V-Reader-Chinese-v2p12017.pdf target=_blank rel="external nofollow noopener noreferrer">相关手册</a>。</p><h3 id=代码转换 class=heading-element><span>代码转换</span>
<a href=#%e4%bb%a3%e7%a0%81%e8%bd%ac%e6%8d%a2 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>下面就是从中间语言到目标平台代码的翻译过程，其中 MC 指 Machine Code。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209090342.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209090342.png?size=small" data-sub-html="<h2>20241209090342</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209090342.png alt=转换流程 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209090342.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209090342.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209090342.png?size=large 2x" data-title=20241209090342 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>转换流程</figcaption></figure></p><p>下图上面部分就是在转换为目标代码过程中的各个中间产物，而下面就是具体流程。白色块就是 pass，主要是进行优化，因此我们的关注点就是黑色的转换块。</p><p>这里首先把 LLVM IR 转化为 DAG（有向无环图） 形式，然后在这个形势下做指令选择。之后 Instruction scheduling 就是对于前面的无环图进行排序，转换为线性结构，这样才能给后面进行处理。然后进行 Register allocation，把之前使用 SSA 的 IR 转换为有限寄存器的结构。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209090540.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209090540.png?size=small" data-sub-html="<h2>20241209090540</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209090540.png alt="LLVM 转换" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209090540.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209090540.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209090540.png?size=large 2x" data-title=20241209090540 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>LLVM 转换</figcaption></figure></p><h3 id=指令选择 class=heading-element><span>指令选择</span>
<a href=#%e6%8c%87%e4%bb%a4%e9%80%89%e6%8b%a9 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><h4 id=介绍-1 class=heading-element><span>介绍</span>
<a href=#%e4%bb%8b%e7%bb%8d-1 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209090109.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209090109.png?size=small" data-sub-html="<h2>20241209090109</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209090109.png alt=指令选择介绍 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209090109.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209090109.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209090109.png?size=large 2x" data-title=20241209090109 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>指令选择介绍</figcaption></figure></p><p>指令选择的介绍如上图所示，下面就是可以采用的不同的算法。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209091855.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209091855.png?size=small" data-sub-html="<h2>20241209091855</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209091855.png alt=指令选择算法 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209091855.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209091855.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209091855.png?size=large 2x" data-title=20241209091855 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>指令选择算法</figcaption></figure></p><p>下面就是 LLVM IR 生成的相关 DAG 图，之后我们需要做的就是对于这个 DAG 图进行优化，删除改进合并相关细节。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209092745.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209092745.png?size=small" data-sub-html="<h2>20241209092745</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209092745.png alt="DAG 生成" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209092745.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209092745.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209092745.png?size=large 2x" data-title=20241209092745 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>DAG 生成</figcaption></figure></p><p>优化之后的 DAG 如下左图所示。之后我们就需要从 DAG 中找到和指令相关的元素，然后采用树结构来进行匹配，从而获取下图最终的结果。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209092902.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209092902.png?size=small" data-sub-html="<h2>20241209092902</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209092902.png alt=选择指令 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209092902.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209092902.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209092902.png?size=large 2x" data-title=20241209092902 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>选择指令</figcaption></figure></p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209092911.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209092911.png?size=small" data-sub-html="<h2>20241209092911</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209092911.png alt=结构转换 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209092911.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209092911.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209092911.png?size=large 2x" data-title=20241209092911 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>结构转换</figcaption></figure></p><h4 id=树匹配 class=heading-element><span>树匹配</span>
<a href=#%e6%a0%91%e5%8c%b9%e9%85%8d class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209093104.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209093104.png?size=small" data-sub-html="<h2>20241209093104</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209093104.png alt=定义 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209093104.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209093104.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209093104.png?size=large 2x" data-title=20241209093104 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>定义</figcaption></figure></p><p>上面就是我们需要进行匹配的定义，下面则是我们相关的匹配规则。1<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209093408.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209093408.png?size=small" data-sub-html="<h2>20241209093408</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209093408.png alt="匹配规则 1" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209093408.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209093408.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209093408.png?size=large 2x" data-title=20241209093408 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>匹配规则 1</figcaption></figure></p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209093418.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209093418.png?size=small" data-sub-html="<h2>20241209093418</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209093418.png alt="匹配规则 2" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209093418.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209093418.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209093418.png?size=large 2x" data-title=20241209093418 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>匹配规则 2</figcaption></figure></p><p>由上述匹配规则，我们自底向上进行匹配，若是遇到更大的匹配规则，那么采用更大的覆盖小的，这样就可以得到右侧的相关指令。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209093425.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209093425.png?size=small" data-sub-html="<h2>20241209093425</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209093425.png alt=匹配结果 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209093425.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209093425.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209093425.png?size=large 2x" data-title=20241209093425 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>匹配结果</figcaption></figure></p><p>对于上述匹配是理解匹配，我们需要转换为相关算法，所以采用之前语法分析的流程。将树进行前缀表达，语法的推导也转换形式，这样就可以形成推导算法了。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209093441.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209093441.png?size=small" data-sub-html="<h2>20241209093441</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209093441.png alt=匹配算法 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209093441.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209093441.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209093441.png?size=large 2x" data-title=20241209093441 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>匹配算法</figcaption></figure></p><p>但是这也会存在二义性问题，所以面对归约/归约冲突，优先选择较长的归约；面对移入/归约冲突，优先选择移入动作。</p><h3 id=寄存器分配 class=heading-element><span>寄存器分配</span>
<a href=#%e5%af%84%e5%ad%98%e5%99%a8%e5%88%86%e9%85%8d class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209095529.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209095529.png?size=small" data-sub-html="<h2>20241209095529</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209095529.png alt=定义 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209095529.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209095529.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241209095529.png?size=large 2x" data-title=20241209095529 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>定义</figcaption></figure></p><p>线性扫描分配算法就是根据活跃变量算法查看不同变量的活跃期间，然后进行寄存器的分配和回收；而对于溢出变量，就是使用 store/load 来存取内存。然后后面就没有声音了，但是有个 <a href=https://cubicy.icu/compiler-construction-principles/ target=_blank rel="external nofollow noopener noreferrer">笔记</a> 可以看看，包含编译原理的很多内容。</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2025-04-15 00:18:37">更新于 2025.4.15&nbsp;
<a class=git-hash href=https://github.com/czTangt/blog.git/commit/2a00ed2028962bc79e815c448d5ffa60bc7aecc7 rel="external nofollow noopener noreferrer" target=_blank title="commit by czTangt(cz.tangt@gmail.com) 2a00ed2028962bc79e815c448d5ffa60bc7aecc7: modify the blog post structure twice"><i class="fa-solid fa-hashtag fa-fw" aria-hidden=true></i>2a00ed2</a></span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href="https://github.com/czTangt/blog.git/blob/main/content/posts%5cCourse%5cCompilers-Course.md?plain=1" title=查看源码 target=_blank rel="external nofollow noopener noreferrer" class=link-to-source>查看源码</a></span><span><a href=https://github.com/czTangt/blog.git/edit/main/content/posts%5cCourse%5cCompilers-Course.md title=编辑此页 target=_blank rel="external nofollow noopener noreferrer" class=link-to-edit>编辑此页</a></span><span><a href="https://github.com/czTangt/blog.git/issues/new?title=[BUG]%20Compilers+Course&amp;body=%7cField%7cValue%7c%0A%7c-%7c-%7c%0A%7cTitle%7cCompilers+Course%7c%0A%7cURL%7chttps://czTangt.github.io/blog/posts/course/compilers-course/%7c%0A%7cFilename%7chttps://github.com/czTangt/blog.git/blob/main/content/posts%5cCourse%5cCompilers-Course.md?plain=1%7c" title=报告问题 target=_blank rel="external nofollow noopener noreferrer" class=link-to-report>报告问题</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 X" data-sharer=twitter data-url=https://czTangt.github.io/blog/posts/course/compilers-course/ data-title="Compilers Course" data-hashtags=Course,compile><i class="fa-brands fa-x-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://czTangt.github.io/blog/posts/course/compilers-course/ data-hashtag=Course><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://czTangt.github.io/blog/posts/course/compilers-course/ data-title="Compilers Course"><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/blog/tags/course/ class=post-tag title="标签 - Course">Course</a><a href=/blog/tags/compile/ class=post-tag title="标签 - Compile">Compile</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/blog/>主页</a></span></section></div><div class=post-nav><a href=/blog/posts/programming/python/ class=post-nav-item rel=prev title="Some About Python"><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>Some About Python</a><a href=/blog/posts/config/git/ class=post-nav-item rel=next title="Some About Git">Some About Git<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article><aside class=toc id=toc-auto aria-label=目录><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside></main><footer class=footer><div class=footer-container><div class="footer-line powered order-1">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.136.5"><img class=hugo-icon src=/blog/images/hugo.min.svg alt="Hugo logo"> Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.3.17-30a67c4b"><img class=fixit-icon src=/blog/images/fixit.min.svg alt="FixIt logo"> FixIt</a></div><div class="footer-line copyright order-2" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2024 - 2025</span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class="variant-numeric d-none">0%</span></div></div><a href=https://github.com/czTangt/blog title="View source on GitHub" target=_blank rel="external nofollow" class="github-corner left d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true" width="56" height="56"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><noscript><div class=noscript-warning>该网站在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/blog/lib/lightgallery/css/lightgallery-bundle.min.css><link rel=preload href=/blog/lib/katex/katex.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/blog/lib/katex/katex.min.css></noscript><link rel=stylesheet href=/blog/lib/cookieconsent/cookieconsent.min.css><script src=/blog/lib/autocomplete/autocomplete.min.js defer></script><script src=/blog/lib/fuse/fuse.min.js defer></script><script src=/blog/lib/lightgallery/lightgallery.min.js defer></script><script src=/blog/lib/lightgallery/plugins/thumbnail/lg-thumbnail.min.js defer></script><script src=/blog/lib/lightgallery/plugins/zoom/lg-zoom.min.js defer></script><script src=/blog/lib/sharer/sharer.min.js async defer></script><script src=/blog/lib/katex/katex.min.js defer></script><script src=/blog/lib/katex/auto-render.min.js defer></script><script src=/blog/lib/katex/mhchem.min.js defer></script><script src=/blog/lib/cookieconsent/cookieconsent.min.js defer></script><script src=/blog/js/codeblock.js defer></script><script src=https://libs.baidu.com/jquery/2.1.4/jquery.min.js defer></script><script>window.config={code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:10},comment:{enable:!1},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},lightgallery:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{distance:100,findAllMatches:!1,fuseIndexURL:"/blog/search.json",highlightTag:"em",ignoreFieldNorm:!1,ignoreLocation:!1,isCaseSensitive:!1,location:0,maxResultLength:10,minMatchCharLength:2,noResultsFound:"没有找到结果",snippetLength:30,threshold:.3,type:"fuse",useExtendedSearch:!1},version:"v0.3.17-30a67c4b"}</script><script src=/blog/js/theme.min.js defer></script></body></html>