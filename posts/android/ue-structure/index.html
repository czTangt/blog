<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>UE 结构分析 - czTang</title><meta name=author content="czTang">
<meta name=description content="这里记录一下对于 UE4.27 SDK 的理解，同时补充完善 2024第九届腾讯游戏安全技术竞赛初赛安卓赛道 中的分析。源码在 SDKDumper。
"><meta name=keywords content='android,game'><meta itemprop=name content="UE 结构分析"><meta itemprop=description content="这里记录一下对于 UE4.27 SDK 的理解，同时补充完善 2024第九届腾讯游戏安全技术竞赛初赛安卓赛道 中的分析。源码在 SDKDumper。"><meta itemprop=datePublished content="2025-07-08T22:08:14+08:00"><meta itemprop=dateModified content="2025-07-08T22:08:14+08:00"><meta itemprop=wordCount content="8143"><meta itemprop=keywords content="Android,Game"><meta property="og:url" content="https://czTangt.github.io/blog/posts/android/ue-structure/"><meta property="og:site_name" content="czTang"><meta property="og:title" content="UE 结构分析"><meta property="og:description" content="这里记录一下对于 UE4.27 SDK 的理解，同时补充完善 2024第九届腾讯游戏安全技术竞赛初赛安卓赛道 中的分析。源码在 SDKDumper。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-07-08T22:08:14+08:00"><meta property="article:modified_time" content="2025-07-08T22:08:14+08:00"><meta property="article:tag" content="Android"><meta property="article:tag" content="Game"><meta name=twitter:card content="summary"><meta name=twitter:title content="UE 结构分析"><meta name=twitter:description content="这里记录一下对于 UE4.27 SDK 的理解，同时补充完善 2024第九届腾讯游戏安全技术竞赛初赛安卓赛道 中的分析。源码在 SDKDumper。"><meta name=application-name content="FixIt"><meta name=apple-mobile-web-app-title content="FixIt"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel=icon href=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410312135963.svg><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical type=text/html href=https://czTangt.github.io/blog/posts/android/ue-structure/ title="UE 结构分析 - czTang"><link rel=prev type=text/html href=https://czTangt.github.io/blog/posts/android/2024-tencent-gamesec-final/ title=2024腾讯游戏安全竞赛决赛><link rel=stylesheet href=/blog/css/style.min.css><link rel=preload href=/blog/lib/fontawesome-free/all.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/blog/lib/fontawesome-free/all.min.css></noscript><link rel=preload href=/blog/lib/animate/animate.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/blog/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"UE 结构分析","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/czTangt.github.io\/blog\/posts\/android\/ue-structure\/"},"genre":"posts","keywords":"android, game","wordcount":8143,"url":"https:\/\/czTangt.github.io\/blog\/posts\/android\/ue-structure\/","datePublished":"2025-07-08T22:08:14+08:00","dateModified":"2025-07-08T22:08:14+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"czTang"},"description":""}</script><script src=/blog/js/head/color-scheme.min.js></script></head><body data-header-desktop=sticky data-header-mobile=auto><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=left><div class=header-title><a href=/blog/ title=czTang><span class=header-title-pre><i class='fa fa-coffee'>&nbsp</i></span><span class=header-title-text>czTang</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/blog/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 归档</a></li><li class=menu-item><a class=menu-link href=/blog/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/blog/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/blog/about/><i class="fa-solid fa-user fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/blog/ title=czTang><span class=header-title-pre><i class='fa fa-coffee'>&nbsp</i></span><span class=header-title-text>czTang</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/blog/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 归档</a></li><li class=menu-item><a class=menu-link href=/blog/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/blog/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/blog/about/><i class="fa-solid fa-user fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=container><aside class="aside-collection animate__animated animate__fadeIn animate__faster" aria-label=合集><div class="details collection-details open"><div class="details-summary collection-summary"><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i>
<span class=collection-name title=合集>Game</span>
<span class=collection-count>3</span><i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class="details-content collection-content"><nav><ul class=collection-list><li class=collection-item><a href=/blog/posts/android/2024-tencent-gamesec-prelim/ title=2024腾讯游戏安全竞赛初赛>2024腾讯游戏安全竞赛初赛</a></li><li class=collection-item><a href=/blog/posts/android/2024-tencent-gamesec-final/ title=2024腾讯游戏安全竞赛决赛>2024腾讯游戏安全竞赛决赛</a></li><li class=collection-item><span class=active title="UE 结构分析">UE 结构分析</span></li></ul><div class=collection-nav-simple><a href=/blog/posts/android/2024-tencent-gamesec-final/ class=collection-nav-item rel=prev title=2024腾讯游戏安全竞赛决赛><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i></a><span class=text-secondary>3/3</span><i class="fa-solid fa-angle-right fa-fw collection-nav-item text-secondary" aria-hidden=true></i></div></nav></div></div></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>UE 结构分析</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/czTangt title=作者 target=_blank rel="external nofollow noopener noreferrer author" class=author><img loading=lazy src=/blog/images/avatar.jpg alt=czTang data-title=czTang width=20 height=20 class=avatar style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'>&nbsp;czTang</a></span><span class=post-included-in>&nbsp;收录于 <a href=/blog/categories/android/ class=post-category title="分类 - Android"><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> Android</a> 和 <a href=/blog/collections/game/ class=post-collection title="合集 - Game"><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i> Game</a></span></div><div class=post-meta-line><span title="发布于 2025-07-08 22:08:14"><i class="fa-solid fa-calendar-days fa-fw me-1" aria-hidden=true></i><time datetime=2025.7.8>2025.7.8</time></span>&nbsp;<span title="8143 字"><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 8200 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 17 分钟</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#基本结构>基本结构</a></li><li><a href=#strings-获取>Strings 获取</a><ul><li><a href=#fnameentryallocator>FNameEntryAllocator</a></li><li><a href=#debugdump>DebugDump</a></li><li><a href=#debugdumpblock>DebugDumpBlock</a><ul><li><a href=#fnameentry>FNameEntry</a></li><li><a href=#函数解析>函数解析</a></li></ul></li></ul></li><li><a href=#getname-算法>GetName 算法</a><ul><li><a href=#获取字符串>获取字符串</a><ul><li><a href=#相关结构>相关结构</a><ul><li><a href=#fstring>FString</a></li><li><a href=#tarray>TArray</a></li><li><a href=#tchar>TCHAR</a></li></ul></li><li><a href=#getdisplaynameentry>GetDisplayNameEntry</a><ul><li><a href=#getnamepool>GetNamePool</a></li><li><a href=#getdisplayindex>GetDisplayIndex</a></li><li><a href=#resolve>Resolve</a></li></ul></li><li><a href=#getplainnamestring>GetPlainNameString</a></li></ul></li><li><a href=#总结>总结</a></li></ul></li><li><a href=#actors-获取>Actors 获取</a><ul><li><a href=#获取地址>获取地址</a><ul><li><a href=#uworld>UWorld</a></li><li><a href=#ulevel>ULevel</a></li></ul></li><li><a href=#获取名称>获取名称</a><ul><li><a href=#获取唯一标识符>获取唯一标识符</a><ul><li><a href=#tarray-1>TArray</a></li><li><a href=#aactor>AActor</a></li><li><a href=#uobjectbase>UObjectBase</a></li><li><a href=#fname>FName</a></li></ul></li></ul></li></ul></li></ul></nav></div></div><div class=content id=content><p>这里记录一下对于 UE4.27 SDK 的理解，同时补充完善 <a href=https://gss.tencent.com/competition/2024/race-pre.htm target=_blank rel="external nofollow noopener noreferrer">2024第九届腾讯游戏安全技术竞赛初赛安卓赛道</a> 中的分析。源码在 <a href=https://github.com/czTangt/SDKDumper target=_blank rel="external nofollow noopener noreferrer">SDKDumper</a>。</p><div class="details admonition abstract open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-clipboard-list" aria-hidden=true></i>注意事项</div><div class=details-content><div class=admonition-content><p>为了更好地理解 UE4.27 SDK 的获取，这里根据 <a href=https://bbs.kanxue.com/thread-282857.htm target=_blank rel="external nofollow noopener noreferrer">UE4.27SDK-Dump</a> 的内容对 UE4.27 源码进行分析，同时结合 <a href=https://github.com/hackcatml/frida-ue4dump target=_blank rel="external nofollow noopener noreferrer">frida-ue4dump</a> 和 <a href=https://github.com/revercc/UE4Dumper target=_blank rel="external nofollow noopener noreferrer">UE4Dumper</a> 的代码对 <a href=https://gss.tencent.com/competition/2024/race-pre.htm target=_blank rel="external nofollow noopener noreferrer">2024第九届腾讯游戏安全技术竞赛初赛安卓赛道</a> 的游戏样本进行分析。同时在分析的过程中穿插对于 libUE.so 内存布局的查看，以便应对魔改的情况。</p></div></div></div><h2 id=基本结构 class=heading-element><span>基本结构</span>
<a href=#%e5%9f%ba%e6%9c%ac%e7%bb%93%e6%9e%84 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>查看 <a href=https://github.com/revercc/UE4Dumper target=_blank rel="external nofollow noopener noreferrer">UE4Dumper</a> 的使用指南，可以发现 dump sdk 通常需要 libUE.so 中三个变量的地址 GWorld，GName 和 GUObjectArray（也被称为GUobject）。</p><ul><li><strong>GWorld</strong>：GWorld 是一个全局变量，其类型为 <code>UWorld**</code>。它存储着指向当前活动游戏世界实例（<code>UWorld*</code>）的指针的地址。<code>*GWorld</code> 提供了访问当前世界（UWorld）的直接指针。UWorld 对象包含了游戏运行时的核心状态，如关卡、Actor 列表、玩家控制器、游戏模式、游戏状态、物理和导航系统等。它是游戏逻辑和对象交互的中心枢纽，是逆向工程中定位游戏状态和对象的起点。</li><li><strong>GName</strong>：GName 是一个全局的 FNamePool 实例。FNamePool 管理着引擎中所有唯一字符串标识符（FName）的存储池。它采用大块内存分配策略，块内划分槽位存储字符串条目。GName 使得通过 FName 的索引或句柄快速查找和比较字符串成为可能，是解析对象类型名、函数名、属性名等字符串的关键。</li><li><strong>GUObjectArray</strong>：GUObjectArray 是一个全局的 FUObjectArray 类型的实例。它是 UE 垃圾回收系统的核心组成部分，是所有 UObject 及其派生类实例的全局容器和注册表。通过遍历 GUObjectArray，可以枚举、跟踪和管理引擎中存在的所有 UObject 实例。</li></ul><p>在获取这些变量的地址之后，就可以进行下一步了。这里三个变量的获取方法不再赘述，网上很多资料讲述如何获取。</p><h2 id=strings-获取 class=heading-element><span>Strings 获取</span>
<a href=#strings-%e8%8e%b7%e5%8f%96 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>Strings</div><div class=details-content><div class=admonition-content><p>UE 使用 <strong>FName</strong> 存储唯一且不可变的字符串标识符（如对象名称、属性名、资源路径等），它为每个字符串分配唯一数字 ID（如 123 对应 &ldquo;Player&rdquo;），将文本名称转化为高效标识符，并集中存储在全局池中，使得游戏对象（如 Actor）能通过 ID 快速检索名称。</p></div></div></div><p>这里字符串的存储依赖于 <strong>GName</strong>，上文说到 <strong>GName</strong> 是一个全局的 FNamePool 实例。那么可以在源码中查看 FNamePool 这个类，如下所示：<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313173020.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313173020.png?size=small" data-sub-html="<h2>20250313173020</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313173020.png alt=FNamePool srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313173020.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313173020.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313173020.png?size=large 2x" data-title=20250313173020 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>FNamePool</figcaption></figure>在这个类中，存在函数 <code>TArray&lt;const FNameEntry *> DebugDump() const</code>，它用于调试目的，负责收集名称池中所有字符串条目的指针。而有了这个指针，我们就可以获取所有的字符串了，因此这里可以通过实现这个函数来达成我们 dump Strings 的目的。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250712183818.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250712183818.png?size=small" data-sub-html="<h2>20250712183818</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250712183818.png alt="DebugDump() 函数" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250712183818.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250712183818.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250712183818.png?size=large 2x" data-title=20250712183818 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>DebugDump() 函数</figcaption></figure>查看这个函数的实现，可以发现它创建输出容器 Out，然后预分配内存，之后通过 <code>Entries.DebugDump(Out)</code> 委托给内部的成员进行处理来获取字符串条目的指针。这里根据函数的实现可以发现，获取字符串条目指针的函数就是 <code>Entries.DebugDump(Out)</code>，因此这里了解实现这个函数就可以达成我们的目标，因此首先就需要了解相关的数据 Entries 的结构。</p><h3 id=fnameentryallocator class=heading-element><span>FNameEntryAllocator</span>
<a href=#fnameentryallocator class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>这里翻阅 FNamePool 类的源码可以发现第一个成员变量就是 Entries，它的类型为 FNameEntryAllocator。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>FNamePool</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>FNameEntryAllocator</span> <span class=n>Entries</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>......</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>得到了 Entries，那么就可以看同文件下的 <code>Entries.DebugDump(Out)</code> 函数了，这个函数就是 FNameEntryAllocator 类的一个成员函数。但是若要进行后续的探索，需要先知道 FNameEntryAllocator 这个类的结构。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313183511.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313183511.png?size=small" data-sub-html="<h2>20250313183511</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313183511.png alt=FNameEntryAllocator srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313183511.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313183511.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313183511.png?size=large 2x" data-title=20250313183511 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>FNameEntryAllocator</figcaption></figure>提取相关成员变量如下所示：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>static</span> <span class=k>constexpr</span> <span class=n>uint32</span> <span class=n>FNameMaxBlockBits</span> <span class=o>=</span> <span class=mi>13</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>constexpr</span> <span class=n>uint32</span> <span class=n>FNameBlockOffsetBits</span> <span class=o>=</span> <span class=mi>16</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>constexpr</span> <span class=n>uint32</span> <span class=n>FNameMaxBlocks</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>FNameMaxBlockBits</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>constexpr</span> <span class=n>uint32</span> <span class=n>FNameBlockOffsets</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>FNameBlockOffsetBits</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>FNameEntryAllocator</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=k>enum</span> <span class=p>{</span> <span class=n>Stride</span> <span class=o>=</span> <span class=k>alignof</span><span class=p>(</span><span class=n>FNameEntry</span><span class=p>)</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>	<span class=k>enum</span> <span class=p>{</span> <span class=n>BlockSizeBytes</span> <span class=o>=</span> <span class=n>Stride</span> <span class=o>*</span> <span class=n>FNameBlockOffsets</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>mutable</span> <span class=n>FRWLock</span> <span class=n>Lock</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>uint32</span> <span class=n>CurrentBlock</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>uint32</span> <span class=n>CurrentByteCursor</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>uint8</span><span class=o>*</span> <span class=n>Blocks</span><span class=p>[</span><span class=n>FNameMaxBlocks</span><span class=p>]</span> <span class=o>=</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>注意这个结构中存在成员变量 Blocks，它是 UE 中字符串存储的关键。FNamePool 由多个固定大小的内存块（Blocks）组成，每个块大小为 <code>BlockSize = FNameStride * 65536</code>。当当前块（CurrentBlock）用满后，会分配新块继续存储字符串。CurrentByteCursor 记录当前块已使用的字节数，最后一个块可能未完全使用。知道了这些就可以继续看 FNameEntryAllocator 的成员函数 <code>DebugDump()</code> 的代码。</p><p>同时还需要注意 <code>mutable FRWLock Lock;</code>，这里没有信息得知它的大小，但是这是对于 Android 平台，所以可以找到相关的定义，由此找到了 FRWLock 的定义。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313223325.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313223325.png?size=small" data-sub-html="<h2>20250313223325</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313223325.png alt=FRWLock srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313223325.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313223325.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313223325.png?size=large 2x" data-title=20250313223325 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>FRWLock</figcaption></figure>然后顺藤摸瓜可以找到 FPThreadsRWLock 类型的定义。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313223419.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313223419.png?size=small" data-sub-html="<h2>20250313223419</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313223419.png alt=FPThreadsRWLock srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313223419.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313223419.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313223419.png?size=large 2x" data-title=20250313223419 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>FPThreadsRWLock</figcaption></figure>这个 FPThreadsRWLock 只有一个成员变量，如下所示：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>FPThreadsRWLock</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>pthread_rwlock_t</span> <span class=n>Mutex</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>因此知道了 FRWLock 的大小就是 pthread_rwlock_t 的大小，而这个数据类型定义在 <strong>&lt;pthread.h></strong> 这个 Linux 库文件中，由此可以直接得到它的大小。它在 32 位安卓平台上此成员大小为 0x28，在 64 位安卓平台上是 0x38。</p><p>而对于 FNameEntryAllocator 中的 <code>Stride = alignof(FNameEntry)</code>，这里的 <code>alignof()</code> 用于 FNameEntry 的对齐要求。这里 FNameEntry 的对齐要求可以查看下面对于 FNameEntry 结构体的介绍，它是 2 字节，那么这里的 Stride 就是 2 了。于此同时，CurrentBlock 和 CurrentByteCursor 都是 uint32 类型，所以大小为 4 字节。而 Blocks 存储的则是 uint8* 类型的指针，它的大小在 64 为系统上为 8 字节。</p><h3 id=debugdump class=heading-element><span>DebugDump</span>
<a href=#debugdump class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>得到的 <code>DebugDump()</code> 函数实现如下：<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250712194213.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250712194213.png?size=small" data-sub-html="<h2>20250712194213</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250712194213.png alt="DebugDump() 实现" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250712194213.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250712194213.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250712194213.png?size=large 2x" data-title=20250712194213 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>DebugDump() 实现</figcaption></figure>忽略一开始加读锁的操作，这里的代码就是遍历所有的内存块，也就是 Blocks 数组，然后采用 <code>DebugDumpBlock()</code> 解析单个块中的字符串条目。for 循环内部使用完整快的固定大小 BlockSizeBytes，而 for 循环外对于最后一个块，因为可能没有用完，所以使用当前块的实际填充大小 CurrentByteCursor。</p><h3 id=debugdumpblock class=heading-element><span>DebugDumpBlock</span>
<a href=#debugdumpblock class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>然后找到 <code>DebugDumpBlock()</code> 函数进行分析：<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250713102617.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250713102617.png?size=small" data-sub-html="<h2>20250713102617</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250713102617.png alt="DebugDumpBlock() 实现" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250713102617.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250713102617.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250713102617.png?size=large 2x" data-title=20250713102617 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>DebugDumpBlock() 实现</figcaption></figure>这里 End 的获取就是从 Block 的开始加上 BlockSize，然后减去特定结构 FNameEntry 中的一个大小，因此这里要知道为什么要减去，需要知道 FNameEntry 的结构。</p><h4 id=fnameentry class=heading-element><span>FNameEntry</span>
<a href=#fnameentry class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313192458.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313192458.png?size=small" data-sub-html="<h2>20250313192458</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313192458.png alt=FNameEntry srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313192458.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313192458.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313192458.png?size=large 2x" data-title=20250313192458 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>FNameEntry</figcaption></figure>这里需要知道在 Block 中，字符串的存储其实就是 FNameEntry 的存储，在 Block 中紧邻的就是一个个 FNameEntry 结构，它负责对于字符串的封装处理。然后再看这个 FNameEntry 结构，它有一个在编译运行时才有效的宏，所以可以忽略不管。因此它的成员变量如下所示，只有一个 <code>FNameEntryHeader Header;</code> 和一个联合体，它们都会参与字符串的存储。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>enum</span> <span class=p>{</span> <span class=n>NAME_SIZE</span> <span class=o>=</span> <span class=mi>1024</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>FNameEntry</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>FNameEntryHeader</span> <span class=n>Header</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>union</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ANSICHAR</span> <span class=n>AnsiName</span><span class=p>[</span><span class=n>NAME_SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>WIDECHAR</span> <span class=n>WideName</span><span class=p>[</span><span class=n>NAME_SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>继续查看这里的 FNameEntryHeader 结构。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313192828.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313192828.png?size=small" data-sub-html="<h2>20250313192828</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313192828.png alt=FNameEntryHeader srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313192828.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313192828.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313192828.png?size=large 2x" data-title=20250313192828 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>FNameEntryHeader</figcaption></figure>然后看到同文件下的 FNameEntryHeader 结构，它同样存在一个编译运行时才有效的宏，忽略这个宏，它的成员变量如下所示：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>FNameEntryHeader</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>uint16</span> <span class=nl>bIsWide</span> <span class=p>:</span> <span class=mi>1</span><span class=p>;</span>                         <span class=c1>// 标记是否为宽字符（Unicode）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>static</span> <span class=k>constexpr</span> <span class=n>uint32</span> <span class=n>ProbeHashBits</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span>  <span class=c1>// 哈希值位数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>uint16</span> <span class=nl>LowercaseProbeHash</span> <span class=p>:</span> <span class=n>ProbeHashBits</span><span class=p>;</span>  <span class=c1>// 小写哈希值（5 位）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>uint16</span> <span class=nl>Len</span> <span class=p>:</span> <span class=mi>10</span><span class=p>;</span>                            <span class=c1>// 字符串长度（最大 1023）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><p>那么真实结构如下所示，这里展示的是小端序的结构。这个结构指示了该字符串是否为宽字符，同时保存了字符串哈希，字符串长度，总共使用 2 字节空间。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>| bIsWide (1 bit) | LowercaseProbeHash (5 bits) | Len (10 bits) |
</span></span><span class=line><span class=cl>| --------------- | --------------------------- | ------------- |</span></span></code></pre></td></tr></table></div></div><p>这里就知道 FNameEntryHeader 是一个两字节的数据，存储字符串的标识和长度等信息。后面就分析 FNameEntry 剩余的联合体，从代码中可以看出它根据 FNameEntryHeader 的 bIsWide 来存储普通单字节字符或宽字符。这里 ANSICHAR 就是 char，占据 8 bit 一个字节，而 WIDECHAR 就是 wchar_t，占据 16 bit 两个字节。</p><h4 id=函数解析 class=heading-element><span>函数解析</span>
<a href=#%e5%87%bd%e6%95%b0%e8%a7%a3%e6%9e%90 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>继续回到对 <code>DebugDumpBlock()</code> 的解析，可以看到 End 的获取需要 <code>FNameEntry::GetDataOffset()</code> 函数的值。找到的与这个函数相关的代码如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>int32</span> <span class=n>FNameEntry</span><span class=o>::</span><span class=n>GetDataOffset</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nf>STRUCT_OFFSET</span><span class=p>(</span><span class=n>FNameEntry</span><span class=p>,</span> <span class=n>AnsiName</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#define STRUCT_OFFSET( struc, member )	offsetof(struc, member)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define offsetof(s,m) ((::size_t)&amp;reinterpret_cast&lt;char const volatile&amp;&gt;((((s*)0)-&gt;m)))</span></span></span></code></pre></td></tr></table></div></div><p>这里最后就是调用 offsetof 宏，而它的本质就是计算结构体/类中成员变量相对于对象起始地址的字节偏移量。这样根据代码，这个函数的目的就是获取 AnsiName 变量在 FNameEntry 结构体中的偏移，而它的前面只有 FNameEntryHeader 结构体，因此这个函数返回 2。这里对于 End 需要再多减去这个 FNameEntryHeader 存在疑惑，不知道为什么需要减去这个 2 字节，然后找到了下面的 Block 分配算法。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250713112743.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250713112743.png?size=small" data-sub-html="<h2>20250713112743</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250713112743.png alt="Block 分配" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250713112743.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250713112743.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250713112743.png?size=large 2x" data-title=20250713112743 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>Block 分配</figcaption></figure>这里可以看出分配 NewBlock 时就需要判断 <code>CurrentByteCursor + FNameEntry::GetDataOffset()</code> 的大小，因此这个 End 的计算也是根据分配算法来的。因此我觉得这里是把一个 Block 的最后两个字节视为无效内存区域，因为一个 FNameEntry 最少需要两个字节。所以这里就通过两个字节来判断 Block 的终止。</p><p>然后继续看 <code>DebugDumpBlock()</code> 的代码，它先是把 It 转化为 FNameEntry 结构体类型，然后判断其中 FNameEntryHeader 的长度是否为零，若不是，那么就进行记录。最后通过 <code>FNameEntry::GetSize(Len, !Entry->IsWide())</code> 寻找下一个 FNameEntry 结构。这里找到的相关代码如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>int32</span> <span class=n>FNameEntry</span><span class=o>::</span><span class=n>GetSize</span><span class=p>(</span><span class=n>int32</span> <span class=n>Length</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>bIsPureAnsi</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>int32</span> <span class=n>Bytes</span> <span class=o>=</span> <span class=n>GetDataOffset</span><span class=p>()</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>                <span class=n>Length</span> <span class=o>*</span> <span class=p>(</span><span class=n>bIsPureAnsi</span> <span class=o>?</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>ANSICHAR</span><span class=p>)</span> <span class=o>:</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>WIDECHAR</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nf>Align</span><span class=p>(</span><span class=n>Bytes</span><span class=p>,</span> <span class=k>alignof</span><span class=p>(</span><span class=n>FNameEntry</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Aligns a value to the nearest higher multiple of &#39;Alignment&#39;, which must be a power of two.
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * @param  Val        The value to align.
</span></span></span><span class=line><span class=cl><span class=cm> * @param  Alignment  The alignment value, must be a power of two.
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * @return The value aligned up to the specified alignment.
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>FORCEINLINE</span> <span class=k>constexpr</span> <span class=n>T</span> <span class=n>Align</span><span class=p>(</span><span class=n>T</span> <span class=n>Val</span><span class=p>,</span> <span class=n>uint64</span> <span class=n>Alignment</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>static_assert</span><span class=p>(</span><span class=n>TIsIntegral</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>Value</span> <span class=o>||</span> <span class=n>TIsPointer</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>Value</span><span class=p>,</span> <span class=s>&#34;Align expects an integer or pointer type&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=p>(</span><span class=n>T</span><span class=p>)(((</span><span class=n>uint64</span><span class=p>)</span><span class=n>Val</span> <span class=o>+</span> <span class=n>Alignment</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>&amp;</span> <span class=o>~</span><span class=p>(</span><span class=n>Alignment</span> <span class=o>-</span> <span class=mi>1</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>由这里的代码可以知道，Bytes 是根据是否为宽字符来计算字符的字节数，然后加上之前获取的 2 字节 FNameEntryHeader 而得到的，然后经过 <code>Align()</code> 函数进行内存对齐，这里是对齐到 2 字节的倍数。因为 FNameEntry 中存在 FNameEntryHeader 这个数据，它大小为 2 字节，同时 Union 中的 ANSICHAR 和 WIDECHAR 一个 1 字节，一个 2 字节，所以会满足最大对齐要求，对齐到 2 字节的倍数。</p><p>由此解析完函数可以知道 UE 中字符串的存储结构。首先字符串都是存储在 GName，也就是全局唯一的 FNamePool 中，它内部第一个成员变量 FNameEntryAllocator 中的 Blocks 数组就是实际存储字符串相关数据的地方。这里的结构是 <code>uint8* Blocks[]</code>，因此这个数组实际存储一个个 Block 的指针，然后通过解析指针可以知道每个 Block 的地址。而在实际的 Block 中，字符串按照 FNameEntry 的结构逐一排布，同时对齐到 2 字节的倍数，也就是若这个结构是奇数，后面就会添加一个字节的 0x00 进行内存对齐。而在 FNameEntry 中，分为两个字节的 FNameEntryHeader 和后面的字符串，前面的结构指明字符串是否为宽字符，字符串的长度和哈希值，这样就可以通过解析前面的结构获取字符串的信息，从而成功读取字符串。</p><h2 id=getname-算法 class=heading-element><span>GetName 算法</span>
<a href=#getname-%e7%ae%97%e6%b3%95 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>GetName</div><div class=details-content><div class=admonition-content><p>在 UE 中，所有对象和类都有其名字，它们的名称存储在上文获取 Strings 过程中提到的 Block 中。这里 FNamePool 管理着引擎中所有唯一字符串标识符（FName）的存储池，可以通过字符串标识符来获取字符串，同时对象和类的结构中就存储着对应的字符串标识符，这样保证了可以在获取类和对象时就知道它对应的字符串名称，而这里通过字符串标识符获取字符串的算法就是 GetName 算法。</p></div></div></div><h3 id=获取字符串 class=heading-element><span>获取字符串</span>
<a href=#%e8%8e%b7%e5%8f%96%e5%ad%97%e7%ac%a6%e4%b8%b2 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>在 FName 中存在函数 <code>ToString()</code>，它就是通过唯一标识符获取字符串的函数，也就是 GetName 算法的实现函数。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313131322.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313131322.png?size=small" data-sub-html="<h2>20250313131322</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313131322.png alt=ToString() srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313131322.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313131322.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313131322.png?size=large 2x" data-title=20250313131322 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>ToString()</figcaption></figure>然后继续找到这个函数的定义，发现它就是调用了 <code>GetDisplayNameEntry()->GetPlainNameString()</code> 来实现功能。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313131758.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313131758.png?size=small" data-sub-html="<h2>20250313131758</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313131758.png alt=ToString() srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313131758.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313131758.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313131758.png?size=large 2x" data-title=20250313131758 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>ToString()</figcaption></figure></p><h4 id=相关结构 class=heading-element><span>相关结构</span>
<a href=#%e7%9b%b8%e5%85%b3%e7%bb%93%e6%9e%84 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><h5 id=fstring class=heading-element><span>FString</span>
<a href=#fstring class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>这里函数的返回值为 FString，它是一个动态大小的字符串类，用于存储和操作字符串数据。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305182228.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305182228.png?size=small" data-sub-html="<h2>20250305182228</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305182228.png alt=FString srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305182228.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305182228.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305182228.png?size=large 2x" data-title=20250305182228 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>FString</figcaption></figure>上图就是 FString 这个类的结构，这里 CORE_API 用于处理模块间的符号导入/导出，于结构分析无益。然后提取这个类的变量可以知道，它只有一个 DataType 类型的成员变量 Data。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>CORE_API</span> <span class=n>FString</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=cm>/** Array holding the character data */</span>
</span></span><span class=line><span class=cl>	<span class=k>typedef</span> <span class=n>TArray</span><span class=o>&lt;</span><span class=n>TCHAR</span><span class=o>&gt;</span> <span class=n>DataType</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>DataType</span> <span class=n>Data</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>而这里的 DataType 其实就是 <code>TArray&lt;TCHAR></code> 类型，因此继续查看这两个结构。</p><h5 id=tarray class=heading-element><span>TArray</span>
<a href=#tarray class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305184237.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305184237.png?size=small" data-sub-html="<h2>20250305184237</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305184237.png alt=TArray srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305184237.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305184237.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305184237.png?size=large 2x" data-title=20250305184237 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>TArray</figcaption></figure>首先就是分析 TArray 结构，它是 UE 的动态数组容器，类似于 <code>std::vector</code>，提取出来的关键结构如下所示。这里 ElementAllocatorType 是 TArray 的内存分配器类型，其具体类型由模板参数 Allocator 决定。而 SizeType 是 TArray 的元素计数和索引类型，其类型由分配器的 SizeType 决定。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>SizeType</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>TArray</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>typedef</span> <span class=k>typename</span> <span class=n>TChooseClass</span><span class=o>&lt;</span>
</span></span><span class=line><span class=cl>		<span class=n>Allocator</span><span class=o>::</span><span class=n>NeedsElementType</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=k>typename</span> <span class=n>Allocator</span><span class=o>::</span><span class=k>template</span> <span class=n>ForElementType</span><span class=o>&lt;</span><span class=n>ElementType</span><span class=o>&gt;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=k>typename</span> <span class=n>Allocator</span><span class=o>::</span><span class=n>ForAnyElementType</span>
</span></span><span class=line><span class=cl>	<span class=o>&gt;::</span><span class=n>Result</span> <span class=n>ElementAllocatorType</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>ElementAllocatorType</span> <span class=n>AllocatorInstance</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>SizeType</span>             <span class=n>ArrayNum</span><span class=p>;</span>          <span class=c1>//记录当前数组内元素的实际个数
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>SizeType</span>             <span class=n>ArrayMax</span><span class=p>;</span>          <span class=c1>//记录当前数组最大可容纳元素的数量
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>根据 TArray 的结构，可以知道它通过传递的 TCHAR 结构来开辟容器的大小。</p><h5 id=tchar class=heading-element><span>TCHAR</span>
<a href=#tchar class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>这里 TCHAR 在不同的平台上定义不一样，然后可以找到 Android 平台下的相关定义如下。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250725220437.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250725220437.png?size=small" data-sub-html="<h2>20250725220437</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250725220437.png alt=20250725220437 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250725220437.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250725220437.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250725220437.png?size=large 2x" data-title=20250725220437 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>20250725220437</figcaption></figure>这里直接可以看出这个 TCHAR 就是 char16_t 类型，和 Windows 平台的定义一样，都是专门用于表示 UTF-16 编码的 Unicode 字符，占用 2 字节内存空间。</p><p>由此可以知道 FString 就是就是一个存储字符串的动态数组容器，每个字符占用 2 字节。</p><h4 id=getdisplaynameentry class=heading-element><span>GetDisplayNameEntry</span>
<a href=#getdisplaynameentry class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>首先看 <code>GetDisplayNameEntry()</code> 这个函数，它的实现如下图所示。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313132357.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313132357.png?size=small" data-sub-html="<h2>20250313132357</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313132357.png alt=GetDisplayNameEntry() srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313132357.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313132357.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313132357.png?size=large 2x" data-title=20250313132357 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>GetDisplayNameEntry()</figcaption></figure>这个函数的返回值是上文提到的 FNameEntry 结构，它是 Block 中字符串存储的结构。那么该函数返回这个类型就说明 <code>GetPlainNameString()</code> 函数应该是 FNameEntry 类的函数，负责将 FNameEntry 转化为 FString 结构。这里该函数只是调用 <code>GetNamePool()</code>，<code>Resolve()</code>，<code>GetDisplayIndex()</code> 三个函数，因此继续查看这三个函数。</p><h5 id=getnamepool class=heading-element><span>GetNamePool</span>
<a href=#getnamepool class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313132859.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313132859.png?size=small" data-sub-html="<h2>20250313132859</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313132859.png alt=GetNamePool() srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313132859.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313132859.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313132859.png?size=large 2x" data-title=20250313132859 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>GetNamePool()</figcaption></figure>这个函数是一个单例模式的函数，也就是在 so 中存在唯一的全局变量 NamePoolData，它的类型为 FNamePool。</p><ul><li><code>static bool bNamePoolInitialized;</code>：声明了一个静态布尔变量 bNamePoolInitialized，用于跟踪 FNamePool 实例是否已经被初始化。</li><li><code>alignas(FNamePool) static uint8 NamePoolData[sizeof(FNamePool)];</code>：声明了一个静态数组 NamePoolData，其大小等于 FNamePool 类的大小，并使用 alignas 关键字确保这个数组按照 FNamePool 的内存对齐要求进行对齐。这个数组将用作 FNamePool 实例的内存空间。</li><li><code>GetNamePool()</code>：这个函数用于返回 FNamePool 的实例，如果未被初始化则初始化。</li></ul><p>这个模式保证了即使在多线程环境下，FNamePool 也只会被初始化一次。它不使用 C++11 中的魔法静态（magic statics）或单例模式中的锁，以减少运行时的开销。通过这种方式，FNamePool 类的实例在第一次调用 GetNamePool 时被创建，并在随后的调用中直接返回，避免了重复初始化。</p><p>由此可以看出这个函数就是用来初始化 FNamePool 实例的，也就是 NamePoolData 这个数组，同时它只会初始化一次。同时上文提到的 GName 就是用内存池 FNamePool 来定义的。所以由此可以知道，FNamePoll 会定义一个全局静态变量 NamePoolData 数组，这个数组就是上文提到的 GName，它存储了全局的字符串，相当于一个字符串池，这里的 <code>ToString()</code> 函数就依赖这个数组获取字符串名字。</p><h5 id=getdisplayindex class=heading-element><span>GetDisplayIndex</span>
<a href=#getdisplayindex class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313160335.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313160335.png?size=small" data-sub-html="<h2>20250313160335</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313160335.png alt=GetDisplayIndex() srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313160335.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313160335.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313160335.png?size=large 2x" data-title=20250313160335 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>GetDisplayIndex()</figcaption></figure>这里就是调用了 <code>GetDisplayIndexFast()</code> 函数，然后返回了一个 FNameEntryId 类型的 Index。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305130947.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305130947.png?size=small" data-sub-html="<h2>20250305130947</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305130947.png alt=FNameEntryId srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305130947.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305130947.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305130947.png?size=large 2x" data-title=20250305130947 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>FNameEntryId</figcaption></figure>FNameEntryId 这个类型内部只有一个成员变量 <code>uint32 Value;</code>，具体如下所示。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>FNameEntryId</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>uint32</span> <span class=n>Value</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>这里 FName 提供名字字符串，同时上文也讲到 UE 中字符串和唯一标识符进行绑定，而这两个之间的桥梁就是字符串标识符。它就是一个 FNameEntryId 类型数据，也就是一个 uint32 类型的数字。这个字符串标识符指向了 FNamePool 中的名称条目，我们可以通过解析 UE 中提供的算法来将这个标识符转化为对应的字符串。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313161823.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313161823.png?size=small" data-sub-html="<h2>20250313161823</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313161823.png alt=GetDisplayIndexFast() srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313161823.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313161823.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313161823.png?size=large 2x" data-title=20250313161823 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>GetDisplayIndexFast()</figcaption></figure>然后查看 <code>GetDisplayIndexFast()</code> 函数。这里有相关宏定义，由注释可以知道这个宏只用于编译器，而在实际运行中不会启用。因此这里的 <code>GetDisplayIndexFast()</code> 函数实际返回的就是 ComparisonIndex，而这个变量有两处被定义，其中一处就是作为 FName 的成员变量。同时它的类型也是 FNameEntryId 类型，所以可以知道 ComparisonIndex 只是存储了一个 uint32 的值，它是字符串在 GName 中的索引。</p><h5 id=resolve class=heading-element><span>Resolve</span>
<a href=#resolve class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313163154.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313163154.png?size=small" data-sub-html="<h2>20250313163154</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313163154.png alt=Resolve() srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313163154.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313163154.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313163154.png?size=large 2x" data-title=20250313163154 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>Resolve()</figcaption></figure>由上图可以看到该函数调用了 <code>Entries.Resolve()</code> 函数。由上文 Strings dump 可知，这个 Entries 的类型为 FNameEntryAllocator，所以继续寻找这个类得到了函数的实现。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313165045.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313165045.png?size=small" data-sub-html="<h2>20250313165045</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313165045.png alt=Resolve() srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313165045.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313165045.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313165045.png?size=large 2x" data-title=20250313165045 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>Resolve()</figcaption></figure>这个函数的参数为 FNameEntryHandle 类型，然后查看其函数实现。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313164532.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313164532.png?size=small" data-sub-html="<h2>20250313164532</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313164532.png alt=FNameEntryHandle srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313164532.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313164532.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313164532.png?size=large 2x" data-title=20250313164532 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>FNameEntryHandle</figcaption></figure>将该结构简化之后就是下面的呈现方式，同时获取了相关未知值，例如 FNameBlockOffsetBits，它在类的上方被定义，是个常量。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/** Remember to update natvis if you change these */</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>constexpr</span> <span class=n>uint32</span> <span class=n>FNameBlockOffsetBits</span> <span class=o>=</span> <span class=mi>16</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>constexpr</span> <span class=n>uint32</span> <span class=n>FNameBlockOffsets</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>FNameBlockOffsetBits</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/** An unpacked FNameEntryId */</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>FNameEntryHandle</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>uint32</span> <span class=n>Block</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>uint32</span> <span class=n>Offset</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>FNameEntryHandle</span><span class=p>(</span><span class=n>uint32</span> <span class=n>InBlock</span><span class=p>,</span> <span class=n>uint32</span> <span class=n>InOffset</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=o>:</span> <span class=n>Block</span><span class=p>(</span><span class=n>InBlock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>,</span> <span class=n>Offset</span><span class=p>(</span><span class=n>InOffset</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>FNameEntryHandle</span><span class=p>(</span><span class=n>FNameEntryId</span> <span class=n>Id</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=o>:</span> <span class=n>Block</span><span class=p>(</span><span class=n>Id</span><span class=p>.</span><span class=n>ToUnstableInt</span><span class=p>()</span> <span class=o>&gt;&gt;</span> <span class=n>FNameBlockOffsetBits</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>,</span> <span class=n>Offset</span><span class=p>(</span><span class=n>Id</span><span class=p>.</span><span class=n>ToUnstableInt</span><span class=p>()</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>FNameBlockOffsets</span> <span class=o>-</span> <span class=mi>1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>查看这个结构可以发现，FNameEntryHandle 的构造函数有两种，但都是传入 Block 的 id 和块内 offset，一种是直接传入，一种通过 FNameEntryId 传入。这里知道 FNameEntryId 其实就是上文说的字符串标识符，它指向了 Block 中对应的 FNameEntry 结构，同时由 <code>GetDisplayIndex()</code> 的返回值也是这个类型可以知道，它这里就是通过第二个构造函数来进行类型转化。</p><p>然后继续查看这个函数，发现它和上文的 Strings dump 的流程类似，都是根据偏移在 Block 中获取 FNameEntry 类型数据。因此这里的过程就是调用 <code>GetNamePool()</code> 得到了 GName，然后由 <code>GetDisplayIndex()</code> 函数获取字符串索引 <code>FNameEntryId ComparisonIndex</code>，之后根据索引调用 <code>Entries.Resolve()</code> 函数在 Blocks 中找出对应的包装字符串的 FNameEntry 类型数据。</p><h4 id=getplainnamestring class=heading-element><span>GetPlainNameString</span>
<a href=#getplainnamestring class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313195030.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313195030.png?size=small" data-sub-html="<h2>20250313195030</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313195030.png alt=GetPlainNameString srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313195030.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313195030.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313195030.png?size=large 2x" data-title=20250313195030 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>GetPlainNameString</figcaption></figure>然后看 GetPlainNameString 函数，它是 FNameEntry 类的函数，那么这里的 Header 就是上文 FNameEntry 中的 <code>FNameEntryHeader Header;</code>，它利用变量 bIsWide 来判断是否为宽字符，然后根据这个判断返回对应类型的字符串。之后可以看同文件下的 <code>GetUnterminatedName()</code> 函数，它的作用只是返回 FNameEntry 中存储的对应类型字符串。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313195352.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313195352.png?size=small" data-sub-html="<h2>20250313195352</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313195352.png alt=GetUnterminatedName() srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313195352.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313195352.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313195352.png?size=large 2x" data-title=20250313195352 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>GetUnterminatedName()</figcaption></figure></p><h3 id=总结 class=heading-element><span>总结</span>
<a href=#%e6%80%bb%e7%bb%93 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>这里的 <code>ToString()</code> 函数会调用关键函数 <code>GetDisplayNameEntry()->GetPlainNameString()</code>，而 <code>GetDisplayNameEntry()</code> 又依次调用 <code>GetNamePool()</code>，<code>GetDisplayIndex()</code>，<code>Resolve()</code> 三个函数。</p><ul><li><code>GetNamePool()</code> 函数主要用于初始化并返回 <code>FNamePool NamePoolData</code>，这个 NamePoolData 就是之前找的 GName。</li><li><code>GetDisplayIndex()</code> 主要用于返回对象名称的索引，它返回类型为 FNameEntryId，其成员变量只有一个 <code>uint32 Value;</code>。同时此函数内部调用 <code>GetDisplayIndexFast()</code> 获取 ComparisonIndex，该索引值直接存储在 FName 对象中，可通过 UObjectBase 的 NamePrivate 成员直接提取。</li><li><code>Resolve()</code> 根据索引从名称池中解析出对应的目录项，返回 FNameEntry 对象。此对象通过 bIsWide 判断字符串编码类型，并通过联合体兼容不同编码的字符串存储。</li></ul><p>最后 <code>Resolve()</code> 返回的 FNameEntry 对象将调用 <code>GetPlainNameString()</code> 方法，将内部存储的原始字符串转换为 FString 类型输出。此过程根据 bIsWide 标志自动选择字符编码处理逻辑，确保字符串内容的准确性。</p><h2 id=actors-获取 class=heading-element><span>Actors 获取</span>
<a href=#actors-%e8%8e%b7%e5%8f%96 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>Actors</div><div class=details-content><div class=admonition-content><p>在 UE 中，每一个物体就是一个可交互对象，它们这些对象就是 Actor。所有首先需要知道这些对象（包括玩家）都是哪些 Actor，才能针对不同的 Actor 进行不同的操作。这里首先获取每个 Actor 的名称，而要获取名称，那么需要知道每个 Actor 的地址，然后再通过 Actor 的结构解析出它的地址。具体而言，这里首先通过 GWorld 获取 Actors 的地址，然后根据地址解析结构，获取 actorID，之后根据这个 actorID 从 GName 开始寻找，获取 Actor 的名称。这里可以查看源码知道具体的流程。</p></div></div></div><h3 id=获取地址 class=heading-element><span>获取地址</span>
<a href=#%e8%8e%b7%e5%8f%96%e5%9c%b0%e5%9d%80 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>这里所有的 Actors 都存储在 ULevel 的结构中，而 ULevel 就是通过 GWorld 获取的。在上文的介绍中，GWorld 是 UE 中的一个全局指针变量，是指向 UWorld 的指针，代表当前的世界实例。所有可以把 GWorld 理解为 UWorld 类。</p><h4 id=uworld class=heading-element><span>UWorld</span>
<a href=#uworld class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305111155.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305111155.png?size=small" data-sub-html="<h2>20250305111155</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305111155.png alt=UWorld srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305111155.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305111155.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305111155.png?size=large 2x" data-title=20250305111155 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>UWorld</figcaption></figure>上述是 UWorld 的结构，但是在实际运行环境中 UWorld 的第一个成员是 <code>ULevel* PersistentLevel</code>，可表示成下面的形式。这里 ENGINE_API 是一个模块导出宏，用于控制 Engine 模块的符号可见性。在 Windows 平台上被定义为 <code>__declspec(dllexport)</code>，表示将类或函数导出为 DLL 的公共符号；而在其他平台为空，这些平台不需要显式导出符号。而 <code>UPROPERTY(Transient)</code> 是 Unreal Engine 的属性修饰符，用于标记一个成员变量为临时变量，避免序列化和网络同步，这里可以不加理会。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>ENGINE_API</span> <span class=n>UWorld</span> <span class=k>final</span> <span class=o>:</span> <span class=k>public</span> <span class=n>UObject</span><span class=p>,</span> <span class=k>public</span> <span class=n>FNetworkNotify</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/** Persistent level containing the world info, default brush and actors spawned during gameplay among other things			*/</span>
</span></span><span class=line><span class=cl>	<span class=n>UPROPERTY</span><span class=p>(</span><span class=n>Transient</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>class</span> <span class=nc>ULevel</span><span class=o>*</span>								<span class=n>PersistentLevel</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>这里 PersistentLevel 是一个指向 ULevel 的指针，表示持久化关卡。它是 UWorld 的核心成员之一，负责管理关卡中的 Actor、光照、BSP 等内容。</p><h4 id=ulevel class=heading-element><span>ULevel</span>
<a href=#ulevel class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305152202.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305152202.png?size=small" data-sub-html="<h2>20250305152202</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305152202.png alt=ULevel srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305152202.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305152202.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305152202.png?size=large 2x" data-title=20250305152202 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>ULevel</figcaption></figure>然后查看这个 ULevel 类，可以发现它这里存在 <code>TArray&lt;AActor*> Actors;</code>，而这个就是存储 Actors 的结构，由此获取这个结构也就是得到了 Actors 的地址。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>ULevel</span> <span class=o>:</span> <span class=k>public</span> <span class=n>UObject</span><span class=p>,</span> <span class=k>public</span> <span class=n>IInterface_AssetUserData</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=cm>/** URL associated with this level. */</span>
</span></span><span class=line><span class=cl>	<span class=n>FURL</span>					<span class=n>URL</span><span class=p>;</span>                <span class=c1>//存储协议相关配置，以及地图等选项
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=cm>/** Array of all actors in this level, used by FActorIteratorBase and derived classes */</span>
</span></span><span class=line><span class=cl>	<span class=n>TArray</span><span class=o>&lt;</span><span class=n>AActor</span><span class=o>*&gt;</span> <span class=n>Actors</span><span class=p>;</span>                     <span class=c1>//存储所有Actors
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h3 id=获取名称 class=heading-element><span>获取名称</span>
<a href=#%e8%8e%b7%e5%8f%96%e5%90%8d%e7%a7%b0 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><h4 id=获取唯一标识符 class=heading-element><span>获取唯一标识符</span>
<a href=#%e8%8e%b7%e5%8f%96%e5%94%af%e4%b8%80%e6%a0%87%e8%af%86%e7%ac%a6 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>在上文 Strings dump 的过程中，我们知道 UE 中每一个字符串都有一个唯一标识符，可以通过这个标识符来找到对应的字符串。那么相应的，Actor 的名称也是一个字符串，我们可以找到这个唯一标识符获取 Actor 的名称。</p><h5 id=tarray-1 class=heading-element><span>TArray</span>
<a href=#tarray-1 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305184237.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305184237.png?size=small" data-sub-html="<h2>20250305184237</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305184237.png alt=TArray srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305184237.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305184237.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305184237.png?size=large 2x" data-title=20250305184237 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>TArray</figcaption></figure>首先就是分析 TArray 结构，它是一个动态数组模板类，提取出来的关键结构如下所示。这里 ElementAllocatorType 是 TArray 的内存分配器类型，其具体类型由模板参数 Allocator 决定。而 SizeType 是 TArray 的元素计数和索引类型，其类型由分配器的 SizeType 决定。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>SizeType</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>TArray</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>typedef</span> <span class=k>typename</span> <span class=n>TChooseClass</span><span class=o>&lt;</span>
</span></span><span class=line><span class=cl>		<span class=n>Allocator</span><span class=o>::</span><span class=n>NeedsElementType</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=k>typename</span> <span class=n>Allocator</span><span class=o>::</span><span class=k>template</span> <span class=n>ForElementType</span><span class=o>&lt;</span><span class=n>ElementType</span><span class=o>&gt;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=k>typename</span> <span class=n>Allocator</span><span class=o>::</span><span class=n>ForAnyElementType</span>
</span></span><span class=line><span class=cl>	<span class=o>&gt;::</span><span class=n>Result</span> <span class=n>ElementAllocatorType</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>ElementAllocatorType</span> <span class=n>AllocatorInstance</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>SizeType</span>             <span class=n>ArrayNum</span><span class=p>;</span>          <span class=c1>//记录当前数组内元素的实际个数
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>SizeType</span>             <span class=n>ArrayMax</span><span class=p>;</span>          <span class=c1>//记录当前数组最大可容纳元素的数量
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>由此可知这个 TArray 只是数组的包装类型，Actors 数组存储着连续的指向 AActor 的指针 <code>AActor*</code>，AActor 就是 Actor 的具体类型。</p><h5 id=aactor class=heading-element><span>AActor</span>
<a href=#aactor class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250306205942.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250306205942.png?size=small" data-sub-html="<h2>20250306205942</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250306205942.png alt=AActor srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250306205942.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250306205942.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250306205942.png?size=large 2x" data-title=20250306205942 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>AActor</figcaption></figure>由上图可以看出 AActor 继承 UObject 类，这说明每一个 Actor 都是 UE 中的一个对象。而 UObject 又继承 UObjectBase 类。</p><h5 id=uobjectbase class=heading-element><span>UObjectBase</span>
<a href=#uobjectbase class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305122209.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305122209.png?size=small" data-sub-html="<h2>20250305122209</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305122209.png alt=UObjectBase srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305122209.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305122209.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305122209.png?size=large 2x" data-title=20250305122209 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>UObjectBase</figcaption></figure>UObjectBase 这个类就是顶级类了，其中也定义了相关的成员变量，可以简化为下面的形式。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>COREUOBJECT_API</span> <span class=n>UObjectBase</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>VTable</span><span class=p>;</span>                                        <span class=c1>//虚表指针，自己添加的
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=cm>/** Flags used to track and report various object states. This needs to be 8 byte aligned on 32-bit
</span></span></span><span class=line><span class=cl><span class=cm>	    platforms to reduce memory waste */</span>
</span></span><span class=line><span class=cl>	<span class=n>EObjectFlags</span>					<span class=n>ObjectFlags</span><span class=p>;</span>            <span class=c1>//对象属性
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=cm>/** Index into GObjectArray...very private. */</span>
</span></span><span class=line><span class=cl>	<span class=n>int32</span>							<span class=n>InternalIndex</span><span class=p>;</span>          <span class=c1>//对象 GUObjectArray 序号
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=cm>/** Class the object belongs to. */</span>
</span></span><span class=line><span class=cl>	<span class=n>UClass</span><span class=o>*</span>							<span class=n>ClassPrivate</span><span class=p>;</span>           <span class=c1>//对象的类
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=cm>/** Name of this object */</span>
</span></span><span class=line><span class=cl>	<span class=n>FName</span>							<span class=n>NamePrivate</span><span class=p>;</span>            <span class=c1>//对象的名字
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=cm>/** Object this object resides in. */</span>
</span></span><span class=line><span class=cl>	<span class=n>UObject</span><span class=o>*</span>						<span class=n>OuterPrivate</span><span class=p>;</span>           <span class=c1>//对象所在UPackage
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h5 id=fname class=heading-element><span>FName</span>
<a href=#fname class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>这里查看 FName，它是一个轻量级的字符串类型，用于表示对象的名称。在这里就可以看出，正是因为 UE 中所有对象都继承自 UObject 这个类，同时这个类又有成员变量 FName 提供名字，所以 UE 的反射系统才能方便知道一个对象的名字、字段、函数参数等信息。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305125139.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305125139.png?size=small" data-sub-html="<h2>20250305125139</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305125139.png alt=FName srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305125139.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305125139.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305125139.png?size=large 2x" data-title=20250305125139 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>FName</figcaption></figure>然后忽略编译条件宏包裹的变量后提取的成员变量如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>CORE_API</span> <span class=n>FName</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=cm>/** Index into the Names array (used to find String portion of the string/number pair used for comparison) */</span>
</span></span><span class=line><span class=cl>	<span class=n>FNameEntryId</span>	<span class=n>ComparisonIndex</span><span class=p>;</span>        <span class=c1>//指向 FNamePool 中的名称条目
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=cm>/** Number portion of the string/number pair (stored internally as 1 more than actual, so zero&#39;d memory will be the default, no-instance case) */</span>
</span></span><span class=line><span class=cl>	<span class=n>uint32</span>			<span class=n>Number</span><span class=p>;</span>                 <span class=c1>//用于区分同名对象的编号
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>这里 FNameEntryId 和 FName 在同一个文件中被定义。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305130947.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305130947.png?size=small" data-sub-html="<h2>20250305130947</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305130947.png alt=FNameEntryId srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305130947.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305130947.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305130947.png?size=large 2x" data-title=20250305130947 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>FNameEntryId</figcaption></figure>它只有一个成员变量 Value，具体如下所示。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>FNameEntryId</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>uint32</span> <span class=n>Value</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>这里 FName 提供名字字符串，同时上文也讲到 UE 中字符串和唯一标识符进行绑定，而这两个之间的桥梁就是 ComparisonIndex。它是一个 FNameEntryId 类型数据，也就是一个 uint32 类型的数字。这个 ComparisonIndex 指向了 FNamePool 中的名称条目，我们可以通过解析 UE 中提供的算法来将这个标识符转化为对应的字符串。</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2025-07-08 22:08:14">更新于 2025.7.8&nbsp;</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href="https://github.com/czTangt/blog.git/blob/main/content/posts%5candroid%5cUE_structure.md?plain=1" title=查看源码 target=_blank rel="external nofollow noopener noreferrer" class=link-to-source>查看源码</a></span><span><a href=https://github.com/czTangt/blog.git/edit/main/content/posts%5candroid%5cUE_structure.md title=编辑此页 target=_blank rel="external nofollow noopener noreferrer" class=link-to-edit>编辑此页</a></span><span><a href="https://github.com/czTangt/blog.git/issues/new?title=[BUG]%20UE+%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90&amp;body=%7cField%7cValue%7c%0A%7c-%7c-%7c%0A%7cTitle%7cUE+%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90%7c%0A%7cURL%7chttps://czTangt.github.io/blog/posts/android/ue-structure/%7c%0A%7cFilename%7chttps://github.com/czTangt/blog.git/blob/main/content/posts%5candroid%5cUE_structure.md?plain=1%7c" title=报告问题 target=_blank rel="external nofollow noopener noreferrer" class=link-to-report>报告问题</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 X" data-sharer=twitter data-url=https://czTangt.github.io/blog/posts/android/ue-structure/ data-title="UE 结构分析" data-hashtags=android,game><i class="fa-brands fa-x-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://czTangt.github.io/blog/posts/android/ue-structure/ data-hashtag=android><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://czTangt.github.io/blog/posts/android/ue-structure/ data-title="UE 结构分析"><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/blog/tags/android/ class=post-tag title="标签 - Android">Android</a><a href=/blog/tags/game/ class=post-tag title="标签 - Game">Game</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/blog/>主页</a></span></section></div><div class=post-nav><a href=/blog/posts/android/2024-tencent-gamesec-final/ class=post-nav-item rel=prev title=2024腾讯游戏安全竞赛决赛><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>2024腾讯游戏安全竞赛决赛</a></div></div></article><aside class=toc id=toc-auto aria-label=目录><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside></main><footer class=footer><div class=footer-container><div class="footer-line powered order-1">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.136.5"><img class=hugo-icon src=/blog/images/hugo.min.svg alt="Hugo logo"> Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.3.17-30a67c4b"><img class=fixit-icon src=/blog/images/fixit.min.svg alt="FixIt logo"> FixIt</a></div><div class="footer-line copyright order-2" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2024 - 2025</span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class="variant-numeric d-none">0%</span></div></div><a href=https://github.com/czTangt/blog title="View source on GitHub" target=_blank rel="external nofollow" class="github-corner left d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true" width="56" height="56"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><noscript><div class=noscript-warning>该网站在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/blog/lib/lightgallery/css/lightgallery-bundle.min.css><link rel=preload href=/blog/lib/katex/katex.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/blog/lib/katex/katex.min.css></noscript><link rel=stylesheet href=/blog/lib/cookieconsent/cookieconsent.min.css><script src=/blog/lib/autocomplete/autocomplete.min.js defer></script><script src=/blog/lib/fuse/fuse.min.js defer></script><script src=/blog/lib/lightgallery/lightgallery.min.js defer></script><script src=/blog/lib/lightgallery/plugins/thumbnail/lg-thumbnail.min.js defer></script><script src=/blog/lib/lightgallery/plugins/zoom/lg-zoom.min.js defer></script><script src=/blog/lib/sharer/sharer.min.js async defer></script><script src=/blog/lib/katex/katex.min.js defer></script><script src=/blog/lib/katex/auto-render.min.js defer></script><script src=/blog/lib/katex/mhchem.min.js defer></script><script src=/blog/lib/cookieconsent/cookieconsent.min.js defer></script><script src=/blog/js/codeblock.js defer></script><script src=https://libs.baidu.com/jquery/2.1.4/jquery.min.js defer></script><script>window.config={code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:10},comment:{enable:!1},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},lightgallery:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{distance:100,findAllMatches:!1,fuseIndexURL:"/blog/search.json",highlightTag:"em",ignoreFieldNorm:!1,ignoreLocation:!1,isCaseSensitive:!1,location:0,maxResultLength:10,minMatchCharLength:2,noResultsFound:"没有找到结果",snippetLength:30,threshold:.3,type:"fuse",useExtendedSearch:!1},version:"v0.3.17-30a67c4b"}</script><script src=/blog/js/theme.min.js defer></script></body></html>