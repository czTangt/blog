<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>UE 结构分析 - czTang</title><meta name=author content="czTang">
<meta name=description content="这里记录一下对于 UE4.27 SDK 的理解，同时补充完善 2024第九届腾讯游戏安全技术竞赛初赛安卓赛道 中的分析。源码在 SDKDumper。
"><meta name=keywords content='android,game'><meta itemprop=name content="UE 结构分析"><meta itemprop=description content="这里记录一下对于 UE4.27 SDK 的理解，同时补充完善 2024第九届腾讯游戏安全技术竞赛初赛安卓赛道 中的分析。源码在 SDKDumper。"><meta itemprop=datePublished content="2025-07-08T22:08:14+08:00"><meta itemprop=dateModified content="2025-08-01T20:14:13+08:00"><meta itemprop=wordCount content="13043"><meta itemprop=keywords content="Android,Game"><meta property="og:url" content="https://czTangt.github.io/blog/posts/android/ue-structure/"><meta property="og:site_name" content="czTang"><meta property="og:title" content="UE 结构分析"><meta property="og:description" content="这里记录一下对于 UE4.27 SDK 的理解，同时补充完善 2024第九届腾讯游戏安全技术竞赛初赛安卓赛道 中的分析。源码在 SDKDumper。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-07-08T22:08:14+08:00"><meta property="article:modified_time" content="2025-08-01T20:14:13+08:00"><meta property="article:tag" content="Android"><meta property="article:tag" content="Game"><meta name=twitter:card content="summary"><meta name=twitter:title content="UE 结构分析"><meta name=twitter:description content="这里记录一下对于 UE4.27 SDK 的理解，同时补充完善 2024第九届腾讯游戏安全技术竞赛初赛安卓赛道 中的分析。源码在 SDKDumper。"><meta name=application-name content="FixIt"><meta name=apple-mobile-web-app-title content="FixIt"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel=icon href=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410312135963.svg><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical type=text/html href=https://czTangt.github.io/blog/posts/android/ue-structure/ title="UE 结构分析 - czTang"><link rel=prev type=text/html href=https://czTangt.github.io/blog/posts/android/2024-tencent-gamesec-final/ title=2024腾讯游戏安全竞赛决赛><link rel=stylesheet href=/blog/css/style.min.css><link rel=preload href=/blog/lib/fontawesome-free/all.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/blog/lib/fontawesome-free/all.min.css></noscript><link rel=preload href=/blog/lib/animate/animate.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/blog/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"UE 结构分析","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/czTangt.github.io\/blog\/posts\/android\/ue-structure\/"},"genre":"posts","keywords":"android, game","wordcount":13043,"url":"https:\/\/czTangt.github.io\/blog\/posts\/android\/ue-structure\/","datePublished":"2025-07-08T22:08:14+08:00","dateModified":"2025-08-01T20:14:13+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"czTang"},"description":""}</script><script src=/blog/js/head/color-scheme.min.js></script></head><body data-header-desktop=sticky data-header-mobile=auto><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=left><div class=header-title><a href=/blog/ title=czTang><span class=header-title-pre><i class='fa fa-coffee'>&nbsp</i></span><span class=header-title-text>czTang</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/blog/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 归档</a></li><li class=menu-item><a class=menu-link href=/blog/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/blog/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/blog/about/><i class="fa-solid fa-user fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/blog/ title=czTang><span class=header-title-pre><i class='fa fa-coffee'>&nbsp</i></span><span class=header-title-text>czTang</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/blog/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 归档</a></li><li class=menu-item><a class=menu-link href=/blog/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/blog/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/blog/about/><i class="fa-solid fa-user fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=container><aside class="aside-collection animate__animated animate__fadeIn animate__faster" aria-label=合集><div class="details collection-details open"><div class="details-summary collection-summary"><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i>
<span class=collection-name title=合集>Game</span>
<span class=collection-count>3</span><i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class="details-content collection-content"><nav><ul class=collection-list><li class=collection-item><a href=/blog/posts/android/2024-tencent-gamesec-prelim/ title=2024腾讯游戏安全竞赛初赛>2024腾讯游戏安全竞赛初赛</a></li><li class=collection-item><a href=/blog/posts/android/2024-tencent-gamesec-final/ title=2024腾讯游戏安全竞赛决赛>2024腾讯游戏安全竞赛决赛</a></li><li class=collection-item><span class=active title="UE 结构分析">UE 结构分析</span></li></ul><div class=collection-nav-simple><a href=/blog/posts/android/2024-tencent-gamesec-final/ class=collection-nav-item rel=prev title=2024腾讯游戏安全竞赛决赛><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i></a><span class=text-secondary>3/3</span><i class="fa-solid fa-angle-right fa-fw collection-nav-item text-secondary" aria-hidden=true></i></div></nav></div></div></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>UE 结构分析</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/czTangt title=作者 target=_blank rel="external nofollow noopener noreferrer author" class=author><img loading=lazy src=/blog/images/avatar.jpg alt=czTang data-title=czTang width=20 height=20 class=avatar style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'>&nbsp;czTang</a></span><span class=post-included-in>&nbsp;收录于 <a href=/blog/categories/android/ class=post-category title="分类 - Android"><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> Android</a> 和 <a href=/blog/collections/game/ class=post-collection title="合集 - Game"><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i> Game</a></span></div><div class=post-meta-line><span title="发布于 2025-07-08 22:08:14"><i class="fa-solid fa-calendar-days fa-fw me-1" aria-hidden=true></i><time datetime=2025.7.8>2025.7.8</time></span>&nbsp;<span title="更新于 2025-08-01 20:14:13"><i class="fa-regular fa-calendar-check fa-fw me-1" aria-hidden=true></i><time datetime=2025.8.1>2025.8.1</time></span>&nbsp;<span title="13043 字"><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 13100 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 27 分钟</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#基本结构>基本结构</a></li><li><a href=#strings-获取>Strings 获取</a><ul><li><a href=#fnameentryallocator>FNameEntryAllocator</a></li><li><a href=#debugdump>DebugDump</a></li><li><a href=#debugdumpblock>DebugDumpBlock</a><ul><li><a href=#fnameentry>FNameEntry</a></li><li><a href=#函数解析>函数解析</a></li></ul></li></ul></li><li><a href=#getname-算法>GetName 算法</a><ul><li><a href=#获取字符串>获取字符串</a><ul><li><a href=#相关结构>相关结构</a><ul><li><a href=#fstring>FString</a></li><li><a href=#tarray>TArray</a></li><li><a href=#tchar>TCHAR</a></li></ul></li><li><a href=#getdisplaynameentry>GetDisplayNameEntry</a><ul><li><a href=#getnamepool>GetNamePool</a></li><li><a href=#getdisplayindex>GetDisplayIndex</a></li><li><a href=#resolve>Resolve</a></li></ul></li><li><a href=#getplainnamestring>GetPlainNameString</a></li></ul></li><li><a href=#总结>总结</a></li></ul></li><li><a href=#guobject-解析>GUobject 解析</a><ul><li><a href=#获取对象>获取对象</a><ul><li><a href=#相关结构-1>相关结构</a><ul><li><a href=#fuobjectarray>FUObjectArray</a></li><li><a href=#tuobjectarray>TUObjectArray</a></li><li><a href=#fuobjectitem>FUObjectItem</a></li></ul></li><li><a href=#getobjectptr>GetObjectPtr</a></li></ul></li><li><a href=#获取对象名称>获取对象名称</a><ul><li><a href=#uobjectbase>UObjectBase</a></li><li><a href=#fname>FName</a></li></ul></li><li><a href=#获取类名称>获取类名称</a></li><li><a href=#获取属性和方法>获取属性和方法</a><ul><li><a href=#相关知识>相关知识</a><ul><li><a href=#ufield>UField</a></li><li><a href=#ffield>FField</a></li><li><a href=#fproperty>FProperty</a></li><li><a href=#ustruct>UStruct</a></li><li><a href=#uclass>UClass</a></li><li><a href=#总结-1>总结</a></li></ul></li><li><a href=#childproperties>ChildProperties</a></li></ul></li></ul></li><li><a href=#actors-获取>Actors 获取</a><ul><li><a href=#获取地址>获取地址</a><ul><li><a href=#uworld>UWorld</a></li><li><a href=#ulevel>ULevel</a></li></ul></li><li><a href=#获取名称>获取名称</a></li></ul></li></ul></nav></div></div><div class=content id=content><p>这里记录一下对于 UE4.27 SDK 的理解，同时补充完善 <a href=https://gss.tencent.com/competition/2024/race-pre.htm target=_blank rel="external nofollow noopener noreferrer">2024第九届腾讯游戏安全技术竞赛初赛安卓赛道</a> 中的分析。源码在 <a href=https://github.com/czTangt/SDKDumper target=_blank rel="external nofollow noopener noreferrer">SDKDumper</a>。</p><div class="details admonition abstract open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-clipboard-list" aria-hidden=true></i>注意事项</div><div class=details-content><div class=admonition-content><p>为了更好地理解 UE4.27 SDK 的获取，这里根据 <a href=https://bbs.kanxue.com/thread-282857.htm target=_blank rel="external nofollow noopener noreferrer">UE4.27SDK-Dump</a> 的内容对 UE4.27 源码进行分析，同时结合 <a href=https://github.com/hackcatml/frida-ue4dump target=_blank rel="external nofollow noopener noreferrer">frida-ue4dump</a> 和 <a href=https://github.com/revercc/UE4Dumper target=_blank rel="external nofollow noopener noreferrer">UE4Dumper</a> 的代码对 <a href=https://gss.tencent.com/competition/2024/race-pre.htm target=_blank rel="external nofollow noopener noreferrer">2024第九届腾讯游戏安全技术竞赛初赛安卓赛道</a> 的游戏样本进行分析。同时在分析的过程中穿插对于 libUE.so 内存布局的查看，以便应对魔改的情况。</p></div></div></div><h2 id=基本结构 class=heading-element><span>基本结构</span>
<a href=#%e5%9f%ba%e6%9c%ac%e7%bb%93%e6%9e%84 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>查看 <a href=https://github.com/revercc/UE4Dumper target=_blank rel="external nofollow noopener noreferrer">UE4Dumper</a> 的使用指南，可以发现 dump sdk 通常需要 libUE.so 中三个变量的地址 GWorld，GName 和 GUObjectArray（也被称为 GUobject）。</p><ul><li><strong>GWorld</strong>：GWorld 是一个全局变量，其类型为 <code>UWorld**</code>。它存储着指向当前活动游戏世界实例（<code>UWorld*</code>）的指针的地址。<code>*GWorld</code> 提供了访问当前世界（UWorld）的直接指针。UWorld 对象包含了游戏运行时的核心状态，如关卡、Actor 列表、玩家控制器、游戏模式、游戏状态、物理和导航系统等。它是游戏逻辑和对象交互的中心枢纽，是逆向工程中定位游戏状态和对象的起点。</li><li><strong>GName</strong>：GName 是一个全局的 FNamePool 实例。FNamePool 管理着引擎中所有唯一字符串标识符（FName）的存储池。它采用大块内存分配策略，块内划分槽位存储字符串条目。GName 使得通过 FName 的索引或句柄快速查找和比较字符串成为可能，是解析对象类型名、函数名、属性名等字符串的关键。</li><li><strong>GUObjectArray</strong>：GUObjectArray 是一个全局的 FUObjectArray 类型的实例。它是 UE 垃圾回收系统的核心组成部分，是所有 UObject 及其派生类实例的全局容器和注册表。通过遍历 GUObjectArray，可以枚举、跟踪和管理引擎中存在的所有 UObject 实例。</li></ul><p>在获取这些变量的地址之后，就可以进行下一步了。这里三个变量的获取方法不再赘述，网上很多资料讲述如何获取。</p><h2 id=strings-获取 class=heading-element><span>Strings 获取</span>
<a href=#strings-%e8%8e%b7%e5%8f%96 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>Strings</div><div class=details-content><div class=admonition-content><p>UE 使用 <strong>FName</strong> 存储唯一且不可变的字符串标识符（如对象名称、属性名、资源路径等），它为每个字符串分配唯一数字 ID（如 123 对应 &ldquo;Player&rdquo;），将文本名称转化为高效标识符，并集中存储在全局池中，使得游戏对象（如 Actor）能通过 ID 快速检索名称。</p></div></div></div><p>这里字符串的存储依赖于 GName，上文说到 GName 是一个全局的 FNamePool 实例。那么可以在源码中查看 FNamePool 这个类，如下所示：<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313173020.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313173020.png?size=small" data-sub-html="<h2>20250313173020</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313173020.png alt=FNamePool srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313173020.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313173020.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313173020.png?size=large 2x" data-title=20250313173020 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>FNamePool</figcaption></figure>在这个类中，存在函数 <code>TArray&lt;const FNameEntry *> DebugDump() const</code>，它用于调试目的，负责收集名称池中所有字符串条目的指针。而有了这个指针，我们就可以获取所有的字符串了，因此这里可以通过实现这个函数来达成我们 dump Strings 的目的。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250712183818.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250712183818.png?size=small" data-sub-html="<h2>20250712183818</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250712183818.png alt="DebugDump() 函数" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250712183818.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250712183818.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250712183818.png?size=large 2x" data-title=20250712183818 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>DebugDump() 函数</figcaption></figure>查看这个函数的实现，可以发现它创建输出容器 Out，然后预分配内存，之后通过 <code>Entries.DebugDump(Out)</code> 委托给内部的成员进行处理来获取字符串条目的指针。这里根据函数的实现可以发现，获取字符串条目指针的函数就是 <code>Entries.DebugDump(Out)</code>，因此这里了解实现这个函数就可以达成我们的目标，因此首先就需要了解相关的数据 Entries 的结构。</p><h3 id=fnameentryallocator class=heading-element><span>FNameEntryAllocator</span>
<a href=#fnameentryallocator class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>这里翻阅 FNamePool 类的源码可以发现第一个成员变量就是 Entries，它的类型为 FNameEntryAllocator。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>FNamePool</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>FNameEntryAllocator</span> <span class=n>Entries</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>......</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>得到了 Entries，那么就可以看同文件下的 <code>Entries.DebugDump(Out)</code> 函数了，这个函数就是 FNameEntryAllocator 类的一个成员函数。但是若要进行后续的探索，需要先知道 FNameEntryAllocator 这个类的结构。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313183511.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313183511.png?size=small" data-sub-html="<h2>20250313183511</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313183511.png alt=FNameEntryAllocator srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313183511.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313183511.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313183511.png?size=large 2x" data-title=20250313183511 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>FNameEntryAllocator</figcaption></figure>提取相关成员变量如下所示：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>static</span> <span class=k>constexpr</span> <span class=n>uint32</span> <span class=n>FNameMaxBlockBits</span> <span class=o>=</span> <span class=mi>13</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>constexpr</span> <span class=n>uint32</span> <span class=n>FNameBlockOffsetBits</span> <span class=o>=</span> <span class=mi>16</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>constexpr</span> <span class=n>uint32</span> <span class=n>FNameMaxBlocks</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>FNameMaxBlockBits</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>constexpr</span> <span class=n>uint32</span> <span class=n>FNameBlockOffsets</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>FNameBlockOffsetBits</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>FNameEntryAllocator</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=k>enum</span> <span class=p>{</span> <span class=n>Stride</span> <span class=o>=</span> <span class=k>alignof</span><span class=p>(</span><span class=n>FNameEntry</span><span class=p>)</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>	<span class=k>enum</span> <span class=p>{</span> <span class=n>BlockSizeBytes</span> <span class=o>=</span> <span class=n>Stride</span> <span class=o>*</span> <span class=n>FNameBlockOffsets</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>mutable</span> <span class=n>FRWLock</span> <span class=n>Lock</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>uint32</span> <span class=n>CurrentBlock</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>uint32</span> <span class=n>CurrentByteCursor</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>uint8</span><span class=o>*</span> <span class=n>Blocks</span><span class=p>[</span><span class=n>FNameMaxBlocks</span><span class=p>]</span> <span class=o>=</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>注意这个结构中存在成员变量 Blocks，它是 UE 中字符串存储的关键。FNamePool 由多个固定大小的内存块（Blocks）组成，每个块大小为 <code>BlockSize = FNameStride * 65536</code>。当当前块（CurrentBlock）用满后，会分配新块继续存储字符串。CurrentByteCursor 记录当前块已使用的字节数，最后一个块可能未完全使用。知道了这些就可以继续看 FNameEntryAllocator 的成员函数 <code>DebugDump()</code> 的代码。</p><p>同时还需要注意 <code>mutable FRWLock Lock;</code>，这里没有信息得知它的大小，但是这是对于 Android 平台，所以可以找到相关的定义，由此找到了 FRWLock 的定义。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313223325.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313223325.png?size=small" data-sub-html="<h2>20250313223325</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313223325.png alt=FRWLock srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313223325.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313223325.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313223325.png?size=large 2x" data-title=20250313223325 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>FRWLock</figcaption></figure>然后顺藤摸瓜可以找到 FPThreadsRWLock 类型的定义。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313223419.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313223419.png?size=small" data-sub-html="<h2>20250313223419</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313223419.png alt=FPThreadsRWLock srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313223419.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313223419.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313223419.png?size=large 2x" data-title=20250313223419 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>FPThreadsRWLock</figcaption></figure>这个 FPThreadsRWLock 只有一个成员变量，如下所示：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>FPThreadsRWLock</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>pthread_rwlock_t</span> <span class=n>Mutex</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>因此知道了 FRWLock 的大小就是 pthread_rwlock_t 的大小，而这个数据类型定义在 <strong>&lt;pthread.h></strong> 这个 Linux 库文件中，由此可以直接得到它的大小。它在 32 位安卓平台上此成员大小为 0x28，在 64 位安卓平台上是 0x38。</p><p>而对于 FNameEntryAllocator 中的 <code>Stride = alignof(FNameEntry)</code>，这里的 <code>alignof()</code> 用于 FNameEntry 的对齐要求。这里 FNameEntry 的对齐要求可以查看下面对于 FNameEntry 结构体的介绍，它是 2 字节，那么这里的 Stride 就是 2 了。于此同时，CurrentBlock 和 CurrentByteCursor 都是 uint32 类型，所以大小为 4 字节。而 Blocks 存储的则是 uint8* 类型的指针，它的大小在 64 为系统上为 8 字节。</p><h3 id=debugdump class=heading-element><span>DebugDump</span>
<a href=#debugdump class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>得到的 <code>DebugDump()</code> 函数实现如下：<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250712194213.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250712194213.png?size=small" data-sub-html="<h2>20250712194213</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250712194213.png alt="DebugDump() 实现" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250712194213.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250712194213.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250712194213.png?size=large 2x" data-title=20250712194213 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>DebugDump() 实现</figcaption></figure>忽略一开始加读锁的操作，这里的代码就是遍历所有的内存块，也就是 Blocks 数组，然后采用 <code>DebugDumpBlock()</code> 解析单个块中的字符串条目。for 循环内部使用完整快的固定大小 BlockSizeBytes，而 for 循环外对于最后一个块，因为可能没有用完，所以使用当前块的实际填充大小 CurrentByteCursor。</p><h3 id=debugdumpblock class=heading-element><span>DebugDumpBlock</span>
<a href=#debugdumpblock class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>然后找到 <code>DebugDumpBlock()</code> 函数进行分析：<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250713102617.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250713102617.png?size=small" data-sub-html="<h2>20250713102617</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250713102617.png alt="DebugDumpBlock() 实现" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250713102617.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250713102617.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250713102617.png?size=large 2x" data-title=20250713102617 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>DebugDumpBlock() 实现</figcaption></figure>这里 End 的获取就是从 Block 的开始加上 BlockSize，然后减去特定结构 FNameEntry 中的一个大小，因此这里要知道为什么要减去，需要知道 FNameEntry 的结构。</p><h4 id=fnameentry class=heading-element><span>FNameEntry</span>
<a href=#fnameentry class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313192458.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313192458.png?size=small" data-sub-html="<h2>20250313192458</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313192458.png alt=FNameEntry srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313192458.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313192458.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313192458.png?size=large 2x" data-title=20250313192458 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>FNameEntry</figcaption></figure>这里需要知道在 Block 中，字符串的存储其实就是 FNameEntry 的存储，在 Block 中紧邻的就是一个个 FNameEntry 结构，它负责对于字符串的封装处理。然后再看这个 FNameEntry 结构，它有一个在编译运行时才有效的宏，所以可以忽略不管。因此它的成员变量如下所示，只有一个 <code>FNameEntryHeader Header;</code> 和一个联合体，它们都会参与字符串的存储。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>enum</span> <span class=p>{</span> <span class=n>NAME_SIZE</span> <span class=o>=</span> <span class=mi>1024</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>FNameEntry</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>FNameEntryHeader</span> <span class=n>Header</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>union</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ANSICHAR</span> <span class=n>AnsiName</span><span class=p>[</span><span class=n>NAME_SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>WIDECHAR</span> <span class=n>WideName</span><span class=p>[</span><span class=n>NAME_SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>继续查看这里的 FNameEntryHeader 结构。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313192828.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313192828.png?size=small" data-sub-html="<h2>20250313192828</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313192828.png alt=FNameEntryHeader srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313192828.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313192828.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313192828.png?size=large 2x" data-title=20250313192828 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>FNameEntryHeader</figcaption></figure>然后看到同文件下的 FNameEntryHeader 结构，它同样存在一个编译运行时才有效的宏，忽略这个宏，它的成员变量如下所示：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>FNameEntryHeader</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>uint16</span> <span class=nl>bIsWide</span> <span class=p>:</span> <span class=mi>1</span><span class=p>;</span>                         <span class=c1>// 标记是否为宽字符（Unicode）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>static</span> <span class=k>constexpr</span> <span class=n>uint32</span> <span class=n>ProbeHashBits</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span>  <span class=c1>// 哈希值位数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>uint16</span> <span class=nl>LowercaseProbeHash</span> <span class=p>:</span> <span class=n>ProbeHashBits</span><span class=p>;</span>  <span class=c1>// 小写哈希值（5 位）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>uint16</span> <span class=nl>Len</span> <span class=p>:</span> <span class=mi>10</span><span class=p>;</span>                            <span class=c1>// 字符串长度（最大 1023）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><p>那么真实结构如下所示，这里展示的是小端序的结构。这个结构指示了该字符串是否为宽字符，同时保存了字符串哈希，字符串长度，总共使用 2 字节空间。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>| bIsWide (1 bit) | LowercaseProbeHash (5 bits) | Len (10 bits) |
</span></span><span class=line><span class=cl>| --------------- | --------------------------- | ------------- |</span></span></code></pre></td></tr></table></div></div><p>这里就知道 FNameEntryHeader 是一个两字节的数据，存储字符串的标识和长度等信息。后面就分析 FNameEntry 剩余的联合体，从代码中可以看出它根据 FNameEntryHeader 的 bIsWide 来存储普通单字节字符或宽字符。这里 ANSICHAR 就是 char，占据 8 bit 一个字节，而 WIDECHAR 就是 wchar_t，占据 16 bit 两个字节。</p><h4 id=函数解析 class=heading-element><span>函数解析</span>
<a href=#%e5%87%bd%e6%95%b0%e8%a7%a3%e6%9e%90 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>继续回到对 <code>DebugDumpBlock()</code> 的解析，可以看到 End 的获取需要 <code>FNameEntry::GetDataOffset()</code> 函数的值。找到的与这个函数相关的代码如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>int32</span> <span class=n>FNameEntry</span><span class=o>::</span><span class=n>GetDataOffset</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nf>STRUCT_OFFSET</span><span class=p>(</span><span class=n>FNameEntry</span><span class=p>,</span> <span class=n>AnsiName</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#define STRUCT_OFFSET( struc, member )	offsetof(struc, member)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define offsetof(s,m) ((::size_t)&amp;reinterpret_cast&lt;char const volatile&amp;&gt;((((s*)0)-&gt;m)))</span></span></span></code></pre></td></tr></table></div></div><p>这里最后就是调用 offsetof 宏，而它的本质就是计算结构体/类中成员变量相对于对象起始地址的字节偏移量。这样根据代码，这个函数的目的就是获取 AnsiName 变量在 FNameEntry 结构体中的偏移，而它的前面只有 FNameEntryHeader 结构体，因此这个函数返回 2。这里对于 End 需要再多减去这个 FNameEntryHeader 存在疑惑，不知道为什么需要减去这个 2 字节，然后找到了下面的 Block 分配算法。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250713112743.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250713112743.png?size=small" data-sub-html="<h2>20250713112743</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250713112743.png alt="Block 分配" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250713112743.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250713112743.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250713112743.png?size=large 2x" data-title=20250713112743 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>Block 分配</figcaption></figure>这里可以看出分配 NewBlock 时就需要判断 <code>CurrentByteCursor + FNameEntry::GetDataOffset()</code> 的大小，因此这个 End 的计算也是根据分配算法来的。因此我觉得这里是把一个 Block 的最后两个字节视为无效内存区域，因为一个 FNameEntry 最少需要两个字节。所以这里就通过两个字节来判断 Block 的终止。</p><p>然后继续看 <code>DebugDumpBlock()</code> 的代码，它先是把 It 转化为 FNameEntry 结构体类型，然后判断其中 FNameEntryHeader 的长度是否为零，若不是，那么就进行记录。最后通过 <code>FNameEntry::GetSize(Len, !Entry->IsWide())</code> 寻找下一个 FNameEntry 结构。这里找到的相关代码如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>int32</span> <span class=n>FNameEntry</span><span class=o>::</span><span class=n>GetSize</span><span class=p>(</span><span class=n>int32</span> <span class=n>Length</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>bIsPureAnsi</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>int32</span> <span class=n>Bytes</span> <span class=o>=</span> <span class=n>GetDataOffset</span><span class=p>()</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>                <span class=n>Length</span> <span class=o>*</span> <span class=p>(</span><span class=n>bIsPureAnsi</span> <span class=o>?</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>ANSICHAR</span><span class=p>)</span> <span class=o>:</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>WIDECHAR</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nf>Align</span><span class=p>(</span><span class=n>Bytes</span><span class=p>,</span> <span class=k>alignof</span><span class=p>(</span><span class=n>FNameEntry</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Aligns a value to the nearest higher multiple of &#39;Alignment&#39;, which must be a power of two.
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * @param  Val        The value to align.
</span></span></span><span class=line><span class=cl><span class=cm> * @param  Alignment  The alignment value, must be a power of two.
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * @return The value aligned up to the specified alignment.
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>FORCEINLINE</span> <span class=k>constexpr</span> <span class=n>T</span> <span class=n>Align</span><span class=p>(</span><span class=n>T</span> <span class=n>Val</span><span class=p>,</span> <span class=n>uint64</span> <span class=n>Alignment</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>static_assert</span><span class=p>(</span><span class=n>TIsIntegral</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>Value</span> <span class=o>||</span> <span class=n>TIsPointer</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>Value</span><span class=p>,</span> <span class=s>&#34;Align expects an integer or pointer type&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=p>(</span><span class=n>T</span><span class=p>)(((</span><span class=n>uint64</span><span class=p>)</span><span class=n>Val</span> <span class=o>+</span> <span class=n>Alignment</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>&amp;</span> <span class=o>~</span><span class=p>(</span><span class=n>Alignment</span> <span class=o>-</span> <span class=mi>1</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>由这里的代码可以知道，Bytes 是根据是否为宽字符来计算字符的字节数，然后加上之前获取的 2 字节 FNameEntryHeader 而得到的，然后经过 <code>Align()</code> 函数进行内存对齐，这里是对齐到 2 字节的倍数。因为 FNameEntry 中存在 FNameEntryHeader 这个数据，它大小为 2 字节，同时 Union 中的 ANSICHAR 和 WIDECHAR 一个 1 字节，一个 2 字节，所以会满足最大对齐要求，对齐到 2 字节的倍数。</p><p>由此解析完函数可以知道 UE 中字符串的存储结构。首先字符串都是存储在 GName，也就是全局唯一的 FNamePool 中，它内部第一个成员变量 FNameEntryAllocator 中的 Blocks 数组就是实际存储字符串相关数据的地方。这里的结构是 <code>uint8* Blocks[]</code>，其存储布局如下所示，这个数组实际存储一个个 Block 的指针，然后通过解析指针可以知道每个 Block 的地址。而在实际的 Block 中，字符串按照 FNameEntry 的结构逐一排布，同时对齐到 2 字节的倍数，也就是若这个结构是奇数，后面就会添加一个字节的 0x00 进行内存对齐。而在 FNameEntry 中，分为两个字节的 FNameEntryHeader 和后面的字符串，前面的结构指明字符串是否为宽字符，字符串的长度和哈希值，这样就可以通过解析前面的结构获取字符串的信息，从而成功读取字符串。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Blocks
</span></span><span class=line><span class=cl>|
</span></span><span class=line><span class=cl>|——&gt; Block0 -&gt; [FNameEntry_0, FNameEntry_1, ..., FNameEntry_16383]  // 第 0 个块，共 0x10000 个元素，大小为 0x20000 bytes
</span></span><span class=line><span class=cl>|——&gt; Block1 -&gt; [FNameEntry_0, FNameEntry_1, ..., FNameEntry_16383]  // 第 1 个块
</span></span><span class=line><span class=cl>|——&gt; BlockN -&gt; [...]                                                // 第 N 个块</span></span></code></pre></td></tr></table></div></div><h2 id=getname-算法 class=heading-element><span>GetName 算法</span>
<a href=#getname-%e7%ae%97%e6%b3%95 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>GetName</div><div class=details-content><div class=admonition-content><p>在 UE 中，所有对象和类都有其名字，它们的名称存储在上文获取 Strings 过程中提到的 Block 中。这里 FNamePool 管理着引擎中所有唯一字符串标识符（FName）的存储池，可以通过字符串标识符来获取字符串，同时对象和类的结构中就存储着对应的字符串标识符，这样保证了可以在获取类和对象时就知道它对应的字符串名称，而这里通过字符串标识符获取字符串的算法就是 GetName 算法。</p></div></div></div><h3 id=获取字符串 class=heading-element><span>获取字符串</span>
<a href=#%e8%8e%b7%e5%8f%96%e5%ad%97%e7%ac%a6%e4%b8%b2 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>在 FName 中存在函数 <code>ToString()</code>，它就是通过唯一标识符获取字符串的函数，也就是 GetName 算法的实现函数。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313131322.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313131322.png?size=small" data-sub-html="<h2>20250313131322</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313131322.png alt=ToString() srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313131322.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313131322.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313131322.png?size=large 2x" data-title=20250313131322 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>ToString()</figcaption></figure>然后继续找到这个函数的定义，发现它就是调用了 <code>GetDisplayNameEntry()->GetPlainNameString()</code> 来实现功能。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313131758.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313131758.png?size=small" data-sub-html="<h2>20250313131758</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313131758.png alt=ToString() srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313131758.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313131758.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313131758.png?size=large 2x" data-title=20250313131758 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>ToString()</figcaption></figure></p><h4 id=相关结构 class=heading-element><span>相关结构</span>
<a href=#%e7%9b%b8%e5%85%b3%e7%bb%93%e6%9e%84 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><h5 id=fstring class=heading-element><span>FString</span>
<a href=#fstring class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>这里函数的返回值为 FString，它是一个动态大小的字符串类，用于存储和操作字符串数据。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305182228.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305182228.png?size=small" data-sub-html="<h2>20250305182228</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305182228.png alt=FString srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305182228.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305182228.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305182228.png?size=large 2x" data-title=20250305182228 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>FString</figcaption></figure>上图就是 FString 这个类的结构，这里 CORE_API 用于处理模块间的符号导入/导出，于结构分析无益。然后提取这个类的变量可以知道，它只有一个 DataType 类型的成员变量 Data。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>CORE_API</span> <span class=n>FString</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=cm>/** Array holding the character data */</span>
</span></span><span class=line><span class=cl>	<span class=k>typedef</span> <span class=n>TArray</span><span class=o>&lt;</span><span class=n>TCHAR</span><span class=o>&gt;</span> <span class=n>DataType</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>DataType</span> <span class=n>Data</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>而这里的 DataType 其实就是 <code>TArray&lt;TCHAR></code> 类型，因此继续查看这两个结构。</p><h5 id=tarray class=heading-element><span>TArray</span>
<a href=#tarray class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305184237.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305184237.png?size=small" data-sub-html="<h2>20250305184237</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305184237.png alt=TArray srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305184237.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305184237.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305184237.png?size=large 2x" data-title=20250305184237 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>TArray</figcaption></figure>首先就是分析 TArray 结构，它是 UE 的动态数组容器，类似于 <code>std::vector</code>，提取出来的关键结构如下所示。这里 ElementAllocatorType 是 TArray 的内存分配器类型，其具体类型由模板参数 Allocator 决定。而 SizeType 是 TArray 的元素计数和索引类型，其类型由分配器的 SizeType 决定。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>SizeType</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>TArray</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>typedef</span> <span class=k>typename</span> <span class=n>TChooseClass</span><span class=o>&lt;</span>
</span></span><span class=line><span class=cl>		<span class=n>Allocator</span><span class=o>::</span><span class=n>NeedsElementType</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=k>typename</span> <span class=n>Allocator</span><span class=o>::</span><span class=k>template</span> <span class=n>ForElementType</span><span class=o>&lt;</span><span class=n>ElementType</span><span class=o>&gt;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=k>typename</span> <span class=n>Allocator</span><span class=o>::</span><span class=n>ForAnyElementType</span>
</span></span><span class=line><span class=cl>	<span class=o>&gt;::</span><span class=n>Result</span> <span class=n>ElementAllocatorType</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>ElementAllocatorType</span> <span class=n>AllocatorInstance</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>SizeType</span>             <span class=n>ArrayNum</span><span class=p>;</span>          <span class=c1>//记录当前数组内元素的实际个数
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>SizeType</span>             <span class=n>ArrayMax</span><span class=p>;</span>          <span class=c1>//记录当前数组最大可容纳元素的数量
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>根据 TArray 的结构，可以知道它通过传递的 TCHAR 结构来开辟容器的大小。</p><h5 id=tchar class=heading-element><span>TCHAR</span>
<a href=#tchar class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>这里 TCHAR 在不同的平台上定义不一样，然后可以找到 Android 平台下的相关定义如下。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250725220437.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250725220437.png?size=small" data-sub-html="<h2>20250725220437</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250725220437.png alt=20250725220437 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250725220437.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250725220437.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250725220437.png?size=large 2x" data-title=20250725220437 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>20250725220437</figcaption></figure>这里直接可以看出这个 TCHAR 就是 char16_t 类型，和 Windows 平台的定义一样，都是专门用于表示 UTF-16 编码的 Unicode 字符，占用 2 字节内存空间。</p><p>由此可以知道 FString 就是就是一个存储字符串的动态数组容器，每个字符占用 2 字节。</p><h4 id=getdisplaynameentry class=heading-element><span>GetDisplayNameEntry</span>
<a href=#getdisplaynameentry class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>首先看 <code>GetDisplayNameEntry()</code> 这个函数，它的实现如下图所示。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313132357.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313132357.png?size=small" data-sub-html="<h2>20250313132357</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313132357.png alt=GetDisplayNameEntry() srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313132357.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313132357.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313132357.png?size=large 2x" data-title=20250313132357 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>GetDisplayNameEntry()</figcaption></figure>这个函数的返回值是上文提到的 FNameEntry 结构，它是 Block 中字符串存储的结构。那么该函数返回这个类型就说明 <code>GetPlainNameString()</code> 函数应该是 FNameEntry 类的函数，负责将 FNameEntry 转化为 FString 结构。这里该函数只是调用 <code>GetNamePool()</code>，<code>Resolve()</code>，<code>GetDisplayIndex()</code> 三个函数，因此继续查看这三个函数。</p><h5 id=getnamepool class=heading-element><span>GetNamePool</span>
<a href=#getnamepool class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313132859.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313132859.png?size=small" data-sub-html="<h2>20250313132859</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313132859.png alt=GetNamePool() srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313132859.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313132859.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313132859.png?size=large 2x" data-title=20250313132859 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>GetNamePool()</figcaption></figure>这个函数是一个单例模式的函数，也就是在 so 中存在唯一的全局变量 NamePoolData，它的类型为 FNamePool。</p><ul><li><code>static bool bNamePoolInitialized;</code>：声明了一个静态布尔变量 bNamePoolInitialized，用于跟踪 FNamePool 实例是否已经被初始化。</li><li><code>alignas(FNamePool) static uint8 NamePoolData[sizeof(FNamePool)];</code>：声明了一个静态数组 NamePoolData，其大小等于 FNamePool 类的大小，并使用 alignas 关键字确保这个数组按照 FNamePool 的内存对齐要求进行对齐。这个数组将用作 FNamePool 实例的内存空间。</li><li><code>GetNamePool()</code>：这个函数用于返回 FNamePool 的实例，如果未被初始化则初始化。</li></ul><p>这个模式保证了即使在多线程环境下，FNamePool 也只会被初始化一次。它不使用 C++11 中的魔法静态（magic statics）或单例模式中的锁，以减少运行时的开销。通过这种方式，FNamePool 类的实例在第一次调用 GetNamePool 时被创建，并在随后的调用中直接返回，避免了重复初始化。</p><p>由此可以看出这个函数就是用来初始化 FNamePool 实例的，也就是 NamePoolData 这个数组，同时它只会初始化一次。同时上文提到的 GName 就是用内存池 FNamePool 来定义的。所以由此可以知道，FNamePoll 会定义一个全局静态变量 NamePoolData 数组，这个数组就是上文提到的 GName，它存储了全局的字符串，相当于一个字符串池，这里的 <code>ToString()</code> 函数就依赖这个数组获取字符串名字。</p><h5 id=getdisplayindex class=heading-element><span>GetDisplayIndex</span>
<a href=#getdisplayindex class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313160335.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313160335.png?size=small" data-sub-html="<h2>20250313160335</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313160335.png alt=GetDisplayIndex() srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313160335.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313160335.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313160335.png?size=large 2x" data-title=20250313160335 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>GetDisplayIndex()</figcaption></figure>这里就是调用了 <code>GetDisplayIndexFast()</code> 函数，然后返回了一个 FNameEntryId 类型的 Index。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305130947.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305130947.png?size=small" data-sub-html="<h2>20250305130947</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305130947.png alt=FNameEntryId srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305130947.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305130947.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305130947.png?size=large 2x" data-title=20250305130947 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>FNameEntryId</figcaption></figure>FNameEntryId 这个类型内部只有一个成员变量 <code>uint32 Value;</code>，具体如下所示。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>FNameEntryId</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>uint32</span> <span class=n>Value</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>这里 FName 提供名字字符串，同时上文也讲到 UE 中字符串和唯一标识符进行绑定，而这两个之间的桥梁就是字符串标识符。它就是一个 FNameEntryId 类型数据，也就是一个 uint32 类型的数字。这个字符串标识符指向了 FNamePool 中的名称条目，我们可以通过解析 UE 中提供的算法来将这个标识符转化为对应的字符串。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313161823.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313161823.png?size=small" data-sub-html="<h2>20250313161823</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313161823.png alt=GetDisplayIndexFast() srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313161823.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313161823.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313161823.png?size=large 2x" data-title=20250313161823 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>GetDisplayIndexFast()</figcaption></figure>然后查看 <code>GetDisplayIndexFast()</code> 函数。这里有相关宏定义，由注释可以知道这个宏只用于编译器，而在实际运行中不会启用。因此这里的 <code>GetDisplayIndexFast()</code> 函数实际返回的就是 ComparisonIndex，而这个变量有两处被定义，其中一处就是作为 FName 的成员变量。同时它的类型也是 FNameEntryId 类型，所以可以知道 ComparisonIndex 只是存储了一个 uint32 的值，它是字符串在 GName 中的索引。</p><h5 id=resolve class=heading-element><span>Resolve</span>
<a href=#resolve class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313163154.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313163154.png?size=small" data-sub-html="<h2>20250313163154</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313163154.png alt=Resolve() srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313163154.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313163154.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313163154.png?size=large 2x" data-title=20250313163154 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>Resolve()</figcaption></figure>由上图可以看到该函数调用了 <code>Entries.Resolve()</code> 函数。由上文 Strings dump 可知，这个 Entries 的类型为 FNameEntryAllocator，所以继续寻找这个类得到了函数的实现。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313165045.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313165045.png?size=small" data-sub-html="<h2>20250313165045</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313165045.png alt=Resolve() srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313165045.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313165045.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313165045.png?size=large 2x" data-title=20250313165045 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>Resolve()</figcaption></figure>这个函数的参数为 FNameEntryHandle 类型，然后查看其函数实现。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313164532.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313164532.png?size=small" data-sub-html="<h2>20250313164532</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313164532.png alt=FNameEntryHandle srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313164532.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313164532.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313164532.png?size=large 2x" data-title=20250313164532 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>FNameEntryHandle</figcaption></figure>将该结构简化之后就是下面的呈现方式，同时获取了相关未知值，例如 FNameBlockOffsetBits，它在类的上方被定义，是个常量。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/** Remember to update natvis if you change these */</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>constexpr</span> <span class=n>uint32</span> <span class=n>FNameBlockOffsetBits</span> <span class=o>=</span> <span class=mi>16</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>constexpr</span> <span class=n>uint32</span> <span class=n>FNameBlockOffsets</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>FNameBlockOffsetBits</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/** An unpacked FNameEntryId */</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>FNameEntryHandle</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>uint32</span> <span class=n>Block</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>uint32</span> <span class=n>Offset</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>FNameEntryHandle</span><span class=p>(</span><span class=n>uint32</span> <span class=n>InBlock</span><span class=p>,</span> <span class=n>uint32</span> <span class=n>InOffset</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=o>:</span> <span class=n>Block</span><span class=p>(</span><span class=n>InBlock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>,</span> <span class=n>Offset</span><span class=p>(</span><span class=n>InOffset</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>FNameEntryHandle</span><span class=p>(</span><span class=n>FNameEntryId</span> <span class=n>Id</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=o>:</span> <span class=n>Block</span><span class=p>(</span><span class=n>Id</span><span class=p>.</span><span class=n>ToUnstableInt</span><span class=p>()</span> <span class=o>&gt;&gt;</span> <span class=n>FNameBlockOffsetBits</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>,</span> <span class=n>Offset</span><span class=p>(</span><span class=n>Id</span><span class=p>.</span><span class=n>ToUnstableInt</span><span class=p>()</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>FNameBlockOffsets</span> <span class=o>-</span> <span class=mi>1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>查看这个结构可以发现，FNameEntryHandle 的构造函数有两种，但都是传入 Block 的 id 和块内 offset，一种是直接传入，一种通过 FNameEntryId 传入。这里知道 FNameEntryId 其实就是上文说的字符串标识符，它指向了 Block 中对应的 FNameEntry 结构，同时由 <code>GetDisplayIndex()</code> 的返回值也是这个类型可以知道，它这里就是通过第二个构造函数来进行类型转化。</p><p>然后继续查看这个函数，发现它和上文的 Strings dump 的流程类似，都是根据偏移在 Block 中获取 FNameEntry 类型数据。因此这里的过程就是调用 <code>GetNamePool()</code> 得到了 GName，然后由 <code>GetDisplayIndex()</code> 函数获取字符串索引 <code>FNameEntryId ComparisonIndex</code>，之后根据索引调用 <code>Entries.Resolve()</code> 函数在 Blocks 中找出对应的包装字符串的 FNameEntry 类型数据。</p><h4 id=getplainnamestring class=heading-element><span>GetPlainNameString</span>
<a href=#getplainnamestring class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313195030.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313195030.png?size=small" data-sub-html="<h2>20250313195030</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313195030.png alt=GetPlainNameString srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313195030.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313195030.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313195030.png?size=large 2x" data-title=20250313195030 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>GetPlainNameString</figcaption></figure>然后看 GetPlainNameString 函数，它是 FNameEntry 类的函数，那么这里的 Header 就是上文 FNameEntry 中的 <code>FNameEntryHeader Header;</code>，它利用变量 bIsWide 来判断是否为宽字符，然后根据这个判断返回对应类型的字符串。之后可以看同文件下的 <code>GetUnterminatedName()</code> 函数，它的作用只是返回 FNameEntry 中存储的对应类型字符串。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313195352.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313195352.png?size=small" data-sub-html="<h2>20250313195352</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313195352.png alt=GetUnterminatedName() srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313195352.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313195352.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313195352.png?size=large 2x" data-title=20250313195352 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>GetUnterminatedName()</figcaption></figure></p><h3 id=总结 class=heading-element><span>总结</span>
<a href=#%e6%80%bb%e7%bb%93 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>这里的 <code>ToString()</code> 函数会调用关键函数 <code>GetDisplayNameEntry()->GetPlainNameString()</code>，而 <code>GetDisplayNameEntry()</code> 又依次调用 <code>GetNamePool()</code>，<code>GetDisplayIndex()</code>，<code>Resolve()</code> 三个函数。</p><ul><li><code>GetNamePool()</code> 函数主要用于初始化并返回 <code>FNamePool NamePoolData</code>，这个 NamePoolData 就是之前找的 GName。</li><li><code>GetDisplayIndex()</code> 主要用于返回对象名称的索引，它返回类型为 FNameEntryId，其成员变量只有一个 <code>uint32 Value;</code>。同时此函数内部调用 <code>GetDisplayIndexFast()</code> 获取 ComparisonIndex，该索引值直接存储在 FName 对象中，可通过 UObjectBase 的 NamePrivate 成员直接提取。</li><li><code>Resolve()</code> 根据索引从名称池中解析出对应的目录项，返回 FNameEntry 对象。此对象通过 bIsWide 判断字符串编码类型，并通过联合体兼容不同编码的字符串存储。</li></ul><p>最后 <code>Resolve()</code> 返回的 FNameEntry 对象将调用 <code>GetPlainNameString()</code> 方法，将内部存储的原始字符串转换为 FString 类型输出。此过程根据 bIsWide 标志自动选择字符编码处理逻辑，确保字符串内容的准确性。</p><h2 id=guobject-解析 class=heading-element><span>GUobject 解析</span>
<a href=#guobject-%e8%a7%a3%e6%9e%90 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>GUobject</div><div class=details-content><div class=admonition-content><p>在 UE 中，所有可以被识别的对象都是 Object，比如人物，物体等。而 GUobject（GUObjectArray） 是 UE 引擎中的一个基础类，代表着游戏中可被识别的对象，在 UE 的对象体系中，几乎所有的类都是从 GObject 派生来的。</p></div></div></div><h3 id=获取对象 class=heading-element><span>获取对象</span>
<a href=#%e8%8e%b7%e5%8f%96%e5%af%b9%e8%b1%a1 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><h4 id=相关结构-1 class=heading-element><span>相关结构</span>
<a href=#%e7%9b%b8%e5%85%b3%e7%bb%93%e6%9e%84-1 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>根据上文对于 GUObjectArray 的介绍可以知道，它是一个全局的 FUObjectArray 类型的实例，存储了当前所有的对象，结构如下图所示：<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250401230022.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250401230022.png?size=small" data-sub-html="<h2>20250401230022</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250401230022.png alt=GUObjectArray srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250401230022.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250401230022.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250401230022.png?size=large 2x" data-title=20250401230022 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>GUObjectArray</figcaption></figure></p><h5 id=fuobjectarray class=heading-element><span>FUObjectArray</span>
<a href=#fuobjectarray class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>然后可以找到 FUObjectArray 类的结构如下所示：<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250401230142.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250401230142.png?size=small" data-sub-html="<h2>20250401230142</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250401230142.png alt=FUObjectArray srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250401230142.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250401230142.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250401230142.png?size=large 2x" data-title=20250401230142 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>FUObjectArray</figcaption></figure></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>COREUOBJECT_API</span> <span class=n>FUObjectArray</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=c1>//typedef TStaticIndirectArrayThreadSafeRead&lt;UObjectBase, 8 * 1024 * 1024 /* Max 8M UObjects */, 16384 /* allocated in 64K/128K chunks */ &gt; TUObjectArray;
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>typedef</span> <span class=n>FChunkedFixedUObjectArray</span> <span class=n>TUObjectArray</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// note these variables are left with the Obj prefix so they can be related to the historical GObj versions
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=cm>/** First index into objects array taken into account for GC.							*/</span>
</span></span><span class=line><span class=cl>	<span class=n>int32</span> <span class=n>ObjFirstGCIndex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cm>/** Index pointing to last object created in range disregarded for GC.					*/</span>
</span></span><span class=line><span class=cl>	<span class=n>int32</span> <span class=n>ObjLastNonGCIndex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cm>/** Maximum number of objects in the disregard for GC Pool */</span>
</span></span><span class=line><span class=cl>	<span class=n>int32</span> <span class=n>MaxObjectsNotConsideredByGC</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=cm>/** If true this is the intial load and we should load objects int the disregarded for GC range.	*/</span>
</span></span><span class=line><span class=cl>	<span class=kt>bool</span> <span class=n>OpenForDisregardForGC</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cm>/** Array of all live objects.											*/</span>
</span></span><span class=line><span class=cl>	<span class=n>TUObjectArray</span> <span class=n>ObjObjects</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>......</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>这里根据注释了解到重要的是 <code>TUObjectArray ObjObjects;</code> 变量，它是存储所有存活对象的数组。同时这里需要进行 8 字节内存对齐，要求每个成员的偏移量是自身大小和 8 字节中的较小者的倍数，而下面 TUObjectArray 的结构表明它大于 8 字节，所以为了其从 8 字节倍数偏移开始，这里 bool 类型的 OpenForDisregardForGC 被填补为 4 字节，由此 ObjObjects 的偏移为 0x10。同时它的类型 TUObjectArray 也由上面的 typedef 指明是 FChunkedFixedUObjectArray 类型。</p><h5 id=tuobjectarray class=heading-element><span>TUObjectArray</span>
<a href=#tuobjectarray class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>这个类型的定义如下，根据注释可知它包含最大元素容量，当前元素数量等信息。这里 <code>FUObjectItem** Objects;</code> 是最重要的成员变量。根据下文 <code>GetObjectPtr()</code> 函数的解析，可以知道它是 FUObjectItem 类型的二级指针，指向一个指针数组，其中每个元素都指向一个 Chunk（内存块），enum 定义的 NumElementsPerChunk 决定了 Objects 指向的每个 Chunk 的大小为 64 * 1024 个元素。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250401231036.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250401231036.png?size=small" data-sub-html="<h2>20250401231036</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250401231036.png alt=FChunkedFixedUObjectArray srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250401231036.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250401231036.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250401231036.png?size=large 2x" data-title=20250401231036 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>FChunkedFixedUObjectArray</figcaption></figure></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>FChunkedFixedUObjectArray</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>enum</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>NumElementsPerChunk</span> <span class=o>=</span> <span class=mi>64</span> <span class=o>*</span> <span class=mi>1024</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=cm>/** Master table to chunks of pointers **/</span>
</span></span><span class=line><span class=cl>	<span class=n>FUObjectItem</span><span class=o>**</span> <span class=n>Objects</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cm>/** If requested, a contiguous memory where all objects are allocated **/</span>
</span></span><span class=line><span class=cl>	<span class=n>FUObjectItem</span><span class=o>*</span> <span class=n>PreAllocatedObjects</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cm>/** Maximum number of elements **/</span>
</span></span><span class=line><span class=cl>	<span class=n>int32</span> <span class=n>MaxElements</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cm>/** Number of elements we currently have **/</span>
</span></span><span class=line><span class=cl>	<span class=n>int32</span> <span class=n>NumElements</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cm>/** Maximum number of chunks **/</span>
</span></span><span class=line><span class=cl>	<span class=n>int32</span> <span class=n>MaxChunks</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cm>/** Number of chunks we currently have **/</span>
</span></span><span class=line><span class=cl>	<span class=n>int32</span> <span class=n>NumChunks</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h5 id=fuobjectitem class=heading-element><span>FUObjectItem</span>
<a href=#fuobjectitem class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>之后再看 Objects 的类型 FUObjectItem，它定义简单，就是一个具体的 Object。由此可知 Objects 最终指向的每一个 FUObjectItem 都代表一个对象。这里的 FUObjectItem 也需要进行内存对齐，其大小会对齐到 0x18。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250401233000.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250401233000.png?size=small" data-sub-html="<h2>20250401233000</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250401233000.png alt=FUObjectItem srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250401233000.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250401233000.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250401233000.png?size=large 2x" data-title=20250401233000 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>FUObjectItem</figcaption></figure></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>FUObjectItem</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Pointer to the allocated object
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>class</span> <span class=nc>UObjectBase</span><span class=o>*</span> <span class=n>Object</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Internal flags
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>int32</span> <span class=n>Flags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=c1>// UObject Owner Cluster Index
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>int32</span> <span class=n>ClusterRootIndex</span><span class=p>;</span>	
</span></span><span class=line><span class=cl>	<span class=c1>// Weak Object Pointer Serial number associated with the object
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>int32</span> <span class=n>SerialNumber</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h4 id=getobjectptr class=heading-element><span>GetObjectPtr</span>
<a href=#getobjectptr class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>这里获取 <code>UObject *</code> 和上文 获取 Strings 的过程一样，都需要通过函数来进行获取，这里的就是 <code>GetObjectPtr()</code> 函数。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402095504.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402095504.png?size=small" data-sub-html="<h2>20250402095504</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402095504.png alt=GetObjectPtr() srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402095504.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402095504.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402095504.png?size=large 2x" data-title=20250402095504 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>GetObjectPtr()</figcaption></figure>这里两个函数逻辑一样，区别在于 const 版本防止意外修改数据，适用于只读操作，另一个允许修改数据，适用于需要变更的场景。消去 checkf 操作，简化如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>FORCEINLINE_DEBUGGABLE</span> <span class=n>FUObjectItem</span> <span class=k>const</span><span class=o>*</span> <span class=nf>GetObjectPtr</span><span class=p>(</span><span class=n>int32</span> <span class=n>Index</span><span class=p>)</span> <span class=k>const</span> <span class=n>TSAN_SAFE</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>int32</span> <span class=n>ChunkIndex</span> <span class=o>=</span> <span class=n>Index</span> <span class=o>/</span> <span class=n>NumElementsPerChunk</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>int32</span> <span class=n>WithinChunkIndex</span> <span class=o>=</span> <span class=n>Index</span> <span class=o>%</span> <span class=n>NumElementsPerChunk</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>FUObjectItem</span><span class=o>*</span> <span class=n>Chunk</span> <span class=o>=</span> <span class=n>Objects</span><span class=p>[</span><span class=n>ChunkIndex</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>Chunk</span> <span class=o>+</span> <span class=n>WithinChunkIndex</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>由上面算法可知，Objects 的储存和 Strings 的存储一样，都不是平坦的，而是分块的，只不过 Objects 分为了数个 Chunk，而 Strings 分为了数个 Block
，然后内部依次存储对应的元素。Objects 的存储结构如下所示。这里 <code>GetObjectPtr()</code> 函数首先根据索引 Index 计算块索引 ChunkIndex 和块内偏移 WithinChunkIndex，然后访问块数组 Objects 找到对应块指针，再通过块指针和块内偏移得到目标 FUObjectItem 的地址。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Objects
</span></span><span class=line><span class=cl>|
</span></span><span class=line><span class=cl>|——&gt; Chunk0 -&gt; [FUObjectItem_0, FUObjectItem_1, ..., FUObjectItem_65535]  // 第 0 个块，共 64K 元素
</span></span><span class=line><span class=cl>|——&gt; Chunk1 -&gt; [FUObjectItem_65536, ..., FUObjectItem_131071]             // 第 1 个块
</span></span><span class=line><span class=cl>|——&gt; ChunkN -&gt; [...]                                                      // 第 N 个块</span></span></code></pre></td></tr></table></div></div><h3 id=获取对象名称 class=heading-element><span>获取对象名称</span>
<a href=#%e8%8e%b7%e5%8f%96%e5%af%b9%e8%b1%a1%e5%90%8d%e7%a7%b0 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>在上文 Strings dump 的过程中，我们知道 UE 中每一个字符串都有一个唯一标识符，可以通过这个标识符来找到对应的字符串。那么相应的，Object 的名称也是一个字符串，我们可以找到这个唯一标识符获取 Object 的名称。</p><h4 id=uobjectbase class=heading-element><span>UObjectBase</span>
<a href=#uobjectbase class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>这里根据 <code>class UObjectBase* Object;</code> 得到 Object 的类型为 UObjectBase，其类结构如下：<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305122209.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305122209.png?size=small" data-sub-html="<h2>20250305122209</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305122209.png alt=UObjectBase srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305122209.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305122209.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305122209.png?size=large 2x" data-title=20250305122209 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>UObjectBase</figcaption></figure>UObjectBase 这个类就是顶级类了，其中也定义了相关的成员变量，可以简化为下面的形式。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>COREUOBJECT_API</span> <span class=n>UObjectBase</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>VTable</span><span class=p>;</span>                                        <span class=c1>//虚表指针，自己添加的
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=cm>/** Flags used to track and report various object states. This needs to be 8 byte aligned on 32-bit
</span></span></span><span class=line><span class=cl><span class=cm>	    platforms to reduce memory waste */</span>
</span></span><span class=line><span class=cl>	<span class=n>EObjectFlags</span>					<span class=n>ObjectFlags</span><span class=p>;</span>            <span class=c1>//对象属性
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=cm>/** Index into GObjectArray...very private. */</span>
</span></span><span class=line><span class=cl>	<span class=n>int32</span>							<span class=n>InternalIndex</span><span class=p>;</span>          <span class=c1>//对象 GUObjectArray 序号
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=cm>/** Class the object belongs to. */</span>
</span></span><span class=line><span class=cl>	<span class=n>UClass</span><span class=o>*</span>							<span class=n>ClassPrivate</span><span class=p>;</span>           <span class=c1>//对象的类
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=cm>/** Name of this object */</span>
</span></span><span class=line><span class=cl>	<span class=n>FName</span>							<span class=n>NamePrivate</span><span class=p>;</span>            <span class=c1>//对象的名字
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=cm>/** Object this object resides in. */</span>
</span></span><span class=line><span class=cl>	<span class=n>UObject</span><span class=o>*</span>						<span class=n>OuterPrivate</span><span class=p>;</span>           <span class=c1>//对象所在UPackage
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>虽然普遍认为 UObject 是 UE4 中所有对象的基类，但是真正的基类应该是 UObjectBase。不过认为 UObject 是基类也并无道理，根据 <code>UObject -> UObjectBaseUtility -> UObjectBase</code> 的继承关系，继承自 UObjectBase 的 UObject 没有新增任何成员。它们的联系如下所示：</p><ul><li><code>UObjectBase</code> 提供了最基础的对象功能，如对象索引（InternalIndex）、类信息（ClassPrivate）、对象标志（ObjectFlags），不过不包含任何实用功能（如反射、序列化）；</li><li><code>UObjectBaseUtility</code> 继承扩展了外部对象引用（OuterPrivate）、对象名称（NamePrivate）、更多对象标志（Flags），它提供了基础的实用功能，但仍未实现完整的对象系统；</li><li><code>UObject</code> 实现了完整的对象系统，包括反射（Reflection）、垃圾回收（Garbage Collection）、序列化（Serialization）、属性系统（Property System），提供了开发者直接使用的接口。</li></ul><p>之后查看这个类的大小，可以看出有很多指针类型，那么就是 8 字节，余下不知道的就是 EObjectFlags 和 FName 类型了。EObjectFlags 如下所示，它是一个枚举类型（enum），在 C++ 底层类型是 uint32，也就是 4 个字节。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305124615.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305124615.png?size=small" data-sub-html="<h2>20250305124615</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305124615.png alt=EObjectFlags srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305124615.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305124615.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305124615.png?size=large 2x" data-title=20250305124615 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>EObjectFlags</figcaption></figure></p><h4 id=fname class=heading-element><span>FName</span>
<a href=#fname class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>然后看看 FName，它是一个轻量级的字符串类型，用于表示对象的名称。在这里就可以看出，正是因为 UE 中所有对象都继承自 UObject 这个类，同时这个类又有成员变量 FName 提供名字，所以 UE 的反射系统才能方便知道一个对象的名字、字段、函数参数等信息。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305125139.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305125139.png?size=small" data-sub-html="<h2>20250305125139</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305125139.png alt=FName srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305125139.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305125139.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305125139.png?size=large 2x" data-title=20250305125139 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>FName</figcaption></figure>然后忽略编译条件宏包裹的变量后提取的成员变量如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>CORE_API</span> <span class=n>FName</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=cm>/** Index into the Names array (used to find String portion of the string/number pair used for comparison) */</span>
</span></span><span class=line><span class=cl>	<span class=n>FNameEntryId</span>	<span class=n>ComparisonIndex</span><span class=p>;</span>        <span class=c1>//指向 FNamePool 中的名称条目
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=cm>/** Number portion of the string/number pair (stored internally as 1 more than actual, so zero&#39;d memory will be the default, no-instance case) */</span>
</span></span><span class=line><span class=cl>	<span class=n>uint32</span>			<span class=n>Number</span><span class=p>;</span>                 <span class=c1>//用于区分同名对象的编号
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>这里 FName 提供名字字符串，同时上文也讲到 UE 中字符串和唯一标识符进行绑定，那么在这里，它们之间的桥梁就是 ComparisonIndex。它是一个 FNameEntryId 类型数据，也就是一个 uint32 类型的数字。这个 ComparisonIndex 指向了 FNamePool 中的名称条目，因此我们可以通过 GetName 算法来将这个标识符转化为对应的字符串，由此也就获得了一个对象的名称。</p><h3 id=获取类名称 class=heading-element><span>获取类名称</span>
<a href=#%e8%8e%b7%e5%8f%96%e7%b1%bb%e5%90%8d%e7%a7%b0 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>这里获取对象所属类的名称，首先就是要知道它所属的类是什么。而在 UObjectBase 这个类中，就有成员变量 <code>UClass* ClassPrivate;</code> 表示对象的类，这个指针指向的地址就是对象所属类的信息位置，类型为 UClass。</p><p>然后一直追踪类的继承关系，可以发现 <code>UClass -> UStruct -> UField -> UObject -> UObjectBaseUtility -> UObjectBase</code>。由此就知道 UClass 继承自 UObjectBase，那么它的名称获取就和对象的名称获取方法一样了。同时这里因为 <code>UObjectBase</code> 是顶级类，所以 <code>FName NamePrivate;</code> 这个成员变量的偏移也是一样的。</p><h3 id=获取属性和方法 class=heading-element><span>获取属性和方法</span>
<a href=#%e8%8e%b7%e5%8f%96%e5%b1%9e%e6%80%a7%e5%92%8c%e6%96%b9%e6%b3%95 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>在获取类名称的过程中，发现对象的所属类有很多种，其中一种就是 Class，这里就对属于这个类的结构进行分析，获取其属性（变量）和方法。</p><h4 id=相关知识 class=heading-element><span>相关知识</span>
<a href=#%e7%9b%b8%e5%85%b3%e7%9f%a5%e8%af%86 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><div class="details admonition abstract open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-clipboard-list" aria-hidden=true></i>注意事项</div><div class=details-content><div class=admonition-content><p>下面的内容来自于 <a href=https://bbs.kanxue.com/thread-282857.htm#msg_header_h2_4 target=_blank rel="external nofollow noopener noreferrer">UE4.27SDK-Dump</a>，这里查看 UE4.27 源码进行验证理解。</p></div></div></div><h5 id=ufield class=heading-element><span>UField</span>
<a href=#ufield class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>UField 继承自 UObject，核心扩展是 <code>UField* Next</code> 指针，主要用于支持字段迭代（如 UClass 的链表遍历）。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402151225.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402151225.png?size=small" data-sub-html="<h2>20250402151225</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402151225.png alt=UField srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402151225.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402151225.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402151225.png?size=large 2x" data-title=20250402151225 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>UField</figcaption></figure>这里可以使用 Visual Studio 的内存布局功能查看迭代指针的偏移。不过因为源码中的 FName 类存在条件编译的成员变量，Visual Studio 分析时会添加这个变量，所以会使得 FName 变成 12 字节。但是由上面的分析，<strong>FName 在安卓 arm 64 平台只有两个成员变量，所以它是 8 个字节</strong>，因此将下列条件编译变量注释，得到了符合 arm64 架构的内存布局。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404172556.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404172556.png?size=small" data-sub-html="<h2>20250404172556</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404172556.png alt=修正偏移 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404172556.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404172556.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404172556.png?size=large 2x" data-title=20250404172556 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>修正偏移</figcaption></figure>然后再查看内存布局，就符合 arm64 架构了。这个类的大小为 48 字节，对齐方式是 8 字节。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404172702.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404172702.png?size=small" data-sub-html="<h2>20250404172702</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404172702.png alt=内存布局 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404172702.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404172702.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404172702.png?size=large 2x" data-title=20250404172702 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>内存布局</figcaption></figure></p><h5 id=ffield class=heading-element><span>FField</span>
<a href=#ffield class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>在 UE4.25 之后，引入了 FField，可以把它视为上述 UField 的子集，后续就是通过它来获取属性系统。它直接描述属性信息（也就是成员变量的信息），剥离了与 UObject 相关的功能。且其没有继承任何一个类，这样大幅度减少了属性对象的占用。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402154439.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402154439.png?size=small" data-sub-html="<h2>20250402154439</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402154439.png alt=FField srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402154439.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402154439.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402154439.png?size=large 2x" data-title=20250402154439 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>FField</figcaption></figure>提取的成员变量和内存布局如下。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>COREUOBJECT_API</span> <span class=n>FField</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>VTable</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/** Pointer to the class object representing the type of this FField */</span>
</span></span><span class=line><span class=cl>	<span class=n>FFieldClass</span><span class=o>*</span> <span class=n>ClassPrivate</span><span class=p>;</span>                  <span class=c1>// 类名，用于区分 FProperty 类型
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=cm>/** Owner of this field */</span>
</span></span><span class=line><span class=cl>	<span class=n>FFieldVariant</span> <span class=n>Owner</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=cm>/** Next Field in the linked list */</span>
</span></span><span class=line><span class=cl>	<span class=n>FField</span><span class=o>*</span> <span class=n>Next</span><span class=p>;</span>                               <span class=c1>// 指向下一个 FField
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=cm>/** Name of this field */</span>
</span></span><span class=line><span class=cl>	<span class=n>FName</span> <span class=n>NamePrivate</span><span class=p>;</span>                          <span class=c1>// 成员变量名称
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=cm>/** Object flags */</span>
</span></span><span class=line><span class=cl>	<span class=n>EObjectFlags</span> <span class=n>FlagsPrivate</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// #if WITH_EDITORONLY_DATA
</span></span></span><span class=line><span class=cl><span class=c1>// private:
</span></span></span><span class=line><span class=cl><span class=c1>// 	   /** Editor-only meta data map */
</span></span></span><span class=line><span class=cl><span class=c1>// 	   TMap&lt;FName, FString&gt;* MetaDataMap;
</span></span></span><span class=line><span class=cl><span class=c1>// #endif // WITH_EDITORONLY_DATA
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>这个类最后一个成员变量被条件编译 <code>#if WITH_EDITORONLY_DATA</code> 包裹，实际游戏中不会包含。由此同样将这个变量给注释掉。然后得到了下面的内存布局，大小为 56 字节，对齐方式是 8 字节。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404173129.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404173129.png?size=small" data-sub-html="<h2>20250404173129</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404173129.png alt=内存布局 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404173129.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404173129.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404173129.png?size=large 2x" data-title=20250404173129 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>内存布局</figcaption></figure>其中 FFieldClass 和 FFieldVariant 两种类型的结构如下所示：<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402160849.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402160849.png?size=small" data-sub-html="<h2>20250402160849</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402160849.png alt=FFieldClass srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402160849.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402160849.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402160849.png?size=large 2x" data-title=20250402160849 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>FFieldClass</figcaption></figure><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402160929.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402160929.png?size=small" data-sub-html="<h2>20250402160929</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402160929.png alt=FFieldVariant srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402160929.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402160929.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402160929.png?size=large 2x" data-title=20250402160929 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>FFieldVariant</figcaption></figure></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>COREUOBJECT_API</span> <span class=n>FFieldClass</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=cm>/** Name of this field class */</span>
</span></span><span class=line><span class=cl>	<span class=n>FName</span> <span class=n>Name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cm>/** Unique Id of this field class (for casting) */</span>
</span></span><span class=line><span class=cl>	<span class=n>uint64</span> <span class=n>Id</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cm>/** Cast flags used for casting to other classes */</span>
</span></span><span class=line><span class=cl>	<span class=n>uint64</span> <span class=n>CastFlags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cm>/** Class flags */</span>
</span></span><span class=line><span class=cl>	<span class=n>EClassFlags</span> <span class=n>ClassFlags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cm>/** Super of this class */</span>
</span></span><span class=line><span class=cl>	<span class=n>FFieldClass</span><span class=o>*</span> <span class=n>SuperClass</span><span class=p>;</span>	
</span></span><span class=line><span class=cl>	<span class=cm>/** Default instance of this class */</span>
</span></span><span class=line><span class=cl>	<span class=n>FField</span><span class=o>*</span> <span class=n>DefaultObject</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cm>/** Counter for generating runtime unique names */</span>
</span></span><span class=line><span class=cl>	<span class=n>FThreadSafeCounter</span> <span class=n>UnqiueNameIndexCounter</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>COREUOBJECT_API</span> <span class=n>FFieldVariant</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>union</span> <span class=nc>FFieldObjectUnion</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>FField</span><span class=o>*</span> <span class=n>Field</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>UObject</span><span class=o>*</span> <span class=n>Object</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span> <span class=n>Container</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kt>bool</span> <span class=n>bIsUObject</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>前者大小为 64 字节，对齐大小为 8 字节；后者大小为 16 字节，对齐方式为 8 字节。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404173308.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404173308.png?size=small" data-sub-html="<h2>20250404173308</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404173308.png alt=内存布局 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404173308.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404173308.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404173308.png?size=large 2x" data-title=20250404173308 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>内存布局</figcaption></figure></p><h5 id=fproperty class=heading-element><span>FProperty</span>
<a href=#fproperty class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>这个类继承 FField，它保存更详细的信息描述。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402161655.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402161655.png?size=small" data-sub-html="<h2>20250402161655</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402161655.png alt=FProperty srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402161655.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402161655.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402161655.png?size=large 2x" data-title=20250402161655 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>FProperty</figcaption></figure></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>COREUOBJECT_API</span> <span class=nl>FProperty</span> <span class=p>:</span> <span class=k>public</span> <span class=n>FField</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Persistent variables.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>int32</span>			<span class=n>ArrayDim</span><span class=p>;</span>                   <span class=c1>// 变量的维数
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>int32</span>			<span class=n>ElementSize</span><span class=p>;</span>                <span class=c1>// 变量元素大小（变量整体大小为 ElementSize * ArrayDim）
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>EPropertyFlags</span>	<span class=n>PropertyFlags</span><span class=p>;</span>              <span class=c1>// 变量 Flag
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>uint16</span>			<span class=n>RepIndex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>TEnumAsByte</span><span class=o>&lt;</span><span class=n>ELifetimeCondition</span><span class=o>&gt;</span> <span class=n>BlueprintReplicationCondition</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// In memory variables (generated during Link()).
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>int32</span>		<span class=n>Offset_Internal</span><span class=p>;</span>                <span class=c1>// 变量在结构体中的偏移
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>FName</span>		<span class=n>RepNotifyFunc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=cm>/** In memory only: Linked list of properties from most-derived to base **/</span>
</span></span><span class=line><span class=cl>	<span class=n>FProperty</span><span class=o>*</span>	<span class=n>PropertyLinkNext</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cm>/** In memory only: Linked list of object reference properties from most-derived to base **/</span>
</span></span><span class=line><span class=cl>	<span class=n>FProperty</span><span class=o>*</span>  <span class=n>NextRef</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cm>/** In memory only: Linked list of properties requiring destruction. Note this does not include things that will be destroyed byt he native destructor **/</span>
</span></span><span class=line><span class=cl>	<span class=n>FProperty</span><span class=o>*</span>	<span class=n>DestructorLinkNext</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cm>/** In memory only: Linked list of properties requiring post constructor initialization.**/</span>
</span></span><span class=line><span class=cl>	<span class=n>FProperty</span><span class=o>*</span>	<span class=n>PostConstructLinkNext</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>TEnumAsByte</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>uint8</span> <span class=n>Value</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>其中 FProperty 和 TEnumAsByte 的内存布局如下。前者大小为 120 字节，对齐方式是 8 字节；后者大小为 1 字节，对齐方式为 1 字节。这里为了满足 FProperty 的对齐要求，所以 TEnumAsByte 被填充为 2 字节。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404183916.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404183916.png?size=small" data-sub-html="<h2>20250404183916</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404183916.png alt=内存布局 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404183916.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404183916.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404183916.png?size=large 2x" data-title=20250404183916 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>内存布局</figcaption></figure></p><h5 id=ustruct class=heading-element><span>UStruct</span>
<a href=#ustruct class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>这个类比较重要，它继承于 UField，记录了成员、函数信息的指针。这里主要关注 SuperStruc，ChildProperties 和 Children。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402162727.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402162727.png?size=small" data-sub-html="<h2>20250402162727</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402162727.png alt=UStruct srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402162727.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402162727.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402162727.png?size=large 2x" data-title=20250402162727 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>UStruct</figcaption></figure></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>COREUOBJECT_API</span> <span class=nl>UStruct</span> <span class=p>:</span> <span class=k>public</span> <span class=n>UField</span>
</span></span><span class=line><span class=cl><span class=cp>#if USTRUCT_FAST_ISCHILDOF_IMPL == USTRUCT_ISCHILDOF_STRUCTARRAY
</span></span></span><span class=line><span class=cl><span class=cp></span>	<span class=p>,</span> <span class=k>private</span> <span class=n>FStructBaseChain</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=cm>/** Struct this inherits from, may be null */</span>
</span></span><span class=line><span class=cl>	<span class=n>UStruct</span><span class=o>*</span> <span class=n>SuperStruct</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=cm>/** Pointer to start of linked list of child fields */</span>
</span></span><span class=line><span class=cl>	<span class=n>UField</span><span class=o>*</span> <span class=n>Children</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=cm>/** Pointer to start of linked list of child fields */</span>
</span></span><span class=line><span class=cl>	<span class=n>FField</span><span class=o>*</span> <span class=n>ChildProperties</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=cm>/** Total size of all UProperties, the allocated structure may be larger due to alignment */</span>
</span></span><span class=line><span class=cl>	<span class=n>int32</span> <span class=n>PropertiesSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cm>/** Alignment of structure in memory, structure will be at least this large */</span>
</span></span><span class=line><span class=cl>	<span class=n>int32</span> <span class=n>MinAlignment</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=cm>/** Script bytecode associated with this object */</span>
</span></span><span class=line><span class=cl>	<span class=n>TArray</span><span class=o>&lt;</span><span class=n>uint8</span><span class=o>&gt;</span> <span class=n>Script</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=cm>/** In memory only: Linked list of properties from most-derived to base */</span>
</span></span><span class=line><span class=cl>	<span class=n>FProperty</span><span class=o>*</span> <span class=n>PropertyLink</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cm>/** In memory only: Linked list of object reference properties from most-derived to base */</span>
</span></span><span class=line><span class=cl>	<span class=n>FProperty</span><span class=o>*</span> <span class=n>RefLink</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cm>/** In memory only: Linked list of properties requiring destruction. Note this does not include things that will be destroyed byt he native destructor */</span>
</span></span><span class=line><span class=cl>	<span class=n>FProperty</span><span class=o>*</span> <span class=n>DestructorLink</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cm>/** In memory only: Linked list of properties requiring post constructor initialization */</span>
</span></span><span class=line><span class=cl>	<span class=n>FProperty</span><span class=o>*</span> <span class=n>PostConstructLink</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=cm>/** Array of object references embedded in script code and referenced by FProperties. Mirrored for easy access by realtime garbage collection code */</span>
</span></span><span class=line><span class=cl>	<span class=n>TArray</span><span class=o>&lt;</span><span class=n>UObject</span><span class=o>*&gt;</span> <span class=n>ScriptAndPropertyObjectReferences</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>typedef</span> <span class=n>TArray</span><span class=o>&lt;</span><span class=n>TPair</span><span class=o>&lt;</span><span class=n>TFieldPath</span><span class=o>&lt;</span><span class=n>FField</span><span class=o>&gt;</span><span class=p>,</span> <span class=n>int32</span><span class=o>&gt;&gt;</span> <span class=n>FUnresolvedScriptPropertiesArray</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cm>/** Contains a list of script properties that couldn&#39;t be resolved at load time */</span>
</span></span><span class=line><span class=cl>	<span class=n>FUnresolvedScriptPropertiesArray</span><span class=o>*</span> <span class=n>UnresolvedScriptProperties</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>由上可以看出 UStruct 继承了 UField 和 FStructBaseChain，不过后者被条件编译宏包围着。这个条件编译指令的目的是在类型继承关系查询功能上实现不同的性能优化方案，同时安卓平台上一般启动这个条件编译，所以 UStruct 真实继承两个类。因此它的内存布局如下，大小为 200 字节，对齐方式是 8 字节。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404184837.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404184837.png?size=small" data-sub-html="<h2>20250404184837</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404184837.png alt=内存布局 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404184837.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404184837.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404184837.png?size=large 2x" data-title=20250404184837 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>内存布局</figcaption></figure></p><h5 id=uclass class=heading-element><span>UClass</span>
<a href=#uclass class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>这个类在获取类名称时稍微提到过，它就是 UObject 中的成员，继承于 UStruct，新增很多成员，不过实际使用的还是 UStruct 中已经定义的成员。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402163449.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402163449.png?size=small" data-sub-html="<h2>20250402163449</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402163449.png alt=UClass srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402163449.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402163449.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402163449.png?size=large 2x" data-title=20250402163449 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>UClass</figcaption></figure>下面是 UClass 和 UStruct 的内存布局，其大小为 632 字节，对齐方式为 8 字节。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404185036.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404185036.png?size=small" data-sub-html="<h2>20250404185036</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404185036.png alt=内存布局 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404185036.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404185036.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404185036.png?size=large 2x" data-title=20250404185036 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>内存布局</figcaption></figure></p><h5 id=总结-1 class=heading-element><span>总结</span>
<a href=#%e6%80%bb%e7%bb%93-1 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>回顾一下获取对象的过程，这里首先从 GUObjectArray 获取了每个对象 UObject，然后 UObject 类中包含 <code>UClass* ClassPrivate;</code> 成员变量。而 UClass 继承自 UStruct，所以可以通过 ClassPrivate 获取到 UStruct。由此就可以获得 UStruct 类中的 <code>FField* ChildProperties;</code> 和 <code>UField* Children;</code>。前者是类中的属性，后者则是类中的方法。</p><h4 id=childproperties class=heading-element><span>ChildProperties</span>
<a href=#childproperties class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>这里获取了 UClass 类型的 <code>FField* ChildProperties</code>，就可以根据具体的类型进行解析，在 UE4 中定义了许多具体的类型，例如：FInterfaceProperty，FStructProperty，FEnumProperty 等。他们均继承自 FProperty 类，进而继承自 FField 类，下图清楚地展示了相关类型的继承关系。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402202204.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402202204.png?size=small" data-sub-html="<h2>20250402202204</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402202204.png alt=UObjectHierarchyFwd.h srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402202204.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402202204.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402202204.png?size=large 2x" data-title=20250402202204 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>UObjectHierarchyFwd.h</figcaption></figure>由此可以继续找到这些类型的相关定义。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402202552.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402202552.png?size=small" data-sub-html="<h2>20250402202552</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402202552.png alt=FInterfaceProperty srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402202552.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402202552.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402202552.png?size=large 2x" data-title=20250402202552 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>FInterfaceProperty</figcaption></figure><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402202638.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402202638.png?size=small" data-sub-html="<h2>20250402202638</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402202638.png alt=FStructProperty srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402202638.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402202638.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402202638.png?size=large 2x" data-title=20250402202638 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>FStructProperty</figcaption></figure><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402203013.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402203013.png?size=small" data-sub-html="<h2>20250402203013</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402203013.png alt=20250402203013 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402203013.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402203013.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402203013.png?size=large 2x" data-title=20250402203013 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>20250402203013</figcaption></figure>这些 Property 自身可能还会有字段如 <code>UStriptStruct* Struct</code> 来进一步描述信息，也可能仅仅依赖于 FProperty，不需要新的字段去描述信息。不过实际上，通过上述过程得到的 <code>FField* ChildProperties</code> 就已经是一个具体的 Property 了。这里 FField 要么是 FInterfaceProperty，要么就是 FStructProperty，它总会表示一种具体的类型。因此得到这个指针后添加 FProperty 类型的大小就可以获取真正的 Property 标识。比如对于 FInterfaceProperty，它和 FProperty 的内存布局如下所示，可见它去除 FProperty 的大小之后就是它的标识 <code>class UClass* InterfaceClass</code> 了。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404200137.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404200137.png?size=small" data-sub-html="<h2>20250404200137</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404200137.png alt=内存布局对比 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404200137.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404200137.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404200137.png?size=large 2x" data-title=20250404200137 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>内存布局对比</figcaption></figure>由此得到的 FProperty 大小为 0x78，那么实际偏移也就是 0x78。这里通过添加 FProperty 的大小得到真正类型标识的方法并不是通用的，一些特殊的 Property 还会存在数个指针，比如类型 FMapProperty 有不同指针存储了不同信息，而 FEnumProperty 则多存储了一个 UnderlyingProp 指针，它们都需要加上多出的大小才能指向真正类型。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402224657.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402224657.png?size=small" data-sub-html="<h2>20250402224657</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402224657.png alt="特殊 Property 内存布局" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402224657.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402224657.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250402224657.png?size=large 2x" data-title=20250402224657 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>特殊 Property 内存布局</figcaption></figure>而要区分出这些 Property，那么就需要依赖于它继承自 FField 中的字段 <code>FFieldClass* ClassPrivate</code>，它的类如下所示。由此可见，获取该字段指针之后，第一个成员变量 <code>FName Name;</code> 就是 FName 类型，它存储了当前 Property 的类名称，由此可以区别出不同的 Property。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404201151.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404201151.png?size=small" data-sub-html="<h2>20250404201151</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404201151.png alt=FFieldClass srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404201151.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404201151.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250404201151.png?size=large 2x" data-title=20250404201151 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>FFieldClass</figcaption></figure>同时这里还可以通过获取 FField 结构的 <code>FName NamePrivate</code> 得到这个 Property 的名称，也就是结构体中成员变量的名称。</p><p>总的来说，这里得到了一个 UObject 类的对象，然后解析其中 <code>UClass* ClassPrivate;</code> 成员变量，可以获取这个类型中的 <code>FField* ChildProperties;</code> 成员变量，它表示类中的属性。然后解析这个成员变量的 FField 类型，通过它的 <code>FName NamePrivate</code> 成员变量可以获取 Property 的名称。之后解析 FField 中的 <code>FFieldClass* ClassPrivate;</code> 成员变量，它存储着这个 FProperty 的类型，通过 FFieldClass 结构的 <code>FName Name</code> 可以获取类型的名称。同时这里类的属性以链表的形式存储在 ChildProperties 中，每个 FField 对象可以通过 Next 指针指向下一个属性。由此可以通过循环获取一个类的所有属性。</p><p>看上文的 FProperty 类型，它存在几个关键的成员变量：ArrayDim，ElementSize，PropertyFlags 和 Offset_Internal。其中 ArrayDim 和 ElementSize 分别表示当前成员变量（FProperty 对象）的维数和元素大小，而 PropertyFlags 是一个属性标志位集合，用于定义属性的元数据和行为特性，Offset_Internal 则是该成员变量距离类地址的偏移。之后在实际的调试中（根据腾讯安卓初赛的样本），发现这里的偏移和 Visual Studio 中的不同，ArrayDim 和 ElementSize 会占据前面空闲的 4 个字节，也就是往前移动 4 个字节，也就是将 Visual Studio 内存布局中 FlagsPrivate 后面空闲的 4 个字节移动到了 ElementSize 后面，没有进行字节对齐。</p><h2 id=actors-获取 class=heading-element><span>Actors 获取</span>
<a href=#actors-%e8%8e%b7%e5%8f%96 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>Actors</div><div class=details-content><div class=admonition-content><p>在 UE 中，每一个物体就是一个可交互对象，它们这些对象就是 Actor。所有首先需要知道这些对象（包括玩家）都是哪些 Actor，才能针对不同的 Actor 进行不同的操作。这里首先获取每个 Actor 的名称，而要获取名称，那么需要知道每个 Actor 的地址，然后再通过 Actor 的结构解析出它的地址。具体而言，这里首先通过 GWorld 获取 Actors 的地址，然后根据地址解析结构，获取 actorID，之后根据这个 actorID 从 GName 开始寻找，获取 Actor 的名称。这里可以查看源码知道具体的流程。</p></div></div></div><h3 id=获取地址 class=heading-element><span>获取地址</span>
<a href=#%e8%8e%b7%e5%8f%96%e5%9c%b0%e5%9d%80 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>这里所有的 Actors 都存储在 ULevel 的结构中，而 ULevel 就是通过 GWorld 获取的。在上文的介绍中，GWorld 是 UE 中的一个全局指针变量，是指向 UWorld 的指针，代表当前的世界实例。所有可以把 GWorld 理解为 UWorld 类。</p><h4 id=uworld class=heading-element><span>UWorld</span>
<a href=#uworld class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305111155.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305111155.png?size=small" data-sub-html="<h2>20250305111155</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305111155.png alt=UWorld srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305111155.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305111155.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305111155.png?size=large 2x" data-title=20250305111155 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>UWorld</figcaption></figure>上述是 UWorld 的结构，但是在实际运行环境中 UWorld 的第一个成员是 <code>ULevel* PersistentLevel</code>，可表示成下面的形式。这里 ENGINE_API 是一个模块导出宏，用于控制 Engine 模块的符号可见性。在 Windows 平台上被定义为 <code>__declspec(dllexport)</code>，表示将类或函数导出为 DLL 的公共符号；而在其他平台为空，这些平台不需要显式导出符号。而 <code>UPROPERTY(Transient)</code> 是 Unreal Engine 的属性修饰符，用于标记一个成员变量为临时变量，避免序列化和网络同步，这里可以不加理会。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>ENGINE_API</span> <span class=n>UWorld</span> <span class=k>final</span> <span class=o>:</span> <span class=k>public</span> <span class=n>UObject</span><span class=p>,</span> <span class=k>public</span> <span class=n>FNetworkNotify</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/** Persistent level containing the world info, default brush and actors spawned during gameplay among other things			*/</span>
</span></span><span class=line><span class=cl>	<span class=n>UPROPERTY</span><span class=p>(</span><span class=n>Transient</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>class</span> <span class=nc>ULevel</span><span class=o>*</span>								<span class=n>PersistentLevel</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>这里 PersistentLevel 是一个指向 ULevel 的指针，表示持久化关卡。它是 UWorld 的核心成员之一，负责管理关卡中的 Actor、光照、BSP 等内容。</p><h4 id=ulevel class=heading-element><span>ULevel</span>
<a href=#ulevel class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305152202.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305152202.png?size=small" data-sub-html="<h2>20250305152202</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305152202.png alt=ULevel srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305152202.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305152202.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250305152202.png?size=large 2x" data-title=20250305152202 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>ULevel</figcaption></figure>然后查看这个 ULevel 类，可以发现它这里存在 <code>TArray&lt;AActor*> Actors;</code>，而这个就是存储 Actors 的结构，由此获取这个结构也就是得到了 Actors 的地址。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>ULevel</span> <span class=o>:</span> <span class=k>public</span> <span class=n>UObject</span><span class=p>,</span> <span class=k>public</span> <span class=n>IInterface_AssetUserData</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=cm>/** URL associated with this level. */</span>
</span></span><span class=line><span class=cl>	<span class=n>FURL</span>					<span class=n>URL</span><span class=p>;</span>                <span class=c1>//存储协议相关配置，以及地图等选项
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=cm>/** Array of all actors in this level, used by FActorIteratorBase and derived classes */</span>
</span></span><span class=line><span class=cl>	<span class=n>TArray</span><span class=o>&lt;</span><span class=n>AActor</span><span class=o>*&gt;</span> <span class=n>Actors</span><span class=p>;</span>                     <span class=c1>//存储所有Actors
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h3 id=获取名称 class=heading-element><span>获取名称</span>
<a href=#%e8%8e%b7%e5%8f%96%e5%90%8d%e7%a7%b0 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>上文介绍过 TArray 这个结构，它类似于 <code>std::vector</code>，是一个动态数组模板类。由此可知这个 TArray 只是数组的包装类型，Actors 数组存储着连续的指向 AActor 的指针 <code>AActor*</code>，AActor 就是 Actor 的具体类型。 然后看 AActor 这个类型如下所示：<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250306205942.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250306205942.png?size=small" data-sub-html="<h2>20250306205942</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250306205942.png alt=AActor srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250306205942.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250306205942.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250306205942.png?size=large 2x" data-title=20250306205942 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>AActor</figcaption></figure>由上图可以看出 AActor 继承 UObject 类，这说明每一个 Actor 都是 UE 中的一个对象。而 UObject 又继承 UObjectBase 类，由此每个 Actor 名称的获取就是和对象名称的获取一样的过程了。</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2025-08-01 20:14:13">更新于 2025.8.1&nbsp;
<a class=git-hash href=https://github.com/czTangt/blog.git/commit/332429ff6d7f3224aeaf10f373abee078346f6fa rel="external nofollow noopener noreferrer" target=_blank title="commit by czTangt(cz.tangt@gmail.com) 332429ff6d7f3224aeaf10f373abee078346f6fa: add object resolve"><i class="fa-solid fa-hashtag fa-fw" aria-hidden=true></i>332429f</a></span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href="https://github.com/czTangt/blog.git/blob/main/content/posts%5candroid%5cUE_structure.md?plain=1" title=查看源码 target=_blank rel="external nofollow noopener noreferrer" class=link-to-source>查看源码</a></span><span><a href=https://github.com/czTangt/blog.git/edit/main/content/posts%5candroid%5cUE_structure.md title=编辑此页 target=_blank rel="external nofollow noopener noreferrer" class=link-to-edit>编辑此页</a></span><span><a href="https://github.com/czTangt/blog.git/issues/new?title=[BUG]%20UE+%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90&amp;body=%7cField%7cValue%7c%0A%7c-%7c-%7c%0A%7cTitle%7cUE+%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90%7c%0A%7cURL%7chttps://czTangt.github.io/blog/posts/android/ue-structure/%7c%0A%7cFilename%7chttps://github.com/czTangt/blog.git/blob/main/content/posts%5candroid%5cUE_structure.md?plain=1%7c" title=报告问题 target=_blank rel="external nofollow noopener noreferrer" class=link-to-report>报告问题</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 X" data-sharer=twitter data-url=https://czTangt.github.io/blog/posts/android/ue-structure/ data-title="UE 结构分析" data-hashtags=android,game><i class="fa-brands fa-x-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://czTangt.github.io/blog/posts/android/ue-structure/ data-hashtag=android><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://czTangt.github.io/blog/posts/android/ue-structure/ data-title="UE 结构分析"><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/blog/tags/android/ class=post-tag title="标签 - Android">Android</a><a href=/blog/tags/game/ class=post-tag title="标签 - Game">Game</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/blog/>主页</a></span></section></div><div class=post-nav><a href=/blog/posts/android/2024-tencent-gamesec-final/ class=post-nav-item rel=prev title=2024腾讯游戏安全竞赛决赛><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>2024腾讯游戏安全竞赛决赛</a></div></div></article><aside class=toc id=toc-auto aria-label=目录><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside></main><footer class=footer><div class=footer-container><div class="footer-line powered order-1">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.136.5"><img class=hugo-icon src=/blog/images/hugo.min.svg alt="Hugo logo"> Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.3.17-30a67c4b"><img class=fixit-icon src=/blog/images/fixit.min.svg alt="FixIt logo"> FixIt</a></div><div class="footer-line copyright order-2" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2024 - 2025</span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class="variant-numeric d-none">0%</span></div></div><a href=https://github.com/czTangt/blog title="View source on GitHub" target=_blank rel="external nofollow" class="github-corner left d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true" width="56" height="56"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><noscript><div class=noscript-warning>该网站在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/blog/lib/lightgallery/css/lightgallery-bundle.min.css><link rel=preload href=/blog/lib/katex/katex.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/blog/lib/katex/katex.min.css></noscript><link rel=stylesheet href=/blog/lib/cookieconsent/cookieconsent.min.css><script src=/blog/lib/autocomplete/autocomplete.min.js defer></script><script src=/blog/lib/fuse/fuse.min.js defer></script><script src=/blog/lib/lightgallery/lightgallery.min.js defer></script><script src=/blog/lib/lightgallery/plugins/thumbnail/lg-thumbnail.min.js defer></script><script src=/blog/lib/lightgallery/plugins/zoom/lg-zoom.min.js defer></script><script src=/blog/lib/sharer/sharer.min.js async defer></script><script src=/blog/lib/katex/katex.min.js defer></script><script src=/blog/lib/katex/auto-render.min.js defer></script><script src=/blog/lib/katex/mhchem.min.js defer></script><script src=/blog/lib/cookieconsent/cookieconsent.min.js defer></script><script src=/blog/js/codeblock.js defer></script><script src=https://libs.baidu.com/jquery/2.1.4/jquery.min.js defer></script><script>window.config={code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:10},comment:{enable:!1},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},lightgallery:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{distance:100,findAllMatches:!1,fuseIndexURL:"/blog/search.json",highlightTag:"em",ignoreFieldNorm:!1,ignoreLocation:!1,isCaseSensitive:!1,location:0,maxResultLength:10,minMatchCharLength:2,noResultsFound:"没有找到结果",snippetLength:30,threshold:.3,type:"fuse",useExtendedSearch:!1},version:"v0.3.17-30a67c4b"}</script><script src=/blog/js/theme.min.js defer></script></body></html>