<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>2024腾讯游戏安全竞赛决赛 - czTang</title><meta name=author content="czTang">
<meta name=description content="记录一下对于2024腾讯游戏安全竞赛安卓赛道的复现。
"><meta name=keywords content='android,game'><meta itemprop=name content="2024腾讯游戏安全竞赛决赛"><meta itemprop=description content="记录一下对于2024腾讯游戏安全竞赛安卓赛道的复现。"><meta itemprop=datePublished content="2025-03-27T10:19:48+08:00"><meta itemprop=dateModified content="2025-08-07T10:38:36+08:00"><meta itemprop=wordCount content="5346"><meta itemprop=keywords content="Android,Game"><meta property="og:url" content="https://czTangt.github.io/blog/posts/android/2024-tencent-gamesec-final/"><meta property="og:site_name" content="czTang"><meta property="og:title" content="2024腾讯游戏安全竞赛决赛"><meta property="og:description" content="记录一下对于2024腾讯游戏安全竞赛安卓赛道的复现。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-03-27T10:19:48+08:00"><meta property="article:modified_time" content="2025-08-07T10:38:36+08:00"><meta property="article:tag" content="Android"><meta property="article:tag" content="Game"><meta name=twitter:card content="summary"><meta name=twitter:title content="2024腾讯游戏安全竞赛决赛"><meta name=twitter:description content="记录一下对于2024腾讯游戏安全竞赛安卓赛道的复现。"><meta name=application-name content="FixIt"><meta name=apple-mobile-web-app-title content="FixIt"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel=icon href=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410312135963.svg><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical type=text/html href=https://czTangt.github.io/blog/posts/android/2024-tencent-gamesec-final/ title="2024腾讯游戏安全竞赛决赛 - czTang"><link rel=prev type=text/html href=https://czTangt.github.io/blog/posts/android/2024-tencent-gamesec-prelim/ title=2024腾讯游戏安全竞赛初赛><link rel=next type=text/html href=https://czTangt.github.io/blog/posts/android/ue-structure/ title="UE 结构分析"><link rel=stylesheet href=/blog/css/style.min.css><link rel=preload href=/blog/lib/fontawesome-free/all.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/blog/lib/fontawesome-free/all.min.css></noscript><link rel=preload href=/blog/lib/animate/animate.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/blog/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"2024腾讯游戏安全竞赛决赛","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/czTangt.github.io\/blog\/posts\/android\/2024-tencent-gamesec-final\/"},"genre":"posts","keywords":"android, game","wordcount":5346,"url":"https:\/\/czTangt.github.io\/blog\/posts\/android\/2024-tencent-gamesec-final\/","datePublished":"2025-03-27T10:19:48+08:00","dateModified":"2025-08-07T10:38:36+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"czTang"},"description":""}</script><script src=/blog/js/head/color-scheme.min.js></script></head><body data-header-desktop=sticky data-header-mobile=auto><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=left><div class=header-title><a href=/blog/ title=czTang><span class=header-title-pre><i class='fa fa-coffee'>&nbsp</i></span><span class=header-title-text>czTang</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/blog/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 归档</a></li><li class=menu-item><a class=menu-link href=/blog/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/blog/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/blog/about/><i class="fa-solid fa-user fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/blog/ title=czTang><span class=header-title-pre><i class='fa fa-coffee'>&nbsp</i></span><span class=header-title-text>czTang</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/blog/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 归档</a></li><li class=menu-item><a class=menu-link href=/blog/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/blog/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/blog/about/><i class="fa-solid fa-user fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=container><aside class="aside-collection animate__animated animate__fadeIn animate__faster" aria-label=合集><div class="details collection-details open"><div class="details-summary collection-summary"><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i>
<span class=collection-name title=合集>Game</span>
<span class=collection-count>3</span><i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class="details-content collection-content"><nav><ul class=collection-list><li class=collection-item><a href=/blog/posts/android/2024-tencent-gamesec-prelim/ title=2024腾讯游戏安全竞赛初赛>2024腾讯游戏安全竞赛初赛</a></li><li class=collection-item><span class=active title=2024腾讯游戏安全竞赛决赛>2024腾讯游戏安全竞赛决赛</span></li><li class=collection-item><a href=/blog/posts/android/ue-structure/ title="UE 结构分析">UE 结构分析</a></li></ul><div class=collection-nav-simple><a href=/blog/posts/android/2024-tencent-gamesec-prelim/ class=collection-nav-item rel=prev title=2024腾讯游戏安全竞赛初赛><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i></a><span class=text-secondary>2/3</span><a href=/blog/posts/android/ue-structure/ class=collection-nav-item rel=next title="UE 结构分析"><i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></nav></div></div></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>2024腾讯游戏安全竞赛决赛</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/czTangt title=作者 target=_blank rel="external nofollow noopener noreferrer author" class=author><img loading=lazy src=/blog/images/avatar.jpg alt=czTang data-title=czTang width=20 height=20 class=avatar style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'>&nbsp;czTang</a></span><span class=post-included-in>&nbsp;收录于 <a href=/blog/categories/android/ class=post-category title="分类 - Android"><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> Android</a> 和 <a href=/blog/collections/game/ class=post-collection title="合集 - Game"><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i> Game</a></span></div><div class=post-meta-line><span title="发布于 2025-03-27 10:19:48"><i class="fa-solid fa-calendar-days fa-fw me-1" aria-hidden=true></i><time datetime=2025.3.27>2025.3.27</time></span>&nbsp;<span title="更新于 2025-08-07 10:38:36"><i class="fa-regular fa-calendar-check fa-fw me-1" aria-hidden=true></i><time datetime=2025.8.7>2025.8.7</time></span>&nbsp;<span title="5346 字"><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 5400 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 11 分钟</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#前期准备>前期准备</a><ul><li><a href=#版本与结构>版本与结构</a></li><li><a href=#gname-验证>GName 验证</a><ul><li><a href=#gadget-注入>gadget 注入</a></li><li><a href=#算法验证>算法验证</a></li></ul></li></ul></li><li><a href=#dumpsdk>dumpSDK</a><ul><li><a href=#dump-strings>dump Strings</a></li><li><a href=#dump-sdk>dump SDK</a><ul><li><a href=#对象获取>对象获取</a><ul><li><a href=#tuobjectarray>TUObjectArray</a></li><li><a href=#fuobjectitem>FUObjectItem</a></li><li><a href=#uobject>UObject</a></li><li><a href=#function-获取信息>Function 获取信息</a><ul><li><a href=#ufield>UField</a></li><li><a href=#ffield>FField</a></li><li><a href=#functionflags>FunctionFlags</a></li><li><a href=#func>Func</a></li></ul></li><li><a href=#class-获取信息>Class 获取信息</a></li></ul></li></ul></li></ul></li><li><a href=#参考资料>参考资料</a></li></ul></nav></div></div><div class=content id=content><p>记录一下对于2024腾讯游戏安全竞赛安卓赛道的复现。</p><h2 id=前期准备 class=heading-element><span>前期准备</span>
<a href=#%e5%89%8d%e6%9c%9f%e5%87%86%e5%a4%87 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><h3 id=版本与结构 class=heading-element><span>版本与结构</span>
<a href=#%e7%89%88%e6%9c%ac%e4%b8%8e%e7%bb%93%e6%9e%84 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>按照初赛的逻辑，首先查看这个游戏的 ue 版本，然后发现和初赛一样，在 libUE4.so 中发现了 <code>++UE4+Release-4.27</code>，确定是 4.27 版本。然后就是按照常规流程来寻找 GWorld，GUObjectArray，GName 三件套。对于前面两个而言，就是通过 <code>SeamlessTravel FlushLevelStreaming</code> 和 <code>CloseDisregardForGC</code> 进行字符串交叉引用即可找到。然后由下图得到了 <code>GWorld</code> 为 <code>0x4F5C0D0</code>，<code>GUObjectArray</code> 为 <code>0x4E533AC</code>。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327214918.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327214918.png?size=small" data-sub-html="<h2>20250327214918</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327214918.png alt=GWorld srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327214918.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327214918.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327214918.png?size=large 2x" data-title=20250327214918 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>GWorld</figcaption></figure><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327220856.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327220856.png?size=small" data-sub-html="<h2>20250327220856</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327220856.png alt=GUObjectArray srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327220856.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327220856.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327220856.png?size=large 2x" data-title=20250327220856 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>GUObjectArray</figcaption></figure>不过这里按照常规流程却不好解析 GName 这个关键结构。这里首先搜索字符串 <code>ByteProperty</code>，然后排除上面的宽字符串（因为没有交叉引用），找到最后一个字符串找到其交叉引用。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327221140.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327221140.png?size=small" data-sub-html="<h2>20250327221140</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327221140.png alt=ByteProperty搜索 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327221140.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327221140.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327221140.png?size=large 2x" data-title=20250327221140 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>ByteProperty搜索</figcaption></figure>然后这里就是不同之处了，这里往下翻可以看见是 <code>None</code>，<code>IntProperty</code> 等字符串，但是未识别成函数，按 <code>p</code> 也没有效果。因此查看这个 <code>loc_1C2E26C</code> 发现存在两个交叉引用，其中一个还是自己引用自己，所以跳转到第一个引用的地方。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327221728.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327221728.png?size=small" data-sub-html="<h2>20250327221728</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327221728.png alt=代码段交叉引用 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327221728.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327221728.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327221728.png?size=large 2x" data-title=20250327221728 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>代码段交叉引用</figcaption></figure>之后发现 <code>loc_1C2E0B0</code> 还是没有识别为函数，同时是最后跳转到上面的 <code>loc_1C2E26C</code>。查看这个小的代码片段没发现什么关键的地方，同时查看其交叉引用发现有很多函数调用这个地方，因此继续往上查看这个地方的调用点。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327222041.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327222041.png?size=small" data-sub-html="<h2>20250327222041</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327222041.png alt=代码段交叉引用 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327222041.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327222041.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327222041.png?size=large 2x" data-title=20250327222041 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>代码段交叉引用</figcaption></figure>随便选了交叉引用中的一个函数，发现这里就和之前找到 GName 的汇编代码很相近了。这里 R0 就是传入的 this 指针，也就是 GName，因此 <code>GName</code> 为 <code>0x4E2EC00</code>。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327222352.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327222352.png?size=small" data-sub-html="<h2>20250327222352</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327222352.png alt=交叉引用函数 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327222352.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327222352.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327222352.png?size=large 2x" data-title=20250327222352 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>交叉引用函数</figcaption></figure></p><h3 id=gname-验证 class=heading-element><span>GName 验证</span>
<a href=#gname-%e9%aa%8c%e8%af%81 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><h4 id=gadget-注入 class=heading-element><span>gadget 注入</span>
<a href=#gadget-%e6%b3%a8%e5%85%a5 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>上述找到 GName 的流程和平时不同，所以尝试利用 frida 来验证通过这里的 GName 获取字符串算法是否有效。但是发现 frida attach 没法注入，不过可以采用spawn 模式启动下面的代码，查看 apk 打开的 so 文件，但是过了一会儿就是自己退出。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// frida -U -F com.tencent.ace.gamematch2024final  -l .\hook.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>function</span> <span class=nx>hook_dlopen</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Interceptor</span><span class=p>.</span><span class=nx>attach</span><span class=p>(</span><span class=nx>Module</span><span class=p>.</span><span class=nx>findExportByName</span><span class=p>(</span><span class=kc>null</span><span class=p>,</span> <span class=s2>&#34;android_dlopen_ext&#34;</span><span class=p>),</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>onEnter</span><span class=o>:</span> <span class=kd>function</span> <span class=p>(</span><span class=nx>args</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kd>var</span> <span class=nx>soName</span> <span class=o>=</span> <span class=nx>args</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=nx>readCString</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=sb>`dlopen onEnter: </span><span class=si>${</span><span class=nx>soName</span><span class=si>}</span><span class=sb>`</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>},</span> 
</span></span><span class=line><span class=cl>        <span class=nx>onLeave</span><span class=o>:</span> <span class=kd>function</span> <span class=p>(</span><span class=nx>retval</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=sb>`dlopen onLeave: </span><span class=si>${</span><span class=nx>retval</span><span class=si>}</span><span class=sb>`</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>      
</span></span><span class=line><span class=cl>    <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>setImmediate</span><span class=p>(</span><span class=nx>hook_dlopen</span><span class=p>);</span></span></span></code></pre></td></tr></table></div></div><p>之后得到了下面的结果，可以看出首先打开了 libstats_jni.so，libUE4.so，libvrapi.so 等 so 文件。所以这里尝试使用 frida-gadget 注入来使用 frida。这里是对 apk 本身的 so 进行注入，同时尝试了对于 libUE4.so 注入会闪退，因此最后对 libvrapi.so 进行注入。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327223356.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327223356.png?size=small" data-sub-html="<h2>20250327223356</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327223356.png alt=frida结果 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327223356.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327223356.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327223356.png?size=large 2x" data-title=20250327223356 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>frida结果</figcaption></figure>这里的注入就是利用 lief 来给 libvrapi.so 文件添加依赖。通过下面的代码，libvrapi.so 就依赖 libfrida-gadget.so 了，这样在加载前者时，需要先将后者进行加载，这样就达到了注入 frida-gadget 的目的（注意这里只有 arm32，所以需要选择适当的 frida-gadget 文件）。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>lief</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>sys</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>str_so_apk</span> <span class=o>=</span> <span class=n>sys</span><span class=o>.</span><span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>str_so_gadget</span> <span class=o>=</span> <span class=n>sys</span><span class=o>.</span><span class=n>argv</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># python .\liefpatch.py libvrapi.so libfrida-gadget.so</span>
</span></span><span class=line><span class=cl><span class=n>libnative</span> <span class=o>=</span> <span class=n>lief</span><span class=o>.</span><span class=n>parse</span><span class=p>(</span><span class=n>str_so_apk</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>libnative</span><span class=o>.</span><span class=n>add_library</span><span class=p>(</span><span class=n>str_so_gadget</span><span class=p>)</span> <span class=c1># Injection!</span>
</span></span><span class=line><span class=cl><span class=n>libnative</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=n>str_so_apk</span><span class=p>)</span></span></span></code></pre></td></tr></table></div></div><p>之后就是把新的 libvrapi.so 和准备好的 libfrida-gadget.so 和 libfrida-gadget.config.so 都放入由上文 frida hook 得到的 apk 路径中去即可，具体可以参照 <a href="https://www.bilibili.com/video/BV13B2oYTELv/?spm_id_from=333.337.search-card.all.click&amp;vd_source=17ac9da9453dbd6d64b9616668574c5f" target=_blank rel="external nofollow noopener noreferrer">视频</a> 中的流程。或者使用 apktool 重打包 apk，把上述修改和需要添加的文件放入到 <code>lib/armeabi-v7a</code> 目录中，再使用 MT 管理器签名安装。其中 libfrida-gadget.config.so 是配置文件，内容如下。它规定了 frida-gadget 的交互规则，可以从 <a href=https://frida.re/docs/gadget/ target=_blank rel="external nofollow noopener noreferrer">官网</a> 找到相应解释。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;interaction&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;type&#34;</span><span class=p>:</span> <span class=s2>&#34;listen&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;address&#34;</span><span class=p>:</span> <span class=s2>&#34;127.0.0.1&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;port&#34;</span><span class=p>:</span> <span class=mi>27042</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;on_port_conflict&#34;</span><span class=p>:</span> <span class=s2>&#34;fail&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;on_load&#34;</span><span class=p>:</span> <span class=s2>&#34;wait&#34;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>这样都准备好了之后，再启动 apk，会发现它卡在了加载页面。这个时候就需要使用 <code>frida -U -F -l hook.js</code> 来加载 frida 脚本，这样 apk 才会继续运行到输入密码的界面。同时此时写的 frida 脚本也可以正常进行交互和响应了。</p><h4 id=算法验证 class=heading-element><span>算法验证</span>
<a href=#%e7%ae%97%e6%b3%95%e9%aa%8c%e8%af%81 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>这里的代码可以直接拿初赛的 <code>getNameFromId()</code> 函数来验证，不过这里因为是 arm32 的 apk，所以偏移需要进行适当调整。查看源码就只是 <code>offset_FRWLock</code> 和 <code>size_Block</code> 发生了变化，然后得到了下面的代码。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span><span class=lnt>79
</span><span class=lnt>80
</span><span class=lnt>81
</span><span class=lnt>82
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>GWorld_Offset</span> <span class=o>=</span> <span class=mh>0x4F5C0D0</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>GName_Offset</span> <span class=o>=</span> <span class=mh>0x4E2EC00</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>GUObjectArray_Offset</span> <span class=o>=</span> <span class=mh>0x4E533AC</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>GWorld</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>GName</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>moduleBase</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>init</span><span class=p>(</span><span class=nx>soName</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>module</span> <span class=o>=</span> <span class=nx>Process</span><span class=p>.</span><span class=nx>findModuleByName</span><span class=p>(</span><span class=nx>soName</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nx>module</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>moduleBase</span> <span class=o>=</span> <span class=nx>module</span><span class=p>.</span><span class=nx>base</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nx>GWorld</span> <span class=o>=</span> <span class=nx>moduleBase</span><span class=p>.</span><span class=nx>add</span><span class=p>(</span><span class=nx>GWorld_Offset</span><span class=p>).</span><span class=nx>readPointer</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=nx>GName</span> <span class=o>=</span> <span class=nx>moduleBase</span><span class=p>.</span><span class=nx>add</span><span class=p>(</span><span class=nx>GName_Offset</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=sb>`init success`</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>getNameFromId32</span><span class=p>(</span><span class=nx>ComparisonIndex</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*-----------------------------------------------------------------------------
</span></span></span><span class=line><span class=cl><span class=cm>        相关数据结构偏移与大小
</span></span></span><span class=line><span class=cl><span class=cm>    -----------------------------------------------------------------------------*/</span>
</span></span><span class=line><span class=cl>    <span class=c1>// FNameEntryAllocator 相关数据
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kr>const</span> <span class=nx>offset_FRWLock</span> <span class=o>=</span> <span class=mh>0x28</span><span class=p>;</span>                                  <span class=c1>// FRWLock 偏移量，32位系统下为 0x28
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kr>const</span> <span class=nx>offset_Blocks</span> <span class=o>=</span> <span class=nx>offset_FRWLock</span> <span class=o>+</span> <span class=mh>0x8</span><span class=p>;</span>                   <span class=c1>// Blocks 偏移量
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kr>const</span> <span class=nx>size_Stride</span> <span class=o>=</span> <span class=mh>0x2</span><span class=p>;</span>                                      <span class=c1>// FNameEntry 的大小
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kr>const</span> <span class=nx>size_Block</span> <span class=o>=</span> <span class=mh>0x4</span><span class=p>;</span>                                       <span class=c1>// Blocks 中存储的 uint8* 指针的大小，32位系统下为 4 字节
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// FNameEntryHanlder 相关数据
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kr>const</span> <span class=nx>FNameBlockOffsetBits</span> <span class=o>=</span> <span class=mi>16</span><span class=p>;</span>                              <span class=c1>// 块偏移量位数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kr>const</span> <span class=nx>FNameBlockOffsets</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=nx>FNameBlockOffsetBits</span><span class=p>;</span>          <span class=c1>// 块偏移量
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kr>const</span> <span class=nx>Block</span> <span class=o>=</span> <span class=nx>ComparisonIndex</span> <span class=o>&gt;&gt;</span> <span class=nx>FNameBlockOffsetBits</span><span class=p>;</span>        <span class=c1>// 块索引
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kr>const</span> <span class=nx>Offset</span> <span class=o>=</span> <span class=nx>ComparisonIndex</span> <span class=o>&amp;</span> <span class=p>(</span><span class=nx>FNameBlockOffsets</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>     <span class=c1>// 块内偏移量
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// FNameEntryHeader 相关数据
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kr>const</span> <span class=nx>bIsWideBit</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>                                         <span class=c1>// 判断是否为宽字符的位数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kr>const</span> <span class=nx>offset_LenBit</span> <span class=o>=</span> <span class=mi>6</span><span class=p>;</span>                                      <span class=c1>// 字符串长度位数的偏移
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// FNameEntry 相关数据
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kr>const</span> <span class=nx>offset_Union</span> <span class=o>=</span> <span class=mh>0x2</span><span class=p>;</span>                                     <span class=c1>// FNameEntry 中字符串 Union 的偏移量
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*-----------------------------------------------------------------------------
</span></span></span><span class=line><span class=cl><span class=cm>        相关数据结构计算
</span></span></span><span class=line><span class=cl><span class=cm>    -----------------------------------------------------------------------------*/</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 计算 FNameEntryAllocator 的地址
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kr>const</span> <span class=nx>FNameEntryAllocator</span> <span class=o>=</span> <span class=nx>GName</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 计算 Blocks 数组的地址
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kr>const</span> <span class=nx>Blocks</span> <span class=o>=</span> <span class=nx>FNameEntryAllocator</span><span class=p>.</span><span class=nx>add</span><span class=p>(</span><span class=nx>offset_Blocks</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 获取 Blocks 数组中块实例的地址
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kr>const</span> <span class=nx>BlockInstance</span> <span class=o>=</span> <span class=nx>Blocks</span><span class=p>.</span><span class=nx>add</span><span class=p>(</span><span class=nx>Block</span> <span class=o>*</span> <span class=nx>size_Block</span><span class=p>).</span><span class=nx>readPointer</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 计算 Resolve 返回的 FNameEntry 类型地址
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kr>const</span> <span class=nx>FNameEntry</span> <span class=o>=</span> <span class=nx>BlockInstance</span><span class=p>.</span><span class=nx>add</span><span class=p>(</span><span class=nx>size_Stride</span> <span class=o>*</span> <span class=nx>Offset</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 获取 FNameEntryHeader，它只有两个字节
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kr>const</span> <span class=nx>FNameEntryHeader</span> <span class=o>=</span> <span class=nx>FNameEntry</span><span class=p>.</span><span class=nx>readU16</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 获取字符串地址，长度，是否为宽字符标识
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kr>const</span> <span class=nx>str_addr</span> <span class=o>=</span> <span class=nx>FNameEntry</span><span class=p>.</span><span class=nx>add</span><span class=p>(</span><span class=nx>offset_Union</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>str_length</span> <span class=o>=</span> <span class=nx>FNameEntryHeader</span> <span class=o>&gt;&gt;</span> <span class=nx>offset_LenBit</span><span class=p>;</span>             <span class=c1>// 计算字符串长度
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kr>const</span> <span class=nx>wide</span> <span class=o>=</span> <span class=nx>FNameEntryHeader</span> <span class=o>&amp;</span> <span class=nx>bIsWideBit</span><span class=p>;</span>                       <span class=c1>// 判断字符串是否为宽字符
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// 如果是宽字符，返回 &#34;widestr&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=nx>wide</span><span class=p>)</span> <span class=k>return</span> <span class=s2>&#34;widestr&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 如果字符串长度合理，读取并返回UTF-8字符串
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=nx>str_length</span> <span class=o>&gt;</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>str_length</span> <span class=o>&lt;</span> <span class=mi>250</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>str_addr</span><span class=p>.</span><span class=nx>readCString</span><span class=p>(</span><span class=nx>str_length</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s2>&#34;Invalid length&#34;</span><span class=p>;</span> <span class=c1>// 长度不合理，返回 &#34;Invalid length&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>init</span><span class=p>(</span><span class=s2>&#34;libUE4.so&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kd>let</span> <span class=nx>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;</span> <span class=mi>50</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>let</span> <span class=nx>name</span> <span class=o>=</span> <span class=nx>getNameFromId32</span><span class=p>(</span><span class=nx>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=sb>`[+] name: </span><span class=si>${</span><span class=nx>name</span><span class=si>}</span><span class=sb>`</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>运行的结果如下所示，可以看出来这个 GName 是没有问题的，<code>FNmae::ToString()</code> 函数的功能可以实现。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250330195153.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250330195153.png?size=small" data-sub-html="<h2>20250330195153</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250330195153.png alt="frida 结果" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250330195153.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250330195153.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250330195153.png?size=large 2x" data-title=20250330195153 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>frida 结果</figcaption></figure></p><h2 id=dumpsdk class=heading-element><span>dumpSDK</span>
<a href=#dumpsdk class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>这里直接 dumpSDK 会发现报错，不能 dump，同时采用初始使用的 <code>getActorsMap</code> 也解析不到结果，由此怀疑更改了 UE 相关结构。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250330200342.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250330200342.png?size=small" data-sub-html="<h2>20250330200342</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250330200342.png alt=dump报错 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250330200342.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250330200342.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250330200342.png?size=large 2x" data-title=20250330200342 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>dump报错</figcaption></figure>因此这里就需要根据动态调试获取魔改的偏移，而关于 SDK 怎么获取，可以关注获取代码 <a href=https://github.com/czTangt/SDKDumper target=_blank rel="external nofollow noopener noreferrer">SDKDumper</a>。然后下面就是按照 <a href=https://cztangt.github.io/blog/posts/android/ue-structure/ target=_blank rel="external nofollow noopener noreferrer">UE 结构分析</a> 中的顺序来修正结构偏移获取信息。</p><h3 id=dump-strings class=heading-element><span>dump Strings</span>
<a href=#dump-strings class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>首先在手机中以 root 权限启动 ceserver_arm64，然后转发端口 52736，这样就可以使用 Cheat Engine 了。之后在 CE 中手动添加 GName 的地址 <code>libUE4.so + 0x4E2EC00</code>，然后 <code>Ctrl + B</code> 查看该地址的内存布局。这里由于是 32 位的程序，所以采用 4 字节 HEX 的方式查看。</p><p>查看该内存布局，按照正常的结构，前面的结构应该是 FNamePool 中的第一个结构 FNameEntryAllocator。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>FNamePool</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>FNameEntryAllocator</span> <span class=n>Entries</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>......</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>它一开始就是 <code>FRWLock Lock;</code>，在 32 位程序上占据 0x28 字节。因此剔除这 0x28 字节的数据，发现第一个 4 字节数据为 0xB，那么这个应该就是 <code>uint32 CurrentBlock</code> 了。同时在原本结构中，后面为 <code>uint32 CurrentByteCursor</code> 和 <code>uint8* Blocks[FNameMaxBlocks]</code>，那么红框中的指针就是 Blocks 的内容了。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>static</span> <span class=k>constexpr</span> <span class=n>uint32</span> <span class=n>FNameMaxBlockBits</span> <span class=o>=</span> <span class=mi>13</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>constexpr</span> <span class=n>uint32</span> <span class=n>FNameBlockOffsetBits</span> <span class=o>=</span> <span class=mi>16</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>constexpr</span> <span class=n>uint32</span> <span class=n>FNameMaxBlocks</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>FNameMaxBlockBits</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>constexpr</span> <span class=n>uint32</span> <span class=n>FNameBlockOffsets</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>FNameBlockOffsetBits</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>FNameEntryAllocator</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=k>enum</span> <span class=p>{</span> <span class=n>Stride</span> <span class=o>=</span> <span class=k>alignof</span><span class=p>(</span><span class=n>FNameEntry</span><span class=p>)</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>	<span class=k>enum</span> <span class=p>{</span> <span class=n>BlockSizeBytes</span> <span class=o>=</span> <span class=n>Stride</span> <span class=o>*</span> <span class=n>FNameBlockOffsets</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>mutable</span> <span class=n>FRWLock</span> <span class=n>Lock</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>uint32</span> <span class=n>CurrentBlock</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>uint32</span> <span class=n>CurrentByteCursor</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>uint8</span><span class=o>*</span> <span class=n>Blocks</span><span class=p>[</span><span class=n>FNameMaxBlocks</span><span class=p>]</span> <span class=o>=</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808101826.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808101826.png?size=small" data-sub-html="<h2>20250808101826</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808101826.png alt=FNamePool srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808101826.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808101826.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808101826.png?size=large 2x" data-title=20250808101826 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>FNamePool</figcaption></figure>之后按空格继续查看这些指针指向的内存布局，发现是一个个字符串，那么就确定这些都是 Block 了。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808102825.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808102825.png?size=small" data-sub-html="<h2>20250808102825</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808102825.png alt=Block srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808102825.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808102825.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808102825.png?size=large 2x" data-title=20250808102825 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>Block</figcaption></figure>这里按 Back 回退到原本的内存布局，刚好有（0xB + 1 = 0xC）个指针，它和 CurrentBlock 对应，那么直接修改相关偏移就可以 dump Strings。然后结合 dump 结果可以发现推测是正确的，这里的结构没有魔改。</p><h3 id=dump-sdk class=heading-element><span>dump SDK</span>
<a href=#dump-sdk class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><h4 id=对象获取 class=heading-element><span>对象获取</span>
<a href=#%e5%af%b9%e8%b1%a1%e8%8e%b7%e5%8f%96 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><h5 id=tuobjectarray class=heading-element><span>TUObjectArray</span>
<a href=#tuobjectarray class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>首先根据 GUObjectArray 来获取 FUObjectArray 结构的内存布局，前面 0x10 没有帮助，然后后面紧接着就是 <code>TUObjectArray ObjObjects;</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>COREUOBJECT_API</span> <span class=n>FUObjectArray</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=c1>//typedef TStaticIndirectArrayThreadSafeRead&lt;UObjectBase, 8 * 1024 * 1024 /* Max 8M UObjects */, 16384 /* allocated in 64K/128K chunks */ &gt; TUObjectArray;
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>typedef</span> <span class=n>FChunkedFixedUObjectArray</span> <span class=n>TUObjectArray</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// note these variables are left with the Obj prefix so they can be related to the historical GObj versions
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=cm>/** First index into objects array taken into account for GC.							*/</span>
</span></span><span class=line><span class=cl>	<span class=n>int32</span> <span class=n>ObjFirstGCIndex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cm>/** Index pointing to last object created in range disregarded for GC.					*/</span>
</span></span><span class=line><span class=cl>	<span class=n>int32</span> <span class=n>ObjLastNonGCIndex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cm>/** Maximum number of objects in the disregard for GC Pool */</span>
</span></span><span class=line><span class=cl>	<span class=n>int32</span> <span class=n>MaxObjectsNotConsideredByGC</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=cm>/** If true this is the intial load and we should load objects int the disregarded for GC range.	*/</span>
</span></span><span class=line><span class=cl>	<span class=kt>bool</span> <span class=n>OpenForDisregardForGC</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cm>/** Array of all live objects.											*/</span>
</span></span><span class=line><span class=cl>	<span class=n>TUObjectArray</span> <span class=n>ObjObjects</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>......</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>之后查看 TUObjectArray 结构，可以看到红框中的第一个 4 字节元素就是地址指针，它应该就是对应着 Objects。然后继续往后看，可以看到这些数值和类型都很对应，所以猜测这里没有进行魔改，只不过因为是 32 位程序，所以需要修改偏移。那么就知道这里 0x3C09 对应着 NumElements，偏移为 0xC。而 MaxChunks = 3，NumChunks = 1。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>FChunkedFixedUObjectArray</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>enum</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>NumElementsPerChunk</span> <span class=o>=</span> <span class=mi>64</span> <span class=o>*</span> <span class=mi>1024</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=cm>/** Master table to chunks of pointers **/</span>
</span></span><span class=line><span class=cl>	<span class=n>FUObjectItem</span><span class=o>**</span> <span class=n>Objects</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cm>/** If requested, a contiguous memory where all objects are allocated **/</span>
</span></span><span class=line><span class=cl>	<span class=n>FUObjectItem</span><span class=o>*</span> <span class=n>PreAllocatedObjects</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cm>/** Maximum number of elements **/</span>
</span></span><span class=line><span class=cl>	<span class=n>int32</span> <span class=n>MaxElements</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cm>/** Number of elements we currently have **/</span>
</span></span><span class=line><span class=cl>	<span class=n>int32</span> <span class=n>NumElements</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cm>/** Maximum number of chunks **/</span>
</span></span><span class=line><span class=cl>	<span class=n>int32</span> <span class=n>MaxChunks</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cm>/** Number of chunks we currently have **/</span>
</span></span><span class=line><span class=cl>	<span class=n>int32</span> <span class=n>NumChunks</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808144343.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808144343.png?size=small" data-sub-html="<h2>20250808144343</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808144343.png alt=FUObjectArray srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808144343.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808144343.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808144343.png?size=large 2x" data-title=20250808144343 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>FUObjectArray</figcaption></figure>这里确定了 0xB415B4FF0 这个地址指向了 Objects，因此按空格查看该地址的内存布局。因为上面 Objects 的类型为 <code>FUObjectItem** Objects;</code>，所以这里看到的不是 FUObjectItem 类型，而是一个个 Chunk(FUObjectItem *)。查看这里红框的部分，它有三个数据，刚好对应了上文的 MaxChunks。同时只有第一个不为零，是个地址指针，它也就对应着 NumChunks。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808153021.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808153021.png?size=small" data-sub-html="<h2>20250808153021</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808153021.png alt=0xB415B4FF0 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808153021.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808153021.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808153021.png?size=large 2x" data-title=20250808153021 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>0xB415B4FF0</figcaption></figure></p><h5 id=fuobjectitem class=heading-element><span>FUObjectItem</span>
<a href=#fuobjectitem class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>得到了 Chunk 之后，继续对第一个 Chunk 指针按空格查看 FUObjectItem 类型的内存布局。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>FUObjectItem</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Pointer to the allocated object
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>class</span> <span class=nc>UObjectBase</span><span class=o>*</span> <span class=n>Object</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Internal flags
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>int32</span> <span class=n>Flags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=c1>// UObject Owner Cluster Index
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>int32</span> <span class=n>ClusterRootIndex</span><span class=p>;</span>	
</span></span><span class=line><span class=cl>	<span class=c1>// Weak Object Pointer Serial number associated with the object
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>int32</span> <span class=n>SerialNumber</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>下面就是 FUObjectItem 类型的内存布局，这里首先对第一个结构进行分析，它是 0x00000000，不符合类型的第一个元素，那么猜想这里在最开始填充了 4 个字节的空数据。然后排除这个填充数据，发现后面第一个数据刚好是一个指针，于是猜想这里只是在最开始填充了数据，这样算每个 FUObjectItem 类型的大小就是 4 + 0x10 = 0x14 了。然后在图中使用竖线标明了每个结构的起始位置，可以看出每个结构的第一个数据刚好都是 0，然后后面一个数据刚好就是一个指针。于是这里就确定 FUObjectItem 中共的 Padd 为 0x4，大小为 0x14。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808153731.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808153731.png?size=small" data-sub-html="<h2>20250808153731</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808153731.png alt=FUObjectItem srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808153731.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808153731.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808153731.png?size=large 2x" data-title=20250808153731 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>FUObjectItem</figcaption></figure></p><h5 id=uobject class=heading-element><span>UObject</span>
<a href=#uobject class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>这里知道了 FUObjectItem，那么就根据结构查看 <code>class UObjectBase* Object;</code> 的内存布局。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>COREUOBJECT_API</span> <span class=n>UObjectBase</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>VTable</span><span class=p>;</span>                                        <span class=c1>//虚表指针，自己添加的
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=cm>/** Flags used to track and report various object states. This needs to be 8 byte aligned on 32-bit
</span></span></span><span class=line><span class=cl><span class=cm>	    platforms to reduce memory waste */</span>
</span></span><span class=line><span class=cl>	<span class=n>EObjectFlags</span>					<span class=n>ObjectFlags</span><span class=p>;</span>            <span class=c1>//对象属性
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=cm>/** Index into GObjectArray...very private. */</span>
</span></span><span class=line><span class=cl>	<span class=n>int32</span>							<span class=n>InternalIndex</span><span class=p>;</span>          <span class=c1>//对象 GUObjectArray 序号
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=cm>/** Class the object belongs to. */</span>
</span></span><span class=line><span class=cl>	<span class=n>UClass</span><span class=o>*</span>							<span class=n>ClassPrivate</span><span class=p>;</span>           <span class=c1>//对象的类
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=cm>/** Name of this object */</span>
</span></span><span class=line><span class=cl>	<span class=n>FName</span>							<span class=n>NamePrivate</span><span class=p>;</span>            <span class=c1>//对象的名字
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=cm>/** Object this object resides in. */</span>
</span></span><span class=line><span class=cl>	<span class=n>UObject</span><span class=o>*</span>						<span class=n>OuterPrivate</span><span class=p>;</span>           <span class=c1>//对象所在UPackage
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>这里因为第一个 0xBBDE5C00 不明显，所以就拿第二个 0xE6E4B580 来进行结构分析。这里直接看内存区域不明显，所以采用 内存查看 -> 工具 -> 分析数据/结构 来进行分析，输入地址之后点击 结构 -> 定义新的结构，设置好长度就会自动分析。之后分析的结果如下所示：<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808155615.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808155615.png?size=small" data-sub-html="<h2>20250808155615</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808155615.png alt=UObjectBase srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808155615.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808155615.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808155615.png?size=large 2x" data-title=20250808155615 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>UObjectBase</figcaption></figure>根据源码查看这个结构，可以看到从上到下的指针应该分别对应着 <code>VTable</code>，<code>UClass*</code>，<code>UObject*</code>，那么就确定了 ClassPrivate 的偏移为 0x14，OuterPrivate 的偏移为 0x20。然后红框中间的就是 FName，这里对象 ID 应该不为 0 ，那么就是 354，NamePrivate 的偏移也就是 0x18。</p><h5 id=function-获取信息 class=heading-element><span>Function 获取信息</span>
<a href=#function-%e8%8e%b7%e5%8f%96%e4%bf%a1%e6%81%af class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><h6 id=ufield class=heading-element><span>UField</span>
<a href=#ufield class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h6><p>这里就是寻找属性和方法获取过程中所需的结构偏移。上文得到的信息已经可以获取类的类名和名字了，那么就可以利用下面的代码获取 Object 的偏移，类名和对象名。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>DumpObjects</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>outputpath</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>ofstream</span> <span class=n>obj</span><span class=p>(</span><span class=n>outputpath</span> <span class=o>+</span> <span class=s>&#34;/Objects.txt&#34;</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>ofstream</span><span class=o>::</span><span class=n>out</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>obj</span><span class=p>.</span><span class=n>is_open</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>int32</span> <span class=n>count</span> <span class=o>=</span> <span class=n>GetObjectCount</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Total Objects: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>count</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>int32</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>count</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>kaddr</span> <span class=n>uobj</span> <span class=o>=</span> <span class=n>GetUObjectFromID</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>UObject</span><span class=o>::</span><span class=n>isValid</span><span class=p>(</span><span class=n>uobj</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>kaddr</span> <span class=n>classPtr</span> <span class=o>=</span> <span class=n>UObject</span><span class=o>::</span><span class=n>getClass</span><span class=p>(</span><span class=n>uobj</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>className</span> <span class=o>=</span> <span class=n>UObject</span><span class=o>::</span><span class=n>getClassName</span><span class=p>(</span><span class=n>uobj</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>objectName</span> <span class=o>=</span> <span class=n>UObject</span><span class=o>::</span><span class=n>getName</span><span class=p>(</span><span class=n>uobj</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>obj</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Ptr: 0x&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>hex</span> <span class=o>&lt;&lt;</span> <span class=n>uobj</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>className</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>objectName</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>然后从获取的对象里面寻找类名为 Function 的对象，因为函数一般都存在 <code>UField* Next;</code> 和 <code>FField* ChildProperties;</code> 两种类型。前者使得当前类可以不断寻找类的函数，后者则是存储函数的参数。这里就是寻找一个存在参数的函数来查看结构，因此根据经验选择了 MoveToActor 这个函数，它一般都存在参数。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808180322.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808180322.png?size=small" data-sub-html="<h2>20250808180322</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808180322.png alt=Function srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808180322.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808180322.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808180322.png?size=large 2x" data-title=20250808180322 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>Function</figcaption></figure>这里关心 0x2C 偏移处的数据，它是一个指针，展开查看它前面也符合 UObject 的内存布局，然后根据下面 UFunction 的源码结构来看，这个值应该就是 <code>UField* Next;</code>。因为这个数据在源码上离 OuterPrivate 最近，而结构分析中也是它离 OuterPrivate 最近，同时它符合 UObject 的内存布局，而 UField 又是继承自 UObject。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808180435.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808180435.png?size=small" data-sub-html="<h2>20250808180435</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808180435.png alt=UFunction srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808180435.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808180435.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808180435.png?size=large 2x" data-title=20250808180435 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>UFunction</figcaption></figure></p><h6 id=ffield class=heading-element><span>FField</span>
<a href=#ffield class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h6><p>同时推测下面这个 0x44 的数据为 <code>FField* ChildProperties;</code>。查看下面 FField 的源码结构，可以发现其中也存在一个 FField 的结构。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808180757.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808180757.png?size=small" data-sub-html="<h2>20250808180757</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808180757.png alt=FField srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808180757.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808180757.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808180757.png?size=large 2x" data-title=20250808180757 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>FField</figcaption></figure>然后查看 0x44 指针的结构分析，发现它在 0x10 位置也是一个指针，展开的类型和 0x44 展开的类型相似。之后继续展开 0x10 结构中 0x10 偏移的内存结构，发现也是近乎一样的，在 0x10 也有相似的指针。于是这里就可以推测这个 0x44 的指针就是 <code>FField* ChildProperties;</code>。同时这里也就知道了 FField 的 Next 指针偏移为 0x10，FName 就是 0x14。之后观察到 0x8 偏移的指针的结构符合 UObject 的结构，那么 ClassPrivate 的偏移就是 0x8。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808181003.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808181003.png?size=small" data-sub-html="<h2>20250808181003</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808181003.png alt=结构分析 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808181003.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808181003.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808181003.png?size=large 2x" data-title=20250808181003 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>结构分析</figcaption></figure></p><h6 id=functionflags class=heading-element><span>FunctionFlags</span>
<a href=#functionflags class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h6><p>这里推测 FunctionFlags 的偏移为 0x84，因为它会和 0x00000400 进行位运算来确定函数的返回值是否可以解析，这里根据经验，大多数的函数返回值都是可以解析的，那么这个值大概率会存在 0x00000400 这样的关键信息。而查看多个 Function，只有 0x84 这个偏移的值不是指针，同时基本包含关键信息。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808182031.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808182031.png?size=small" data-sub-html="<h2>20250808182031</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808182031.png alt=结构分析 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808182031.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808182031.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808182031.png?size=large 2x" data-title=20250808182031 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>结构分析</figcaption></figure></p><h6 id=func class=heading-element><span>Func</span>
<a href=#func class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h6><p>之后继续拿多个地址进行分析来确定 <code>FNativeFuncPtr Func;</code> 的偏移。它首先是一个指针，指向一个地址。这里根据别的游戏 SDK 的信息得到同一个类下连续的 Function，然后在上面 Objects.txt 中发现这个游戏也有这些函数。因此就根据指针，且指向的地址减去基址的前面 4 bit 一样，后面数值相差不大的原则寻找，发现 0xA4 偏移的数据符合这个原则，因此确定它指向的就是函数的偏移 Func。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808183831.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808183831.png?size=small" data-sub-html="<h2>20250808183831</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808183831.png alt=结构分析 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808183831.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808183831.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808183831.png?size=large 2x" data-title=20250808183831 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>结构分析</figcaption></figure></p><h5 id=class-获取信息 class=heading-element><span>Class 获取信息</span>
<a href=#class-%e8%8e%b7%e5%8f%96%e4%bf%a1%e6%81%af class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>这里从 Objects.txt 中选出 Actor 和 Object 两个类进行结构分析。因为 Actor 继承自 Object 类，同时 Object 类是一个顶级类，它不再继承其他的了（从别的游戏的 sdk 中得到的信息），因此这里就挑选这两个类进行分析。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808190638.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808190638.png?size=small" data-sub-html="<h2>20250808190638</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808190638.png alt=结构分析 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808190638.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808190638.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808190638.png?size=large 2x" data-title=20250808190638 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>结构分析</figcaption></figure>这里左边是 Actor，右边是 Object，然后分析发现 Actor 在 0x40 位置的指针刚好指向右侧 Object 的地址，然后 Object 这个地方的数据为 0。那么剔除掉 ClassPrivate，可以确定这个偏移的数据就是 SuperStruct。而且这里观察 0x40 偏移指针的结构，发现它也符合 UObject 的内存布局，这说明推测是对的。</p><p>然后这里 0x6C 偏移的指针也符合 UObject 的内存布局，那么根据下图 UClass 的内存布局推测这个偏移就是 <code>UField* Children;</code>。因为 UClass 中只剩下这个数据符合 UObject 的内存布局了，其他的要么已经知道了偏移，要么偏移差距太大了。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808191105.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808191105.png?size=small" data-sub-html="<h2>20250808191105</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808191105.png alt=UClass srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808191105.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808191105.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808191105.png?size=large 2x" data-title=20250808191105 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>UClass</figcaption></figure></p><h2 id=参考资料 class=heading-element><span>参考资料</span>
<a href=#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><div class="details admonition quote open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-quote-right" aria-hidden=true></i>参考</div><div class=details-content><div class=admonition-content><p><ul><li><a href=https://bbs.kanxue.com/thread-281463.htm target=_blank rel="external nofollow noopener noreferrer">腾讯游戏安全技术竞赛2024决赛 安卓方向解题报告</a></li><li><a href=https://bbs.kanxue.com/thread-281464.htm target=_blank rel="external nofollow noopener noreferrer">2024腾讯游戏安全大赛-安卓赛道决赛VM分析与还原</a></li><li><a href=http://www.yxfzedu.com/article/12302 target=_blank rel="external nofollow noopener noreferrer">Android安全-2024騰訊遊戲安全大賽安卓決賽(復現)</a></li><li><a href=https://blog.lleavesg.top/article/Android-Seccomp target=_blank rel="external nofollow noopener noreferrer">Android环境下Seccomp对系统调用的监控</a></li><li><a href=https://bbs.kanxue.com/thread-282857.htm#msg_header_h2_4 target=_blank rel="external nofollow noopener noreferrer">UE4.27SDK-Dump</a></li></ul></div></div></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2025-08-07 10:38:36">更新于 2025.8.7&nbsp;
<a class=git-hash href=https://github.com/czTangt/blog.git/commit/be83e5ca1b8278eae2151c565bc4cb260143909b rel="external nofollow noopener noreferrer" target=_blank title="commit by czTangt(cz.tangt@gmail.com) be83e5ca1b8278eae2151c565bc4cb260143909b: modify tencent2024_final"><i class="fa-solid fa-hashtag fa-fw" aria-hidden=true></i>be83e5c</a></span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href="https://github.com/czTangt/blog.git/blob/main/content/posts%5candroid%5c2024_Tencent_GameSec_Final.md?plain=1" title=查看源码 target=_blank rel="external nofollow noopener noreferrer" class=link-to-source>查看源码</a></span><span><a href=https://github.com/czTangt/blog.git/edit/main/content/posts%5candroid%5c2024_Tencent_GameSec_Final.md title=编辑此页 target=_blank rel="external nofollow noopener noreferrer" class=link-to-edit>编辑此页</a></span><span><a href="https://github.com/czTangt/blog.git/issues/new?title=[BUG]%202024%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B%E5%86%B3%E8%B5%9B&amp;body=%7cField%7cValue%7c%0A%7c-%7c-%7c%0A%7cTitle%7c2024%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B%E5%86%B3%E8%B5%9B%7c%0A%7cURL%7chttps://czTangt.github.io/blog/posts/android/2024-tencent-gamesec-final/%7c%0A%7cFilename%7chttps://github.com/czTangt/blog.git/blob/main/content/posts%5candroid%5c2024_Tencent_GameSec_Final.md?plain=1%7c" title=报告问题 target=_blank rel="external nofollow noopener noreferrer" class=link-to-report>报告问题</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 X" data-sharer=twitter data-url=https://czTangt.github.io/blog/posts/android/2024-tencent-gamesec-final/ data-title=2024腾讯游戏安全竞赛决赛 data-hashtags=android,game><i class="fa-brands fa-x-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://czTangt.github.io/blog/posts/android/2024-tencent-gamesec-final/ data-hashtag=android><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://czTangt.github.io/blog/posts/android/2024-tencent-gamesec-final/ data-title=2024腾讯游戏安全竞赛决赛><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/blog/tags/android/ class=post-tag title="标签 - Android">Android</a><a href=/blog/tags/game/ class=post-tag title="标签 - Game">Game</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/blog/>主页</a></span></section></div><div class=post-nav><a href=/blog/posts/android/2024-tencent-gamesec-prelim/ class=post-nav-item rel=prev title=2024腾讯游戏安全竞赛初赛><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>2024腾讯游戏安全竞赛初赛</a><a href=/blog/posts/android/ue-structure/ class=post-nav-item rel=next title="UE 结构分析">UE 结构分析<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article><aside class=toc id=toc-auto aria-label=目录><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside></main><footer class=footer><div class=footer-container><div class="footer-line powered order-1">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.136.5"><img class=hugo-icon src=/blog/images/hugo.min.svg alt="Hugo logo"> Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.3.17-30a67c4b"><img class=fixit-icon src=/blog/images/fixit.min.svg alt="FixIt logo"> FixIt</a></div><div class="footer-line copyright order-2" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2024 - 2025</span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class="variant-numeric d-none">0%</span></div></div><a href=https://github.com/czTangt/blog title="View source on GitHub" target=_blank rel="external nofollow" class="github-corner left d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true" width="56" height="56"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><noscript><div class=noscript-warning>该网站在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/blog/lib/lightgallery/css/lightgallery-bundle.min.css><link rel=preload href=/blog/lib/katex/katex.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/blog/lib/katex/katex.min.css></noscript><link rel=stylesheet href=/blog/lib/cookieconsent/cookieconsent.min.css><script src=/blog/lib/autocomplete/autocomplete.min.js defer></script><script src=/blog/lib/fuse/fuse.min.js defer></script><script src=/blog/lib/lightgallery/lightgallery.min.js defer></script><script src=/blog/lib/lightgallery/plugins/thumbnail/lg-thumbnail.min.js defer></script><script src=/blog/lib/lightgallery/plugins/zoom/lg-zoom.min.js defer></script><script src=/blog/lib/sharer/sharer.min.js async defer></script><script src=/blog/lib/katex/katex.min.js defer></script><script src=/blog/lib/katex/auto-render.min.js defer></script><script src=/blog/lib/katex/mhchem.min.js defer></script><script src=/blog/lib/cookieconsent/cookieconsent.min.js defer></script><script src=/blog/js/codeblock.js defer></script><script src=https://libs.baidu.com/jquery/2.1.4/jquery.min.js defer></script><script>window.config={code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:10},comment:{enable:!1},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},lightgallery:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{distance:100,findAllMatches:!1,fuseIndexURL:"/blog/search.json",highlightTag:"em",ignoreFieldNorm:!1,ignoreLocation:!1,isCaseSensitive:!1,location:0,maxResultLength:10,minMatchCharLength:2,noResultsFound:"没有找到结果",snippetLength:30,threshold:.3,type:"fuse",useExtendedSearch:!1},version:"v0.3.17-30a67c4b"}</script><script src=/blog/js/theme.min.js defer></script></body></html>