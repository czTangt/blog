<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>2024腾讯游戏安全竞赛决赛 - czTang</title><meta name=author content="czTang">
<meta name=description content="记录一下对于2024腾讯游戏安全竞赛安卓赛道的复现。
"><meta name=keywords content='android,game'><meta itemprop=name content="2024腾讯游戏安全竞赛决赛"><meta itemprop=description content="记录一下对于2024腾讯游戏安全竞赛安卓赛道的复现。"><meta itemprop=datePublished content="2025-03-27T10:19:48+08:00"><meta itemprop=dateModified content="2025-08-10T11:21:40+08:00"><meta itemprop=wordCount content="4436"><meta itemprop=keywords content="Android,Game"><meta property="og:url" content="https://czTangt.github.io/blog/posts/android/2024-tencent-gamesec-final/"><meta property="og:site_name" content="czTang"><meta property="og:title" content="2024腾讯游戏安全竞赛决赛"><meta property="og:description" content="记录一下对于2024腾讯游戏安全竞赛安卓赛道的复现。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-03-27T10:19:48+08:00"><meta property="article:modified_time" content="2025-08-10T11:21:40+08:00"><meta property="article:tag" content="Android"><meta property="article:tag" content="Game"><meta name=twitter:card content="summary"><meta name=twitter:title content="2024腾讯游戏安全竞赛决赛"><meta name=twitter:description content="记录一下对于2024腾讯游戏安全竞赛安卓赛道的复现。"><meta name=application-name content="FixIt"><meta name=apple-mobile-web-app-title content="FixIt"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel=icon href=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410312135963.svg><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical type=text/html href=https://czTangt.github.io/blog/posts/android/2024-tencent-gamesec-final/ title="2024腾讯游戏安全竞赛决赛 - czTang"><link rel=prev type=text/html href=https://czTangt.github.io/blog/posts/android/2024-tencent-gamesec-prelim/ title=2024腾讯游戏安全竞赛初赛><link rel=next type=text/html href=https://czTangt.github.io/blog/posts/android/ue-structure/ title="UE 结构分析"><link rel=stylesheet href=/blog/css/style.min.css><link rel=preload href=/blog/lib/fontawesome-free/all.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/blog/lib/fontawesome-free/all.min.css></noscript><link rel=preload href=/blog/lib/animate/animate.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/blog/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"2024腾讯游戏安全竞赛决赛","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/czTangt.github.io\/blog\/posts\/android\/2024-tencent-gamesec-final\/"},"genre":"posts","keywords":"android, game","wordcount":4436,"url":"https:\/\/czTangt.github.io\/blog\/posts\/android\/2024-tencent-gamesec-final\/","datePublished":"2025-03-27T10:19:48+08:00","dateModified":"2025-08-10T11:21:40+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"czTang"},"description":""}</script><script src=/blog/js/head/color-scheme.min.js></script></head><body data-header-desktop=sticky data-header-mobile=auto><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=left><div class=header-title><a href=/blog/ title=czTang><span class=header-title-pre><i class='fa fa-coffee'>&nbsp</i></span><span class=header-title-text>czTang</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/blog/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 归档</a></li><li class=menu-item><a class=menu-link href=/blog/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/blog/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/blog/about/><i class="fa-solid fa-user fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/blog/ title=czTang><span class=header-title-pre><i class='fa fa-coffee'>&nbsp</i></span><span class=header-title-text>czTang</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/blog/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 归档</a></li><li class=menu-item><a class=menu-link href=/blog/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/blog/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/blog/about/><i class="fa-solid fa-user fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=container><aside class="aside-collection animate__animated animate__fadeIn animate__faster" aria-label=合集><div class="details collection-details open"><div class="details-summary collection-summary"><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i>
<span class=collection-name title=合集>Game</span>
<span class=collection-count>3</span><i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class="details-content collection-content"><nav><ul class=collection-list><li class=collection-item><a href=/blog/posts/android/2024-tencent-gamesec-prelim/ title=2024腾讯游戏安全竞赛初赛>2024腾讯游戏安全竞赛初赛</a></li><li class=collection-item><span class=active title=2024腾讯游戏安全竞赛决赛>2024腾讯游戏安全竞赛决赛</span></li><li class=collection-item><a href=/blog/posts/android/ue-structure/ title="UE 结构分析">UE 结构分析</a></li></ul><div class=collection-nav-simple><a href=/blog/posts/android/2024-tencent-gamesec-prelim/ class=collection-nav-item rel=prev title=2024腾讯游戏安全竞赛初赛><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i></a><span class=text-secondary>2/3</span><a href=/blog/posts/android/ue-structure/ class=collection-nav-item rel=next title="UE 结构分析"><i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></nav></div></div></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>2024腾讯游戏安全竞赛决赛</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/czTangt title=作者 target=_blank rel="external nofollow noopener noreferrer author" class=author><img loading=lazy src=/blog/images/avatar.jpg alt=czTang data-title=czTang width=20 height=20 class=avatar style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'>&nbsp;czTang</a></span><span class=post-included-in>&nbsp;收录于 <a href=/blog/categories/android/ class=post-category title="分类 - Android"><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> Android</a> 和 <a href=/blog/collections/game/ class=post-collection title="合集 - Game"><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i> Game</a></span></div><div class=post-meta-line><span title="发布于 2025-03-27 10:19:48"><i class="fa-solid fa-calendar-days fa-fw me-1" aria-hidden=true></i><time datetime=2025.3.27>2025.3.27</time></span>&nbsp;<span title="更新于 2025-08-10 11:21:40"><i class="fa-regular fa-calendar-check fa-fw me-1" aria-hidden=true></i><time datetime=2025.8.10>2025.8.10</time></span>&nbsp;<span title="4436 字"><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 4500 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 9 分钟</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#版本与结构>版本与结构</a></li><li><a href=#dumpsdk>dumpSDK</a><ul><li><a href=#dump-strings>dump Strings</a></li><li><a href=#dump-sdk>dump SDK</a><ul><li><a href=#对象获取>对象获取</a><ul><li><a href=#tuobjectarray>TUObjectArray</a></li><li><a href=#fuobjectitem>FUObjectItem</a></li><li><a href=#uobject>UObject</a></li></ul></li><li><a href=#function-获取信息>Function 获取信息</a><ul><li><a href=#next>Next</a></li><li><a href=#childproperties>ChildProperties</a></li><li><a href=#functionflags>FunctionFlags</a></li><li><a href=#func>Func</a></li></ul></li><li><a href=#class-获取信息>Class 获取信息</a></li><li><a href=#enum-获取信息>Enum 获取信息</a></li></ul></li><li><a href=#dump-actor>dump Actor</a></li></ul></li><li><a href=#参考资料>参考资料</a></li></ul></nav></div></div><div class=content id=content><p>记录一下对于2024腾讯游戏安全竞赛安卓赛道的复现。</p><h2 id=版本与结构 class=heading-element><span>版本与结构</span>
<a href=#%e7%89%88%e6%9c%ac%e4%b8%8e%e7%bb%93%e6%9e%84 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>按照初赛的逻辑，首先查看这个游戏的 ue 版本，然后发现和初赛一样，在 libUE4.so 中发现了 <code>++UE4+Release-4.27</code>，确定是 4.27 版本，不过这里是 32 位架构的程序。然后就是按照常规流程来寻找 GWorld，GUObjectArray，GName 三件套。对于前面两个而言，就是通过 <code>SeamlessTravel FlushLevelStreaming</code> 和 <code>CloseDisregardForGC</code> 进行字符串交叉引用即可找到。然后由下图得到了 <code>GWorld</code> 为 <code>0x4F5C0D0</code>，<code>GUObjectArray</code> 为 <code>0x4E533AC</code>。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327214918.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327214918.png?size=small" data-sub-html="<h2>20250327214918</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327214918.png alt=GWorld srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327214918.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327214918.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327214918.png?size=large 2x" data-title=20250327214918 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>GWorld</figcaption></figure><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327220856.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327220856.png?size=small" data-sub-html="<h2>20250327220856</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327220856.png alt=GUObjectArray srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327220856.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327220856.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327220856.png?size=large 2x" data-title=20250327220856 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>GUObjectArray</figcaption></figure>不过这里按照常规流程却不好解析 GName 这个关键结构。这里首先搜索字符串 <code>ByteProperty</code>，然后排除上面的宽字符串（因为没有交叉引用），找到最后一个字符串找到其交叉引用。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327221140.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327221140.png?size=small" data-sub-html="<h2>20250327221140</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327221140.png alt=ByteProperty搜索 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327221140.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327221140.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327221140.png?size=large 2x" data-title=20250327221140 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>ByteProperty搜索</figcaption></figure>然后这里就是不同之处了，这里往下翻可以看见是 <code>None</code>，<code>IntProperty</code> 等字符串，但是未识别成函数，按 <code>p</code> 也没有效果。因此查看这个 <code>loc_1C2E26C</code> 发现存在两个交叉引用，其中一个还是自己引用自己，所以跳转到第一个引用的地方。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327221728.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327221728.png?size=small" data-sub-html="<h2>20250327221728</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327221728.png alt=代码段交叉引用 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327221728.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327221728.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327221728.png?size=large 2x" data-title=20250327221728 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>代码段交叉引用</figcaption></figure>之后发现 <code>loc_1C2E0B0</code> 还是没有识别为函数，同时是最后跳转到上面的 <code>loc_1C2E26C</code>。查看这个小的代码片段没发现什么关键的地方，同时查看其交叉引用发现有很多函数调用这个地方，因此继续往上查看这个地方的调用点。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327222041.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327222041.png?size=small" data-sub-html="<h2>20250327222041</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327222041.png alt=代码段交叉引用 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327222041.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327222041.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327222041.png?size=large 2x" data-title=20250327222041 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>代码段交叉引用</figcaption></figure>随便选了交叉引用中的一个函数，发现这里就和之前找到 GName 的汇编代码很相近了。这里 R0 就是传入的 this 指针，也就是 GName，因此 <code>GName</code> 为 <code>0x4E2EC00</code>。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327222352.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327222352.png?size=small" data-sub-html="<h2>20250327222352</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327222352.png alt=交叉引用函数 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327222352.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327222352.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250327222352.png?size=large 2x" data-title=20250327222352 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>交叉引用函数</figcaption></figure></p><h2 id=dumpsdk class=heading-element><span>dumpSDK</span>
<a href=#dumpsdk class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>获取上述结构偏移之后就准备 dumpSDK 了，但是这里使用 <a href=https://github.com/revercc/UE4Dumper target=_blank rel="external nofollow noopener noreferrer">UE4Dumper</a> 发现报错，而且解析的对象数量也不对，由此怀疑更改了 UE 相关结构。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250330200342.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250330200342.png?size=small" data-sub-html="<h2>20250330200342</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250330200342.png alt=dump报错 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250330200342.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250330200342.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250330200342.png?size=large 2x" data-title=20250330200342 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>dump报错</figcaption></figure>因此这里就需要动态调试获取魔改的偏移，这里结合<a href=https://cztangt.github.io/blog/posts/android/ue-structure/ target=_blank rel="external nofollow noopener noreferrer">UE 结构分析</a>的内容分析结构获取偏移，然后修改 <a href=https://github.com/czTangt/SDKDumper target=_blank rel="external nofollow noopener noreferrer">SDKDumper</a> 中的偏移来 dumpSDK。</p><h3 id=dump-strings class=heading-element><span>dump Strings</span>
<a href=#dump-strings class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>首先在手机中以 root 权限启动 ceserver_arm64，然后转发端口 52736，这样就可以使用 Cheat Engine 了。之后在 CE 中手动添加 GName 的地址 <code>libUE4.so + 0x4E2EC00</code>，然后 <code>Ctrl + B</code> 查看该地址的内存布局。这里由于是 32 位的程序，所以采用 4 字节 HEX 的方式查看。</p><p>查看该内存布局，按照正常的结构，前面的结构应该是 FNamePool 中的第一个结构 FNameEntryAllocator。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>FNamePool</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>FNameEntryAllocator</span> <span class=n>Entries</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>......</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>它一开始就是 <code>FRWLock Lock;</code>，在 32 位程序上占据 0x28 字节。因此剔除这 0x28 字节的数据，发现第一个 4 字节数据为 0xB，那么这个应该就是 <code>uint32 CurrentBlock</code> 了。同时在原本结构中，后面为 <code>uint32 CurrentByteCursor</code> 和 <code>uint8* Blocks[FNameMaxBlocks]</code>，那么红框中的指针就是 Blocks 的内容了。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>static</span> <span class=k>constexpr</span> <span class=n>uint32</span> <span class=n>FNameMaxBlockBits</span> <span class=o>=</span> <span class=mi>13</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>constexpr</span> <span class=n>uint32</span> <span class=n>FNameBlockOffsetBits</span> <span class=o>=</span> <span class=mi>16</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>constexpr</span> <span class=n>uint32</span> <span class=n>FNameMaxBlocks</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>FNameMaxBlockBits</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>constexpr</span> <span class=n>uint32</span> <span class=n>FNameBlockOffsets</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>FNameBlockOffsetBits</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>FNameEntryAllocator</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=k>enum</span> <span class=p>{</span> <span class=n>Stride</span> <span class=o>=</span> <span class=k>alignof</span><span class=p>(</span><span class=n>FNameEntry</span><span class=p>)</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>	<span class=k>enum</span> <span class=p>{</span> <span class=n>BlockSizeBytes</span> <span class=o>=</span> <span class=n>Stride</span> <span class=o>*</span> <span class=n>FNameBlockOffsets</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>mutable</span> <span class=n>FRWLock</span> <span class=n>Lock</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>uint32</span> <span class=n>CurrentBlock</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>uint32</span> <span class=n>CurrentByteCursor</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>uint8</span><span class=o>*</span> <span class=n>Blocks</span><span class=p>[</span><span class=n>FNameMaxBlocks</span><span class=p>]</span> <span class=o>=</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808101826.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808101826.png?size=small" data-sub-html="<h2>20250808101826</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808101826.png alt=FNamePool srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808101826.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808101826.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808101826.png?size=large 2x" data-title=20250808101826 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>FNamePool</figcaption></figure>之后按空格继续查看这些指针指向的内存布局，发现是一个个字符串，那么就确定这些都是 Block 了。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808102825.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808102825.png?size=small" data-sub-html="<h2>20250808102825</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808102825.png alt=Block srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808102825.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808102825.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808102825.png?size=large 2x" data-title=20250808102825 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>Block</figcaption></figure>这里按 Back 回退到原本的内存布局，刚好有（0xB + 1 = 0xC）个指针，它和 CurrentBlock 对应，那么直接修改相关偏移就可以 dump Strings。然后结合 dump 结果可以发现推测是正确的，这里的结构没有魔改。</p><h3 id=dump-sdk class=heading-element><span>dump SDK</span>
<a href=#dump-sdk class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><h4 id=对象获取 class=heading-element><span>对象获取</span>
<a href=#%e5%af%b9%e8%b1%a1%e8%8e%b7%e5%8f%96 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><h5 id=tuobjectarray class=heading-element><span>TUObjectArray</span>
<a href=#tuobjectarray class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>首先根据 GUObjectArray 来获取 FUObjectArray 结构的内存布局，前面 0x10 没有帮助，然后后面紧接着就是 <code>TUObjectArray ObjObjects;</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>COREUOBJECT_API</span> <span class=n>FUObjectArray</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=c1>//typedef TStaticIndirectArrayThreadSafeRead&lt;UObjectBase, 8 * 1024 * 1024 /* Max 8M UObjects */, 16384 /* allocated in 64K/128K chunks */ &gt; TUObjectArray;
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>typedef</span> <span class=n>FChunkedFixedUObjectArray</span> <span class=n>TUObjectArray</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// note these variables are left with the Obj prefix so they can be related to the historical GObj versions
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=cm>/** First index into objects array taken into account for GC.							*/</span>
</span></span><span class=line><span class=cl>	<span class=n>int32</span> <span class=n>ObjFirstGCIndex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cm>/** Index pointing to last object created in range disregarded for GC.					*/</span>
</span></span><span class=line><span class=cl>	<span class=n>int32</span> <span class=n>ObjLastNonGCIndex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cm>/** Maximum number of objects in the disregard for GC Pool */</span>
</span></span><span class=line><span class=cl>	<span class=n>int32</span> <span class=n>MaxObjectsNotConsideredByGC</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=cm>/** If true this is the intial load and we should load objects int the disregarded for GC range.	*/</span>
</span></span><span class=line><span class=cl>	<span class=kt>bool</span> <span class=n>OpenForDisregardForGC</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cm>/** Array of all live objects.											*/</span>
</span></span><span class=line><span class=cl>	<span class=n>TUObjectArray</span> <span class=n>ObjObjects</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>......</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>之后查看 TUObjectArray 结构，可以看到红框中的第一个 4 字节元素就是地址指针，它应该就是对应着 Objects。然后继续往后看，可以看到这些数值和类型都很对应，所以猜测这里没有进行魔改，只不过因为是 32 位程序，所以需要修改偏移。那么就知道这里 0x3C09 对应着 NumElements，偏移为 0xC。而 MaxChunks = 3，NumChunks = 1。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>FChunkedFixedUObjectArray</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>enum</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>NumElementsPerChunk</span> <span class=o>=</span> <span class=mi>64</span> <span class=o>*</span> <span class=mi>1024</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=cm>/** Master table to chunks of pointers **/</span>
</span></span><span class=line><span class=cl>	<span class=n>FUObjectItem</span><span class=o>**</span> <span class=n>Objects</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cm>/** If requested, a contiguous memory where all objects are allocated **/</span>
</span></span><span class=line><span class=cl>	<span class=n>FUObjectItem</span><span class=o>*</span> <span class=n>PreAllocatedObjects</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cm>/** Maximum number of elements **/</span>
</span></span><span class=line><span class=cl>	<span class=n>int32</span> <span class=n>MaxElements</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cm>/** Number of elements we currently have **/</span>
</span></span><span class=line><span class=cl>	<span class=n>int32</span> <span class=n>NumElements</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cm>/** Maximum number of chunks **/</span>
</span></span><span class=line><span class=cl>	<span class=n>int32</span> <span class=n>MaxChunks</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cm>/** Number of chunks we currently have **/</span>
</span></span><span class=line><span class=cl>	<span class=n>int32</span> <span class=n>NumChunks</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808144343.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808144343.png?size=small" data-sub-html="<h2>20250808144343</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808144343.png alt=FUObjectArray srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808144343.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808144343.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808144343.png?size=large 2x" data-title=20250808144343 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>FUObjectArray</figcaption></figure>这里确定了 0xB415B4FF0 这个地址指向了 Objects，因此按空格查看该地址的内存布局。因为上面 Objects 的类型为 <code>FUObjectItem** Objects;</code>，所以这里看到的不是 FUObjectItem 类型，而是一个个 Chunk(FUObjectItem *)。查看这里红框的部分，它有三个数据，刚好对应了上文的 MaxChunks。同时只有第一个不为零，是个地址指针，它也就对应着 NumChunks。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808153021.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808153021.png?size=small" data-sub-html="<h2>20250808153021</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808153021.png alt=0xB415B4FF0 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808153021.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808153021.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808153021.png?size=large 2x" data-title=20250808153021 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>0xB415B4FF0</figcaption></figure></p><h5 id=fuobjectitem class=heading-element><span>FUObjectItem</span>
<a href=#fuobjectitem class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>得到了 Chunk 之后，继续对第一个 Chunk 指针按空格查看 FUObjectItem 类型的内存布局。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>FUObjectItem</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Pointer to the allocated object
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>class</span> <span class=nc>UObjectBase</span><span class=o>*</span> <span class=n>Object</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Internal flags
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>int32</span> <span class=n>Flags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=c1>// UObject Owner Cluster Index
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>int32</span> <span class=n>ClusterRootIndex</span><span class=p>;</span>	
</span></span><span class=line><span class=cl>	<span class=c1>// Weak Object Pointer Serial number associated with the object
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>int32</span> <span class=n>SerialNumber</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>下面就是 FUObjectItem 类型的内存布局，这里首先对第一个结构进行分析，它是 0x00000000，不符合类型的第一个元素，那么猜想这里在最开始填充了 4 个字节的空数据。然后排除这个填充数据，发现后面第一个数据刚好是一个指针，于是猜想这里只是在最开始填充了数据，这样算每个 FUObjectItem 类型的大小就是 4 + 0x10 = 0x14 了。然后在图中使用竖线标明了每个结构的起始位置，可以看出每个结构的第一个数据刚好都是 0，然后后面一个数据刚好就是一个指针。于是这里就确定 FUObjectItem 中共的 Padd 为 0x4，大小为 0x14。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808153731.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808153731.png?size=small" data-sub-html="<h2>20250808153731</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808153731.png alt=FUObjectItem srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808153731.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808153731.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808153731.png?size=large 2x" data-title=20250808153731 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>FUObjectItem</figcaption></figure></p><h5 id=uobject class=heading-element><span>UObject</span>
<a href=#uobject class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>这里知道了 FUObjectItem，那么就根据结构查看 <code>class UObjectBase* Object;</code> 的内存布局。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>COREUOBJECT_API</span> <span class=n>UObjectBase</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>VTable</span><span class=p>;</span>                                        <span class=c1>//虚表指针，自己添加的
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=cm>/** Flags used to track and report various object states. This needs to be 8 byte aligned on 32-bit
</span></span></span><span class=line><span class=cl><span class=cm>	    platforms to reduce memory waste */</span>
</span></span><span class=line><span class=cl>	<span class=n>EObjectFlags</span>					<span class=n>ObjectFlags</span><span class=p>;</span>            <span class=c1>//对象属性
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=cm>/** Index into GObjectArray...very private. */</span>
</span></span><span class=line><span class=cl>	<span class=n>int32</span>							<span class=n>InternalIndex</span><span class=p>;</span>          <span class=c1>//对象 GUObjectArray 序号
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=cm>/** Class the object belongs to. */</span>
</span></span><span class=line><span class=cl>	<span class=n>UClass</span><span class=o>*</span>							<span class=n>ClassPrivate</span><span class=p>;</span>           <span class=c1>//对象的类
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=cm>/** Name of this object */</span>
</span></span><span class=line><span class=cl>	<span class=n>FName</span>							<span class=n>NamePrivate</span><span class=p>;</span>            <span class=c1>//对象的名字
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=cm>/** Object this object resides in. */</span>
</span></span><span class=line><span class=cl>	<span class=n>UObject</span><span class=o>*</span>						<span class=n>OuterPrivate</span><span class=p>;</span>           <span class=c1>//对象所在UPackage
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>这里因为第一个 0xBBDE5C00 不明显，所以就拿第二个 0xE6E4B580 来进行结构分析。这里直接看内存区域不明显，所以采用 内存查看 -> 工具 -> 分析数据/结构 来进行分析，输入地址之后点击 结构 -> 定义新的结构，设置好长度就会自动分析。之后分析的结果如下所示：<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808155615.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808155615.png?size=small" data-sub-html="<h2>20250808155615</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808155615.png alt=UObjectBase srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808155615.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808155615.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808155615.png?size=large 2x" data-title=20250808155615 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>UObjectBase</figcaption></figure>根据源码查看这个结构，可以看到从上到下的指针应该分别对应着 <code>VTable</code>，<code>UClass*</code>，<code>UObject*</code>，那么就确定了 ClassPrivate 的偏移为 0x14，OuterPrivate 的偏移为 0x20。然后红框中间的就是 FName，这里对象 ID 应该不为 0 ，那么就是 354，NamePrivate 的偏移也就是 0x18。</p><h4 id=function-获取信息 class=heading-element><span>Function 获取信息</span>
<a href=#function-%e8%8e%b7%e5%8f%96%e4%bf%a1%e6%81%af class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><h5 id=next class=heading-element><span>Next</span>
<a href=#next class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>这里就是寻找属性和方法获取过程中所需的结构偏移。上文得到的信息已经可以获取类的类名和名字了，那么就可以利用下面的代码获取 Object 的偏移，类名和对象名。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>DumpObjects</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>outputpath</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>ofstream</span> <span class=n>obj</span><span class=p>(</span><span class=n>outputpath</span> <span class=o>+</span> <span class=s>&#34;/Objects.txt&#34;</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>ofstream</span><span class=o>::</span><span class=n>out</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>obj</span><span class=p>.</span><span class=n>is_open</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>int32</span> <span class=n>count</span> <span class=o>=</span> <span class=n>GetObjectCount</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Total Objects: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>count</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>int32</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>count</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>kaddr</span> <span class=n>uobj</span> <span class=o>=</span> <span class=n>GetUObjectFromID</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>UObject</span><span class=o>::</span><span class=n>isValid</span><span class=p>(</span><span class=n>uobj</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>kaddr</span> <span class=n>classPtr</span> <span class=o>=</span> <span class=n>UObject</span><span class=o>::</span><span class=n>getClass</span><span class=p>(</span><span class=n>uobj</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>className</span> <span class=o>=</span> <span class=n>UObject</span><span class=o>::</span><span class=n>getClassName</span><span class=p>(</span><span class=n>uobj</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>objectName</span> <span class=o>=</span> <span class=n>UObject</span><span class=o>::</span><span class=n>getName</span><span class=p>(</span><span class=n>uobj</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>obj</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Ptr: 0x&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>hex</span> <span class=o>&lt;&lt;</span> <span class=n>uobj</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>className</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>objectName</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>然后从获取的对象里面寻找类名为 Function 的对象，因为函数一般都存在 <code>UField* Next;</code> 和 <code>FField* ChildProperties;</code> 两种类型。前者使得当前类可以不断寻找类的函数，后者则是存储函数的参数。这里就是寻找一个存在参数的函数来查看结构，因此根据经验选择了 MoveToActor 这个函数，它一般都存在参数。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808180322.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808180322.png?size=small" data-sub-html="<h2>20250808180322</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808180322.png alt=Function srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808180322.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808180322.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808180322.png?size=large 2x" data-title=20250808180322 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>Function</figcaption></figure>这里关心 0x2C 偏移处的数据，它是一个指针，展开查看它前面也符合 UObject 的内存布局，然后根据下面 UFunction 的源码结构来看，这个值应该就是 <code>UField* Next;</code>。因为这个数据在源码上离 OuterPrivate 最近，而结构分析中也是它离 OuterPrivate 最近，同时它符合 UObject 的内存布局，而 UField 又是继承自 UObject。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808180435.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808180435.png?size=small" data-sub-html="<h2>20250808180435</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808180435.png alt=UFunction srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808180435.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808180435.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808180435.png?size=large 2x" data-title=20250808180435 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>UFunction</figcaption></figure></p><h5 id=childproperties class=heading-element><span>ChildProperties</span>
<a href=#childproperties class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>同时推测下面这个 0x44 的数据为 <code>FField* ChildProperties;</code>。查看下面 FField 的源码结构，可以发现其中也存在一个 FField 的结构。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808180757.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808180757.png?size=small" data-sub-html="<h2>20250808180757</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808180757.png alt=FField srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808180757.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808180757.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808180757.png?size=large 2x" data-title=20250808180757 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>FField</figcaption></figure>然后查看 0x44 指针的结构分析，发现它在 0x10 位置也是一个指针，展开的类型和 0x44 展开的类型相似。之后继续展开 0x10 结构中 0x10 偏移的内存结构，发现也是近乎一样的，在 0x10 也有相似的指针。于是这里就可以推测这个 0x44 的指针就是 <code>FField* ChildProperties;</code>。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808181003.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808181003.png?size=small" data-sub-html="<h2>20250808181003</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808181003.png alt=结构分析 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808181003.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808181003.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808181003.png?size=large 2x" data-title=20250808181003 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>结构分析</figcaption></figure></p><h5 id=functionflags class=heading-element><span>FunctionFlags</span>
<a href=#functionflags class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>这里推测 FunctionFlags 的偏移为 0x84，因为它会和 0x00000400 进行位运算来确定函数的返回值是否可以解析，这里根据经验，大多数的函数返回值都是可以解析的，那么这个值大概率会存在 0x00000400 这样的关键信息。而查看多个 Function，只有 0x84 这个偏移的值不是指针，同时基本包含关键信息。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808182031.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808182031.png?size=small" data-sub-html="<h2>20250808182031</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808182031.png alt=结构分析 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808182031.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808182031.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808182031.png?size=large 2x" data-title=20250808182031 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>结构分析</figcaption></figure></p><h5 id=func class=heading-element><span>Func</span>
<a href=#func class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>之后继续拿多个地址进行分析来确定 <code>FNativeFuncPtr Func;</code> 的偏移。它首先是一个指针，指向一个地址。这里根据别的游戏 SDK 的信息得到同一个类下连续的 Function，然后在上面 Objects.txt 中发现这个游戏也有这些函数。因此就根据指针，且指向的地址减去基址的前面 4 bit 一样，后面数值相差不大的原则寻找，发现 0xA4 偏移的数据符合这个原则，因此确定它指向的就是函数的偏移 Func。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808183831.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808183831.png?size=small" data-sub-html="<h2>20250808183831</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808183831.png alt=结构分析 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808183831.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808183831.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808183831.png?size=large 2x" data-title=20250808183831 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>结构分析</figcaption></figure></p><h4 id=class-获取信息 class=heading-element><span>Class 获取信息</span>
<a href=#class-%e8%8e%b7%e5%8f%96%e4%bf%a1%e6%81%af class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>这里从 Objects.txt 中选出 Actor 和 Object 两个类进行结构分析。因为 Actor 继承自 Object 类，同时 Object 类是一个顶级类，它不再继承其他的了（从别的游戏的 sdk 中得到的信息），因此这里就挑选这两个类进行分析。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808190638.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808190638.png?size=small" data-sub-html="<h2>20250808190638</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808190638.png alt=结构分析 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808190638.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808190638.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808190638.png?size=large 2x" data-title=20250808190638 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>结构分析</figcaption></figure>这里左边是 Actor，右边是 Object，然后分析发现 Actor 在 0x40 位置的指针刚好指向右侧 Object 的地址，然后 Object 这个地方的数据为 0。那么剔除掉 ClassPrivate，可以确定这个偏移的数据就是 SuperStruct。而且这里观察 0x40 偏移指针的结构，发现它也符合 UObject 的内存布局，这说明推测是对的。</p><p>然后这里 0x6C 偏移的指针也符合 UObject 的内存布局，那么根据下图 UClass 的内存布局推测这个偏移就是 <code>UField* Children;</code>。因为 UClass 中只剩下这个数据符合 UObject 的内存布局了，其他的要么已经知道了偏移，要么偏移差距太大了。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808191105.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808191105.png?size=small" data-sub-html="<h2>20250808191105</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808191105.png alt=UClass srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808191105.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808191105.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250808191105.png?size=large 2x" data-title=20250808191105 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>UClass</figcaption></figure>同时这里对比多个 Class 发现偏移 0x48 位置一般是一个十进制的数，同时不同的类不太一样。结合其余 SDK 的经验，推测这里就是上图 UStruct 中的 PropertiesSize 成员变量，它存储着一个类的大小。</p><h4 id=enum-获取信息 class=heading-element><span>Enum 获取信息</span>
<a href=#enum-%e8%8e%b7%e5%8f%96%e4%bf%a1%e6%81%af class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>这里首先从之前获取的 SDK Enum 挑选出 EPhysicalSurface，它有 65 个枚举类型，然后从上面获取的 Objects.txt 得到它的地址，然后分析结构。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250809133113.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250809133113.png?size=small" data-sub-html="<h2>20250809133113</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250809133113.png alt=UEnum srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250809133113.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250809133113.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250809133113.png?size=large 2x" data-title=20250809133113 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>UEnum</figcaption></figure>这里分析发现它符合 UObject 的内存布局，然后有考虑从 Enum 中获取的地址，那么它就是 UEnum 类型的数据。之后看偏移为 0x3C 的数据，它是一个指针，然后后面的数据刚好为 65，符合 <code>TArray&lt;TPair&lt;FName, int64>> Names;</code> 的类型，那么这里 0x3C 就是 Names 的偏移，0x40 就是 ArrayNum 的偏移。之后查看这个指针指向的数据，发现这里的 TPair 也是 0x10 大小，所以 FName 和 int64 和在 64 位时一样，都是 8 字节。</p><h3 id=dump-actor class=heading-element><span>dump Actor</span>
<a href=#dump-actor class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>获取上面的魔改偏移之后，那么就可以正常获取 SDK 了。同时这里就可以从 Class.hpp 中找到 PersistentLevel 的偏移为 0x58。然后得到了 ULevel 结构的偏移，那么就分析 ULevel 这个结构。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250810111025.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250810111025.png?size=small" data-sub-html="<h2>20250810111025</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250810111025.png alt=ULevel srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250810111025.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250810111025.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250810111025.png?size=large 2x" data-title=20250810111025 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>ULevel</figcaption></figure>这里主要寻找的就是 <code>TArray&lt;AActor*> Actors;</code>，那么根据 TArray -> Pointer,num,maxnum 的结构来看，这里找的就是一个指针后面跟随两个 4 字节整数的数据，然后查看指针指向的地址，它也是一个指针，它指向的才是真正的 Actor。同时因为 Actor 继承自 UObject，所以查看这个 Actor 是否符合 UObject 的内存布局即可。经过上述步骤，可以确定 Actors 的偏移为 0x9C，而 ActorsCount 的偏移为 0xA0。</p><h2 id=参考资料 class=heading-element><span>参考资料</span>
<a href=#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><div class="details admonition quote open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-quote-right" aria-hidden=true></i>参考</div><div class=details-content><div class=admonition-content><p><ul><li><a href=https://bbs.kanxue.com/thread-281463.htm target=_blank rel="external nofollow noopener noreferrer">腾讯游戏安全技术竞赛2024决赛 安卓方向解题报告</a></li><li><a href=https://bbs.kanxue.com/thread-281464.htm target=_blank rel="external nofollow noopener noreferrer">2024腾讯游戏安全大赛-安卓赛道决赛VM分析与还原</a></li><li><a href=http://www.yxfzedu.com/article/12302 target=_blank rel="external nofollow noopener noreferrer">Android安全-2024騰訊遊戲安全大賽安卓決賽(復現)</a></li><li><a href=https://blog.lleavesg.top/article/Android-Seccomp target=_blank rel="external nofollow noopener noreferrer">Android环境下Seccomp对系统调用的监控</a></li><li><a href=https://bbs.kanxue.com/thread-282857.htm#msg_header_h2_4 target=_blank rel="external nofollow noopener noreferrer">UE4.27SDK-Dump</a></li></ul></div></div></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2025-08-10 11:21:40">更新于 2025.8.10&nbsp;
<a class=git-hash href=https://github.com/czTangt/blog.git/commit/b109efed8753e2a014982f36c41b2aaca121ebc3 rel="external nofollow noopener noreferrer" target=_blank title="commit by czTangt(cz.tangt@gmail.com) b109efed8753e2a014982f36c41b2aaca121ebc3: finish dump sdk in Tencent2024Final"><i class="fa-solid fa-hashtag fa-fw" aria-hidden=true></i>b109efe</a></span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href="https://github.com/czTangt/blog.git/blob/main/content/posts%5candroid%5c2024_Tencent_GameSec_Final.md?plain=1" title=查看源码 target=_blank rel="external nofollow noopener noreferrer" class=link-to-source>查看源码</a></span><span><a href=https://github.com/czTangt/blog.git/edit/main/content/posts%5candroid%5c2024_Tencent_GameSec_Final.md title=编辑此页 target=_blank rel="external nofollow noopener noreferrer" class=link-to-edit>编辑此页</a></span><span><a href="https://github.com/czTangt/blog.git/issues/new?title=[BUG]%202024%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B%E5%86%B3%E8%B5%9B&amp;body=%7cField%7cValue%7c%0A%7c-%7c-%7c%0A%7cTitle%7c2024%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B%E5%86%B3%E8%B5%9B%7c%0A%7cURL%7chttps://czTangt.github.io/blog/posts/android/2024-tencent-gamesec-final/%7c%0A%7cFilename%7chttps://github.com/czTangt/blog.git/blob/main/content/posts%5candroid%5c2024_Tencent_GameSec_Final.md?plain=1%7c" title=报告问题 target=_blank rel="external nofollow noopener noreferrer" class=link-to-report>报告问题</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 X" data-sharer=twitter data-url=https://czTangt.github.io/blog/posts/android/2024-tencent-gamesec-final/ data-title=2024腾讯游戏安全竞赛决赛 data-hashtags=android,game><i class="fa-brands fa-x-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://czTangt.github.io/blog/posts/android/2024-tencent-gamesec-final/ data-hashtag=android><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://czTangt.github.io/blog/posts/android/2024-tencent-gamesec-final/ data-title=2024腾讯游戏安全竞赛决赛><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/blog/tags/android/ class=post-tag title="标签 - Android">Android</a><a href=/blog/tags/game/ class=post-tag title="标签 - Game">Game</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/blog/>主页</a></span></section></div><div class=post-nav><a href=/blog/posts/android/2024-tencent-gamesec-prelim/ class=post-nav-item rel=prev title=2024腾讯游戏安全竞赛初赛><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>2024腾讯游戏安全竞赛初赛</a><a href=/blog/posts/android/ue-structure/ class=post-nav-item rel=next title="UE 结构分析">UE 结构分析<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article><aside class=toc id=toc-auto aria-label=目录><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside></main><footer class=footer><div class=footer-container><div class="footer-line powered order-1">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.136.5"><img class=hugo-icon src=/blog/images/hugo.min.svg alt="Hugo logo"> Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.3.17-30a67c4b"><img class=fixit-icon src=/blog/images/fixit.min.svg alt="FixIt logo"> FixIt</a></div><div class="footer-line copyright order-2" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2024 - 2025</span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class="variant-numeric d-none">0%</span></div></div><a href=https://github.com/czTangt/blog title="View source on GitHub" target=_blank rel="external nofollow" class="github-corner left d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true" width="56" height="56"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><noscript><div class=noscript-warning>该网站在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/blog/lib/lightgallery/css/lightgallery-bundle.min.css><link rel=preload href=/blog/lib/katex/katex.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/blog/lib/katex/katex.min.css></noscript><link rel=stylesheet href=/blog/lib/cookieconsent/cookieconsent.min.css><script src=/blog/lib/autocomplete/autocomplete.min.js defer></script><script src=/blog/lib/fuse/fuse.min.js defer></script><script src=/blog/lib/lightgallery/lightgallery.min.js defer></script><script src=/blog/lib/lightgallery/plugins/thumbnail/lg-thumbnail.min.js defer></script><script src=/blog/lib/lightgallery/plugins/zoom/lg-zoom.min.js defer></script><script src=/blog/lib/sharer/sharer.min.js async defer></script><script src=/blog/lib/katex/katex.min.js defer></script><script src=/blog/lib/katex/auto-render.min.js defer></script><script src=/blog/lib/katex/mhchem.min.js defer></script><script src=/blog/lib/cookieconsent/cookieconsent.min.js defer></script><script src=/blog/js/codeblock.js defer></script><script src=https://libs.baidu.com/jquery/2.1.4/jquery.min.js defer></script><script>window.config={code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:10},comment:{enable:!1},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},lightgallery:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{distance:100,findAllMatches:!1,fuseIndexURL:"/blog/search.json",highlightTag:"em",ignoreFieldNorm:!1,ignoreLocation:!1,isCaseSensitive:!1,location:0,maxResultLength:10,minMatchCharLength:2,noResultsFound:"没有找到结果",snippetLength:30,threshold:.3,type:"fuse",useExtendedSearch:!1},version:"v0.3.17-30a67c4b"}</script><script src=/blog/js/theme.min.js defer></script></body></html>