<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>ELF 解析 - czTang</title><meta name=author content="czTang">
<meta name=description content="借鉴 《程序员的自我修养》，ELF视频 和 文字记录 做的笔记。主要想要探究一下 ELF 的链接和装载。
"><meta name=keywords content='reverse,android'><meta itemprop=name content="ELF 解析"><meta itemprop=description content="借鉴 《程序员的自我修养》，ELF视频 和 文字记录 做的笔记。主要想要探究一下 ELF 的链接和装载。"><meta itemprop=datePublished content="2024-11-24T10:17:25+08:00"><meta itemprop=dateModified content="2025-01-31T20:17:51+08:00"><meta itemprop=wordCount content="5108"><meta itemprop=keywords content="Reverse,Android"><meta property="og:url" content="https://czTangt.github.io/blog/posts/android/elf/"><meta property="og:site_name" content="czTang"><meta property="og:title" content="ELF 解析"><meta property="og:description" content="借鉴 《程序员的自我修养》，ELF视频 和 文字记录 做的笔记。主要想要探究一下 ELF 的链接和装载。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-11-24T10:17:25+08:00"><meta property="article:modified_time" content="2025-01-31T20:17:51+08:00"><meta property="article:tag" content="Reverse"><meta property="article:tag" content="Android"><meta name=twitter:card content="summary"><meta name=twitter:title content="ELF 解析"><meta name=twitter:description content="借鉴 《程序员的自我修养》，ELF视频 和 文字记录 做的笔记。主要想要探究一下 ELF 的链接和装载。"><meta name=application-name content="FixIt"><meta name=apple-mobile-web-app-title content="FixIt"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel=icon href=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410312135963.svg><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical type=text/html href=https://czTangt.github.io/blog/posts/android/elf/ title="ELF 解析 - czTang"><link rel=prev type=text/html href=https://czTangt.github.io/blog/posts/compile/semantics-symboltable-ag/ title="03 Semantics SymbolTable Ag"><link rel=next type=text/html href=https://czTangt.github.io/blog/posts/config/android-phone/ title=安卓手机配置><link rel=stylesheet href=/blog/css/style.min.css><link rel=preload href=/blog/lib/fontawesome-free/all.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/blog/lib/fontawesome-free/all.min.css></noscript><link rel=preload href=/blog/lib/animate/animate.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/blog/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"ELF 解析","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/czTangt.github.io\/blog\/posts\/android\/elf\/"},"genre":"posts","keywords":"reverse, android","wordcount":5108,"url":"https:\/\/czTangt.github.io\/blog\/posts\/android\/elf\/","datePublished":"2024-11-24T10:17:25+08:00","dateModified":"2025-01-31T20:17:51+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"czTang"},"description":""}</script><script src=/blog/js/head/color-scheme.min.js></script></head><body data-header-desktop=sticky data-header-mobile=auto><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=left><div class=header-title><a href=/blog/ title=czTang><span class=header-title-pre><i class='fa fa-coffee'>&nbsp</i></span><span class=header-title-text>czTang</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/blog/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> Archives</a></li><li class=menu-item><a class=menu-link href=/blog/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> Categories</a></li><li class=menu-item><a class=menu-link href=/blog/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> Tags</a></li><li class=menu-item><a class=menu-link href=/blog/about/><i class="fa-solid fa-user fa-fw fa-sm" aria-hidden=true></i> About</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/blog/ title=czTang><span class=header-title-pre><i class='fa fa-coffee'>&nbsp</i></span><span class=header-title-text>czTang</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/blog/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> Archives</a></li><li class=menu-item><a class=menu-link href=/blog/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> Categories</a></li><li class=menu-item><a class=menu-link href=/blog/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> Tags</a></li><li class=menu-item><a class=menu-link href=/blog/about/><i class="fa-solid fa-user fa-fw fa-sm" aria-hidden=true></i> About</a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=container><aside class="aside-collection animate__animated animate__fadeIn animate__faster" aria-label=合集><div class="details collection-details open"><div class="details-summary collection-summary"><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i>
<span class=collection-name title=合集>Reverse</span>
<span class=collection-count>4</span><i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class="details-content collection-content"><nav><ul class=collection-list><li class=collection-item><span class=active title="ELF 解析">ELF 解析</span></li><li class=collection-item><a href=/blog/posts/reverse/algorithm/ title=逆向中的算法>逆向中的算法</a></li><li class=collection-item><a href=/blog/posts/android/unidbg/ title="Unidbg 记录">Unidbg 记录</a></li><li class=collection-item><a href=/blog/posts/android/android-reverse/ title="Android Reverse">Android Reverse</a></li></ul><div class=collection-nav-simple><i class="fa-solid fa-angle-left fa-fw collection-nav-item text-secondary" aria-hidden=true></i><span class=text-secondary>1/4</span><a href=/blog/posts/reverse/algorithm/ class=collection-nav-item rel=next title=逆向中的算法><i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></nav></div></div></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>ELF 解析</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/czTangt title=作者 target=_blank rel="external nofollow noopener noreferrer author" class=author><img loading=lazy src=/blog/images/avatar.jpg alt=czTang data-title=czTang width=20 height=20 class=avatar style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'>&nbsp;czTang</a></span><span class=post-included-in>&nbsp;收录于 <a href=/blog/categories/android/ class=post-category title="分类 - Android"><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> Android</a> 和 <a href=/blog/collections/reverse/ class=post-collection title="合集 - Reverse"><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i> Reverse</a></span></div><div class=post-meta-line><span title="发布于 2024-11-24 10:17:25"><i class="fa-solid fa-calendar-days fa-fw me-1" aria-hidden=true></i><time datetime=2024.11.24>2024.11.24</time></span>&nbsp;<span title="更新于 2025-01-31 20:17:51"><i class="fa-regular fa-calendar-check fa-fw me-1" aria-hidden=true></i><time datetime=2025.1.31>2025.1.31</time></span>&nbsp;<span title="5108 字"><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 5200 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 11 分钟</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#基础配置>基础配置</a></li><li><a href=#elf_header>elf_header</a><ul><li><a href=#结构分析>结构分析</a><ul><li><a href=#e_ident>e_ident</a></li><li><a href=#e_type>e_type</a></li><li><a href=#e_machine>e_machine</a></li><li><a href=#e_entry_start_address>e_entry_START_ADDRESS</a></li><li><a href=#program_header_offset>PROGRAM_HEADER_OFFSET</a></li><li><a href=#section_header_offset>SECTION_HEADER_OFFSET</a></li></ul></li><li><a href=#其余信息>其余信息</a></li><li><a href=#总结>总结</a></li></ul></li><li><a href=#program_header_table>program_header_table</a><ul><li><a href=#结构分析-1>结构分析</a><ul><li><a href=#p_type>p_type</a></li><li><a href=#p_flags>p_flags</a></li><li><a href=#from_file_begin>FROM_FILE_BEGIN</a></li><li><a href=#virtual_address>VIRTUAL_ADDRESS</a></li><li><a href=#physical_address>PHYSICAL_ADDRESS</a></li><li><a href=#segment_file_length>SEGMENT_FILE_LENGTH</a></li><li><a href=#segment_ram_length>SEGMENT_RAM_LENGTH</a></li><li><a href=#p_align>p_align</a></li></ul></li><li><a href=#文件内存映射>文件内存映射</a></li><li><a href=#program-header>Program Header</a></li><li><a href=#interpreter-path>Interpreter Path</a></li><li><a href=#android9-可加载段>Android9 可加载段</a><ul><li><a href=#代码段>代码段</a></li><li><a href=#数据段>数据段</a></li></ul></li></ul></li></ul></nav></div></div><div class=content id=content><p>借鉴 《程序员的自我修养》，<a href="https://space.bilibili.com/37877654/channel/seriesdetail?sid=1467282" target=_blank rel="external nofollow noopener noreferrer">ELF视频</a> 和 <a href=https://www.lyldalek.top/bdc0e9d05123420b8cc87f7ad89a43d5 target=_blank rel="external nofollow noopener noreferrer">文字记录</a> 做的笔记。主要想要探究一下 ELF 的链接和装载。</p><h2 id=基础配置 class=heading-element><span>基础配置</span>
<a href=#%e5%9f%ba%e7%a1%80%e9%85%8d%e7%bd%ae class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><div class="details admonition tip open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-regular fa-lightbulb" aria-hidden=true></i>分析文件</div><div class=details-content><div class=admonition-content><p>这里以 ARM-v8a 架构中的 <code>ls</code> 举例讲解 <code>ELF</code> 文件格式。</p></div></div></div><p>使用 <code>/system/bin/ls</code> 文件来进行分析，首先将其复制一份放在 <code>/data/local/tmp</code> 目录中，之后 <code>pull</code> 到本地使用 <code>010 Editor</code> 进行修改，然后再 <code>push</code> 上去运行验证。下面为了方便采用 <code>bat</code> 脚本执行。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bat data-lang=bat><span class=line><span class=cl>adb push ls /data/local/tmp/ls
</span></span><span class=line><span class=cl>adb shell <span class=s2>&#34;chmod 777 /data/local/tmp/ls&#34;</span>
</span></span><span class=line><span class=cl>adb shell <span class=s2>&#34;cd /data/local/tmp &amp;&amp; ./ls&#34;</span></span></span></code></pre></td></tr></table></div></div><p>要提及一下 <code>Toybox</code>，它是一个小型、高效的命令工具集，为嵌入式系统和 Android 提供了常用命令的实现。同时它也是单一的可执行文件，集成了多个常用命令，如 ls、cp、mv、mkdir 等。我们使用的 <code>ls</code> 就是 <code>Toybox</code> 的软链接，它通过<strong>识别程序调用时的名称（即 argv[0]）决定执行的具体命令</strong>。所以我尝试把 ls 更改名称为 <code>modify-ls</code>，一开始能用，然后后面就报错 <code>toybox: Unknown command modify-ls</code> 了，所以还是使用原来的名称。</p><h2 id=elf_header class=heading-element><span>elf_header</span>
<a href=#elf_header class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124111008.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124111008.png?size=small" data-sub-html="<h2>20241124111008</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124111008.png alt=elf_header srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124111008.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124111008.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124111008.png?size=large 2x" data-title=20241124111008 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>elf_header</figcaption></figure>上图就是 <code>elf_header</code> 的结构，它包含数个结构信息。下面主要展示真正起作用的部分和相关知识点，其余没有用处的部分一笔带过，这里有没有用处的评价标准是相对于在 Linux 中正常运行而言的，不影响运行就是没有作用的。</p><h3 id=结构分析 class=heading-element><span>结构分析</span>
<a href=#%e7%bb%93%e6%9e%84%e5%88%86%e6%9e%90 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><h4 id=e_ident class=heading-element><span>e_ident</span>
<a href=#e_ident class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p><code>elf_header</code> 下面有一个子结构体 <code>e_ident</code>，它里面其实只有第一个 <code>file_identification</code> 是有用的，并且是固定的，为 <code>.ELF</code>。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124111154.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124111154.png?size=small" data-sub-html="<h2>20241124111154</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124111154.png alt=file_identification srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124111154.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124111154.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124111154.png?size=large 2x" data-title=20241124111154 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>file_identification</figcaption></figure></p><p>其余的属性，例如 <code>ei_class_2_e</code>，它是用来描述 elf 的位数的，32位和64位。但是实际上 <code>linker</code> 加载该 elf 文件的时候，根本不会在意这个值。如果把这个结构中除了 <code>file_identification</code> 全部更改为 EE（FF为 -1，可能存在作用），程序依然可以正常运行。</p><h4 id=e_type class=heading-element><span>e_type</span>
<a href=#e_type class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>这个的值虽然是一个枚举，但是是实际上无论是 exe 还是 so，它们的值都必须是 <code>ET_DYN (3)</code> ，如果是一个 exe 文件，将这个值改成 ET_EXEC (2)，它反而不能运行。</p><h4 id=e_machine class=heading-element><span>e_machine</span>
<a href=#e_machine class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>这个字段说明 CPU 平台，比如 x86，arm32，arm64 等。如果这个地方给错了，不能正常运行。</p><h4 id=e_entry_start_address class=heading-element><span>e_entry_START_ADDRESS</span>
<a href=#e_entry_start_address class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>这个是 elf 加载到内存时执行的初始地址，也就是程序加载后，加载器将控制权转移到的第一条指令地址，通常是 <code>_start</code> 函数的地址，之后这个函数会调用 <code>libc</code> 的启动函数 <code>__libc_start_main</code>，而 <code>__libc_start_main</code> 就会调用用户定义的 <code>main</code> 函数。这里它是一个虚拟地址，表示的相对偏移，真实的虚拟地址 = 加载的虚拟地址的基址 + 这个相对偏移。</p><h4 id=program_header_offset class=heading-element><span>PROGRAM_HEADER_OFFSET</span>
<a href=#program_header_offset class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>指 <code>e_phoff_PROGRAM_HEADER_OFFSET_IN_FILE</code>，它是 <code>program_header_table</code> 段的偏移。<code>elf_header</code> 后面就是 <code>program_header_table</code>，斯普哦它一般也是 <code>elf_header</code> 的大小。除非有人故意在这两者之间插入一些无用的数据。</p><h4 id=section_header_offset class=heading-element><span>SECTION_HEADER_OFFSET</span>
<a href=#section_header_offset class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>指 <code>e_shoff_SECTION_HEADER_OFFSET_IN_FILE</code>，它表示 <code>section header table</code> 段的偏移，但是没有什么用处，实际上跟 <code>section</code> 有关的都没啥用，因为 elf 加载的时候根本就不使用 section 相关的东西。上面是 Android 8 之前的版本，而 Android 8 及以后还是会读取 section header的，但不是所有的 section 都会读取。但是我使用 Android 9 进行实验，SDK 为 28，我发现按照之前的修改方式进行，程序还是可以运行。这里是 Android14 的 <a href="https://cs.android.com/android/platform/superproject/+/android14-qpr3-release:bionic/linker/linker_phdr.cpp?q=linker_phdr&amp;ss=android" target=_blank rel="external nofollow noopener noreferrer">linker 代码</a>，可以看到它存在 <code>ReadSectionHeaders()</code>、<code>ReadDynamicSection()</code> 函数来读取相关信息。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124115041.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124115041.png?size=small" data-sub-html="<h2>20241124115041</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124115041.png alt="修改 section header table" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124115041.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124115041.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124115041.png?size=large 2x" data-title=20241124115041 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>修改 section header table</figcaption></figure></p><p>但是 IDA 是使用 section 来进行解析的。我们将 section header 都覆盖为 EE。之后可以正常运行，但是 IDA 解析一开始会报错，之后发现解析不了段信息。实际上加载一个 so 文件的时候，IDA 的 <code>segment view</code> 里面就是解析的 <code>section header</code>。如果我们破坏了甚至是弄一个假的 <code>.text/.data section</code>，那么 IDA 就没有办法正常解析了。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124115521.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124115521.png?size=small" data-sub-html="<h2>20241124115521</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124115521.png alt="IDA 解析" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124115521.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124115521.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124115521.png?size=large 2x" data-title=20241124115521 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>IDA 解析</figcaption></figure></p><h3 id=其余信息 class=heading-element><span>其余信息</span>
<a href=#%e5%85%b6%e4%bd%99%e4%bf%a1%e6%81%af class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><ul><li><code>e_ehsize_ELF_HEADER_SIZE</code>：没有用处，加载的时候根本不检查，它是根据位数的默认大小，所以改动 <code>elf_header</code> 的大小会有不可预料的后果</li><li><code>e_phentsize_PROGRAM_HEADER_ENTRY_SIZE_IN_FILE</code>：<code>program_header_table</code> 是一个数组，这个表示数组中每个元素的大小</li><li><code>e_phnum_NUMBER_OF_PROGRAM_HEADER_ENTRIES</code>：这个表示上面数组中元素的个数</li></ul><h3 id=总结 class=heading-element><span>总结</span>
<a href=#%e6%80%bb%e7%bb%93 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>所以最后可以把 <code>elf_header</code> 修改成下面的形式，它也是可以正常运行的。下面保留的相关结构就是 <code>file_identification</code>、<code>e_type</code>、<code>e_machine</code>、<code>e_entry_START_ADDRESS</code>、<code>e_phoff_PROGRAM_HEADER_OFFSET_IN_FILE</code>、<code>e_phentsize_PROGRAM_HEADER_ENTRY_SIZE_IN_FILE</code>、<code>e_phnum_NUMBER_OF_PROGRAM_HEADER_ENTRIES</code>。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124145051.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124145051.png?size=small" data-sub-html="<h2>20241124145051</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124145051.png alt=修改后ELF srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124145051.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124145051.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124145051.png?size=large 2x" data-title=20241124145051 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>修改后ELF</figcaption></figure></p><h2 id=program_header_table class=heading-element><span>program_header_table</span>
<a href=#program_header_table class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>这是一个数组，拥有数个元素结构体 <code>program_table_element</code>，元素个数和元素大小都在 <code>elf_header</code> 中展示出来了。这里是对单个元素结构进行分析，它每一个元素结构描述的都是内存和文件的对应关系。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124150034.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124150034.png?size=small" data-sub-html="<h2>20241124150034</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124150034.png alt=program_header_table srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124150034.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124150034.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124150034.png?size=large 2x" data-title=20241124150034 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>program_header_table</figcaption></figure></p><h3 id=结构分析-1 class=heading-element><span>结构分析</span>
<a href=#%e7%bb%93%e6%9e%84%e5%88%86%e6%9e%90-1 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><h4 id=p_type class=heading-element><span>p_type</span>
<a href=#p_type class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>段类型，为 1 表示可加载段，然后根据读写权限可以分成代码段和数据段。这两个可加载段最为重要，其它段就是服务这两个段而存在的。</p><h4 id=p_flags class=heading-element><span>p_flags</span>
<a href=#p_flags class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>段属性。表示段为可读，可写，可执行等。对于加载段很重要，区分了代码段和数据段，其它段就基本没什么意义。</p><h4 id=from_file_begin class=heading-element><span>FROM_FILE_BEGIN</span>
<a href=#from_file_begin class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>指 <code>p_offset_FROM_FILE_BEGIN</code>，它表示段在文件中的偏移，可以直接在文件中根据偏移进行查看。</p><h4 id=virtual_address class=heading-element><span>VIRTUAL_ADDRESS</span>
<a href=#virtual_address class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>指 <code>p_vaddr_VIRTUAL_ADDRESS</code>，它表示段的虚拟地址。它表示的是一个相对偏移，因为段被加载到的虚拟地址是不确定的，所以真实的虚拟地址 = 加载的虚拟地址的基址 + 这个相对偏移</p><h4 id=physical_address class=heading-element><span>PHYSICAL_ADDRESS</span>
<a href=#physical_address class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>指 <code>p_paddr_PHYSICAL_ADDRESS</code>，它表示段的物理地址。因为都运行在用户态，没有物理地址的概念，所以所有段的这个都没有用。段只有虚拟地址才有意义。</p><h4 id=segment_file_length class=heading-element><span>SEGMENT_FILE_LENGTH</span>
<a href=#segment_file_length class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>指 <code>p_filesz_SEGMENT_FILE_LENGTH</code>，表示段在文件中的长度。</p><h4 id=segment_ram_length class=heading-element><span>SEGMENT_RAM_LENGTH</span>
<a href=#segment_ram_length class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>指 <code>p_memsz_SEGMENT_RAM_LENGTH</code>，表示段在内存中的长度。</p><h4 id=p_align class=heading-element><span>p_align</span>
<a href=#p_align class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>段的对齐方式。ELF 中的对齐都是内存对齐，不存在文件对齐，它都是密集排列的。它没有什么作用，加载器中写定了内存对齐都是 4K。</p><h3 id=文件内存映射 class=heading-element><span>文件内存映射</span>
<a href=#%e6%96%87%e4%bb%b6%e5%86%85%e5%ad%98%e6%98%a0%e5%b0%84 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p><code>program_header_table</code> 中的每个元素，描述的其实是将段加载到内存中时，elf文件中的段映射到了内存中。</p><ul><li><code>p_offset_FROM_FILE_BEGIN</code> 与 <code>p_filesz_SEGMENT_FILE_LENGTH</code> 表示了文件中的段。</li><li><code>p_vaddr_VIRTUAL_ADDRESS</code> 与 <code>p_memsz_SEGMENT_RAM_LENGTH</code> 表示了内存中的段。</li></ul><p>这两者构成一个映射关系，linker 在加载 elf 的时候采用的是 mmap。<code>p_filesz_SEGMENT_FILE_LENGTH</code> 与 <code>p_memsz_SEGMENT_RAM_LENGTH</code> 的大小不一定一样，因为为了节省 elf 文件大小，有些值为 0 的段，比如 <code>.bss</code> 就不占文件空间。但是加载到内存后，还是要分配空间的。</p><h3 id=program-header class=heading-element><span>Program Header</span>
<a href=#program-header class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>这个段里只有两块数据有用，其余都可以忽略。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124194018.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124194018.png?size=small" data-sub-html="<h2>20241124194018</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124194018.png alt="Program Header" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124194018.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124194018.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124194018.png?size=large 2x" data-title=20241124194018 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>Program Header</figcaption></figure></p><p>文件偏移与虚拟地址，它们都是 0x40，而且这个值与 <code>elf_header</code> 必须是相等的。这个值某种意义上就是 elf_header 的大小。那为什么还需要在这里再储存一次呢？
可以简单理解，<code>linker</code> 里面有一些指针指向的是 elf_header，而有些指针指向的是 program_header，<strong>互相转换</strong>的时候，会使用指针偏移来计算，偏移大小就是这里的 0x40，所以就在这里也记录了值，偏于指针计算。</p><ul><li><code>p_data</code> 就是整个 <code>program_header_table</code> 的内容。</li><li><code>p_type</code> 不知道有没有用，没试过改这里，假定有用吧。</li></ul><h3 id=interpreter-path class=heading-element><span>Interpreter Path</span>
<a href=#interpreter-path class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>这个段就是描述解析器（linker）路径的，它与上面的 Program Header 段必须要出现在可加载段前面。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124194438.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124194438.png?size=small" data-sub-html="<h2>20241124194438</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124194438.png alt="Interpreter Path" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124194438.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124194438.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124194438.png?size=large 2x" data-title=20241124194438 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>Interpreter Path</figcaption></figure></p><p>这个段需要关注的数据就是 <code>p_data</code>，可以发现它是一个字符串 <code>/system/bin/linker64</code>，那么 <code>LENGTH</code> 就都是指的容纳这个字符串的长度，在这里也就是最多 0x15 长度的字符串。ELF 的可加载段就是由这个路径文件来加载的，包括重定位操作等等。</p><p>我们可以根据这个路径获取系统的 <code>linker</code>，之后在入口点写入死循环，然后更改 ls 文件的解析器路径为我们修改的 linker 的路径。这里因为字符串的长度不能超过 0x15，同时需要以 00 字节结尾，所以更改 linker64 为 li64。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124195433.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124195433.png?size=small" data-sub-html="<h2>20241124195433</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124195433.png alt=文件修改 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124195433.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124195433.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124195433.png?size=large 2x" data-title=20241124195433 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>文件修改</figcaption></figure></p><p>之后运行 <code>ls</code> 文件，发现卡死了，所以查看其 maps 信息。这里发现相比之前的死循环，这里少了很多东西，像是 libc 相关的东西也没有了。这是因为现在进程卡在了非常早的时机，连这个 ELF 文件自身的段的重定位都没有做，只是光将 ELF 文件中的东西放到内存里面了。</p><p>但是可以发现下图前面两行表示 ls 文件被加载了，这又是为什么？我们已经在 linker 的入口函数加了一个死循环，linker 根本不会执行加载逻辑才对。其实这是因为这两个可执行段不是由 ls 中指定的 linker 加载的，而是其他进程中的 linker 加载的，目前先简单的理解为是 init 进程干的吧（感觉需要更为细致的判断，这里的理解是猜测）。剩下的其他 ELF 依赖文件，比如 libc 等则将由路径中指定的 linker 来加载。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124195754.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124195754.png?size=small" data-sub-html="<h2>20241124195754</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124195754.png alt="修改后 maps 信息" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124195754.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124195754.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124195754.png?size=large 2x" data-title=20241124195754 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>修改后 maps 信息</figcaption></figure></p><p>我们可以使用 IDA 附加进程来更为细致的查看。在 Modules 中可以发现只有两个 so 被加载。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124200544.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124200544.png?size=small" data-sub-html="<h2>20241124200544</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124200544.png alt="IDA Modules 信息" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124200544.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124200544.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124200544.png?size=large 2x" data-title=20241124200544 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>IDA Modules 信息</figcaption></figure></p><p>之后还原 linker 的入口地址指令，让其继续执行，并且在 ls 的入口地址加上断点。按 F8 步过 <code>linker_init</code> 函数，发现此时 linker 加载了很多的 so。同时这里的 linker 存在一个特点，他没有 <code>imports</code>（导入表）。这是因为它不依赖其他 so，它也不能依赖其他 so。它运行的时候，其他 so 都没有加载。比如 open 函数，它就不能使用 libc 中的 open 函数，它必须自己实现 open 函数。所以它必须实现所有自己需要的函数。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124200938.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124200938.png?size=small" data-sub-html="<h2>20241124200938</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124200938.png alt="IDA Modules 信息" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124200938.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124200938.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124200938.png?size=large 2x" data-title=20241124200938 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>IDA Modules 信息</figcaption></figure></p><h3 id=android9-可加载段 class=heading-element><span>Android9 可加载段</span>
<a href=#android9-%e5%8f%af%e5%8a%a0%e8%bd%bd%e6%ae%b5 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><div class="details admonition tip open"><div class="details-summary admonition-title"><i class="icon fa-fw fa-regular fa-lightbulb" aria-hidden=true></i>重要说明<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content><p>这里加载段和上面的内容都是对于我 Android9 的设备来看，与其它 Android 的版本存在差异。</p></div></div></div><p>这里最为重要的就是下面的两个可加载段了，根据其权限可以判断出，具有 <code>R_X</code> 属性的段为代码段，具有 <code>RW_</code> 属性的段为数据段。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124153202.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124153202.png?size=small" data-sub-html="<h2>20241124153202</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124153202.png alt=可加载段 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124153202.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124153202.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124153202.png?size=large 2x" data-title=20241124153202 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>可加载段</figcaption></figure></p><h4 id=代码段 class=heading-element><span>代码段</span>
<a href=#%e4%bb%a3%e7%a0%81%e6%ae%b5 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>之前根据 <code>elf_header</code> 的 <code>e_entry_START_ADDRESS</code> 值，我们可以知道代码的入口在虚拟地址 <code>0xD760</code>。对于程序在内存运行，段的加载就是根据它的虚拟地址和内存长度来进行排列的。这里代码段的虚拟地址为 <code>0x0</code>，可以判断它是排在第一个的。同时代码入口和段的真实虚拟地址都是 <strong>加载的虚拟地址的基址 + 相对偏移</strong> 得来的，它们的加载虚拟地址基址都是一样的，同时段的大小为 <code>0x6041C</code>，比 <code>0xD760</code> 大，所以代码的入口在代码段中。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124155711.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124155711.png?size=small" data-sub-html="<h2>20241124155711</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124155711.png alt=代码段信息 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124155711.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124155711.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124155711.png?size=large 2x" data-title=20241124155711 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>代码段信息</figcaption></figure></p><p>同时代码段的文件大小和内存大小相同，且段在文件中的偏移也是 0，所以可以判断它们为 1对1 映射。所以该入口地址在文件中也是在代码段中的（0x0 + 0xD760），我们可以直接查找 <code>0xD760</code> 来找到入口的代码。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124160055.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124160055.png?size=small" data-sub-html="<h2>20241124160055</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124160055.png alt=修改前首地址 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124160055.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124160055.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124160055.png?size=large 2x" data-title=20241124160055 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>修改前首地址</figcaption></figure></p><p>之后修改为 <code>00 00 00 14</code> ，它在 ARM64 中表示 <code>b #0</code>，是死循环代码，这样可以帮助我们查看内存中的段分布。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124160255.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124160255.png?size=small" data-sub-html="<h2>20241124160255</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124160255.png alt=修改后首地址 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124160255.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124160255.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124160255.png?size=large 2x" data-title=20241124160255 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>修改后首地址</figcaption></figure></p><p>之后启动文件，通过 <code>ps -a</code> 查看进程信息，之后通过 <code>proc/self/maps</code> 查看内存中段信息。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124171444.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124171444.png?size=small" data-sub-html="<h2>20241124171444</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124171444.png alt=内存段信息 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124171444.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124171444.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124171444.png?size=large 2x" data-title=20241124171444 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>内存段信息</figcaption></figure></p><p>根据上图可以看到段在内存中的分布，这里第一个可读可执行的就是代码段，而后面三个一起就是数据段。这里代码段的起始位置 <code>0x60a053e000</code> 就是<strong>加载的虚拟地址的基址</strong>，因为代码段的相对偏移为 0。之后我们得到代码段的大小为 <code>0x6041C</code>，二者相加等于 <code>0x60A059E41C</code>，然后是 4K 对齐，结束地址为 <code>0x60A059F000</code>。同时我们用户的起始代码地址为 <code>0x60a053e000</code> + <code>0xD760</code> = <code>0x60A054B760</code>。在下图 IDA 的分析中，可以看到起始地址代码刚好为我们更改的结果。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124172255.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124172255.png?size=small" data-sub-html="<h2>20241124172255</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124172255.png alt="IDA 中起始地址" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124172255.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124172255.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124172255.png?size=large 2x" data-title=20241124172255 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>IDA 中起始地址</figcaption></figure></p><p>在 IDA 的分析中，这里的代码在名为 <code>.text</code> 的 segment 中，它是 IDA 根据 section 的信息分析的，在 section 中，<code>.text</code>的起始位置为 <code>0xD740</code>，刚好和这里的图片相对应。由此也可以验证 IDA 的分析是根据 section 来进行的，但是运行是根据 program 来进行的。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124171649.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124171649.png?size=small" data-sub-html="<h2>20241124171649</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124171649.png alt="IDA 代码段信息" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124171649.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124171649.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124171649.png?size=large 2x" data-title=20241124171649 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>IDA 代码段信息</figcaption></figure></p><h4 id=数据段 class=heading-element><span>数据段</span>
<a href=#%e6%95%b0%e6%8d%ae%e6%ae%b5 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>而后面三个一起为数据段，我们查看数据段信息，可以知道它的虚拟地址为 <code>0x7CFC0</code>，而基址为 <code>0x60a053e000</code>，二者相加为 <code>0x60A05BAFC0</code>。因为内存页都是 4K 对齐的，所以不能从这个地址开始给其赋予可读可写的权限，必须是给整个内存页赋予权限，所以这里就从 <code>0x60a05ba000</code> 开始赋予权限，但是真实的地址还是 <code>0x60A05BAFC0</code>。</p><p>同时数据段的大小为 <code>0x89EE</code>，0x60a05ba000 + 0x89EE = <code>0x60A05C29EE</code>，根据 4kb 对齐就是 <code>0x60A05C3000</code>。这个地方应该和三部分的末尾相对应，但是我这里差了 1kb 的空间，每次都是这样，怀疑我这个系统往这个里面添加了什么数据，但是目前不知道。所以这里就当作它是刚好映射到结尾吧。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124165332.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124165332.png?size=small" data-sub-html="<h2>20241124165332</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124165332.png alt=数据段信息 srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124165332.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124165332.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124165332.png?size=large 2x" data-title=20241124165332 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>数据段信息</figcaption></figure></p><p>这里从 IDA 的 <code>Segments View</code> 中可以看出，这个地址对应的 segment 就是 <code>.preinit_array</code>，也就是说这个数据段从这里往后进行放置。我们可以根据该段的文件偏移找到这个地方的代码，可以发现二者是相对应的。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124180823.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124180823.png?size=small" data-sub-html="<h2>20241124180823</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124180823.png alt="IDA 数据段信息" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124180823.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124180823.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124180823.png?size=large 2x" data-title=20241124180823 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>IDA 数据段信息</figcaption></figure></p><p>但是问题还是在这里，为什么这个数据段被分成了三部分？这是因为数据段中的一部分权限会被修改，它是被下面的 GNU Read-only After Relocation 段给修改的。这个段描述的就是，在重定位之后，将虚拟位置 <code>0x7CFC0</code> 且大小为 <code>0x3040</code> 字节的区域的权限改为<strong>只读</strong>。这里 <code>0x7CFC0</code> 就是数据段的起始位置，之后计算数据段的第一部分大小， 0x60a05be000 - 0x60a05ba000 = <code>0x4000</code>，它刚好是 <code>0x3040</code> 4kb 对齐的结果，这说明第一部分就是这个段修改权限所产生的。</p><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124181237.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124181237.png?size=small" data-sub-html="<h2>20241124181237</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124181237.png alt="GNU Read-only After Relocation" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124181237.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124181237.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20241124181237.png?size=large 2x" data-title=20241124181237 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>GNU Read-only After Relocation</figcaption></figure></p><p>而剩余的两部分也都是数据段的内容，它们都是可读可写的，第一个后面存在文件路径，而后面那个没有。这是因为这个数据段的文件大小小于映射后的 RAM 大小，所以 RAM 超出文件的部分就没有文件映射了，也就没有文件路径了。</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2025-01-31 20:17:51">更新于 2025.1.31&nbsp;
<a class=git-hash href=https://github.com/czTangt/blog.git/commit/f0c83d42fb6bbd272123c9c5cbae3f6e3125c70f rel="external nofollow noopener noreferrer" target=_blank title="commit by czTangt(cz.tangt@gmail.com) f0c83d42fb6bbd272123c9c5cbae3f6e3125c70f: add post of android-reverse"><i class="fa-solid fa-hashtag fa-fw" aria-hidden=true></i>f0c83d4</a></span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href="https://github.com/czTangt/blog.git/blob/main/content/posts%5candroid%5cELF.md?plain=1" title=查看源码 target=_blank rel="external nofollow noopener noreferrer" class=link-to-source>查看源码</a></span><span><a href=https://github.com/czTangt/blog.git/edit/main/content/posts%5candroid%5cELF.md title=编辑此页 target=_blank rel="external nofollow noopener noreferrer" class=link-to-edit>编辑此页</a></span><span><a href="https://github.com/czTangt/blog.git/issues/new?title=[BUG]%20ELF+%E8%A7%A3%E6%9E%90&amp;body=%7cField%7cValue%7c%0A%7c-%7c-%7c%0A%7cTitle%7cELF+%E8%A7%A3%E6%9E%90%7c%0A%7cURL%7chttps://czTangt.github.io/blog/posts/android/elf/%7c%0A%7cFilename%7chttps://github.com/czTangt/blog.git/blob/main/content/posts%5candroid%5cELF.md?plain=1%7c" title=报告问题 target=_blank rel="external nofollow noopener noreferrer" class=link-to-report>报告问题</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 X" data-sharer=twitter data-url=https://czTangt.github.io/blog/posts/android/elf/ data-title="ELF 解析" data-hashtags=reverse,android><i class="fa-brands fa-x-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://czTangt.github.io/blog/posts/android/elf/ data-hashtag=reverse><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://czTangt.github.io/blog/posts/android/elf/ data-title="ELF 解析"><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/blog/tags/reverse/ class=post-tag title="标签 - Reverse">Reverse</a><a href=/blog/tags/android/ class=post-tag title="标签 - Android">Android</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/blog/>主页</a></span></section></div><div class=post-nav><a href=/blog/posts/compile/semantics-symboltable-ag/ class=post-nav-item rel=prev title="03 Semantics SymbolTable Ag"><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>03 Semantics SymbolTable Ag</a><a href=/blog/posts/config/android-phone/ class=post-nav-item rel=next title=安卓手机配置>安卓手机配置<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article><aside class=toc id=toc-auto aria-label=目录><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside></main><footer class=footer><div class=footer-container><div class="footer-line powered order-1">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.136.5"><img class=hugo-icon src=/blog/images/hugo.min.svg alt="Hugo logo"> Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.3.17-30a67c4b"><img class=fixit-icon src=/blog/images/fixit.min.svg alt="FixIt logo"> FixIt</a></div><div class="footer-line copyright order-2" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2024 - 2025</span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class="variant-numeric d-none">0%</span></div></div><a href=https://github.com/czTangt/blog title="View source on GitHub" target=_blank rel="external nofollow" class="github-corner left d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true" width="56" height="56"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><noscript><div class=noscript-warning>该网站在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/blog/lib/lightgallery/css/lightgallery-bundle.min.css><link rel=preload href=/blog/lib/katex/katex.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/blog/lib/katex/katex.min.css></noscript><link rel=stylesheet href=/blog/lib/cookieconsent/cookieconsent.min.css><script src=/blog/lib/autocomplete/autocomplete.min.js defer></script><script src=/blog/lib/fuse/fuse.min.js defer></script><script src=/blog/lib/lightgallery/lightgallery.min.js defer></script><script src=/blog/lib/lightgallery/plugins/thumbnail/lg-thumbnail.min.js defer></script><script src=/blog/lib/lightgallery/plugins/zoom/lg-zoom.min.js defer></script><script src=/blog/lib/sharer/sharer.min.js async defer></script><script src=/blog/lib/katex/katex.min.js defer></script><script src=/blog/lib/katex/auto-render.min.js defer></script><script src=/blog/lib/katex/mhchem.min.js defer></script><script src=/blog/lib/cookieconsent/cookieconsent.min.js defer></script><script src=/blog/js/codeblock.js defer></script><script src=https://libs.baidu.com/jquery/2.1.4/jquery.min.js defer></script><script>window.config={code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:10},comment:{enable:!1},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},lightgallery:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{distance:100,findAllMatches:!1,fuseIndexURL:"/blog/search.json",highlightTag:"em",ignoreFieldNorm:!1,ignoreLocation:!1,isCaseSensitive:!1,location:0,maxResultLength:10,minMatchCharLength:2,noResultsFound:"没有找到结果",snippetLength:30,threshold:.3,type:"fuse",useExtendedSearch:!1},version:"v0.3.17-30a67c4b"}</script><script src=/blog/js/theme.min.js defer></script></body></html>