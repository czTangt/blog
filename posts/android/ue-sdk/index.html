<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>UE SDK分析 - czTang</title><meta name=author content="czTang">
<meta name=description content="这里记录一下对于 UE4.27 SDK 的理解，同时补充完善 2024第九届腾讯游戏安全技术竞赛初赛安卓赛道 中的分析。源码在 SDKDumper。
"><meta name=keywords content='android,game'><meta itemprop=name content="UE SDK分析"><meta itemprop=description content="这里记录一下对于 UE4.27 SDK 的理解，同时补充完善 2024第九届腾讯游戏安全技术竞赛初赛安卓赛道 中的分析。源码在 SDKDumper。"><meta itemprop=datePublished content="2025-07-08T22:08:14+08:00"><meta itemprop=dateModified content="2025-07-13T13:35:57+08:00"><meta itemprop=wordCount content="3875"><meta itemprop=keywords content="Android,Game"><meta property="og:url" content="https://czTangt.github.io/blog/posts/android/ue-sdk/"><meta property="og:site_name" content="czTang"><meta property="og:title" content="UE SDK分析"><meta property="og:description" content="这里记录一下对于 UE4.27 SDK 的理解，同时补充完善 2024第九届腾讯游戏安全技术竞赛初赛安卓赛道 中的分析。源码在 SDKDumper。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-07-08T22:08:14+08:00"><meta property="article:modified_time" content="2025-07-13T13:35:57+08:00"><meta property="article:tag" content="Android"><meta property="article:tag" content="Game"><meta name=twitter:card content="summary"><meta name=twitter:title content="UE SDK分析"><meta name=twitter:description content="这里记录一下对于 UE4.27 SDK 的理解，同时补充完善 2024第九届腾讯游戏安全技术竞赛初赛安卓赛道 中的分析。源码在 SDKDumper。"><meta name=application-name content="FixIt"><meta name=apple-mobile-web-app-title content="FixIt"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel=icon href=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202410312135963.svg><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical type=text/html href=https://czTangt.github.io/blog/posts/android/ue-sdk/ title="UE SDK分析 - czTang"><link rel=prev type=text/html href=https://czTangt.github.io/blog/posts/android/2024-tencent-gamesec-final/ title=2024腾讯游戏安全竞赛决赛><link rel=stylesheet href=/blog/css/style.min.css><link rel=preload href=/blog/lib/fontawesome-free/all.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/blog/lib/fontawesome-free/all.min.css></noscript><link rel=preload href=/blog/lib/animate/animate.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/blog/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"UE SDK分析","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/czTangt.github.io\/blog\/posts\/android\/ue-sdk\/"},"genre":"posts","keywords":"android, game","wordcount":3875,"url":"https:\/\/czTangt.github.io\/blog\/posts\/android\/ue-sdk\/","datePublished":"2025-07-08T22:08:14+08:00","dateModified":"2025-07-13T13:35:57+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"czTang"},"description":""}</script><script src=/blog/js/head/color-scheme.min.js></script></head><body data-header-desktop=sticky data-header-mobile=auto><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=left><div class=header-title><a href=/blog/ title=czTang><span class=header-title-pre><i class='fa fa-coffee'>&nbsp</i></span><span class=header-title-text>czTang</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/blog/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 归档</a></li><li class=menu-item><a class=menu-link href=/blog/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/blog/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/blog/about/><i class="fa-solid fa-user fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/blog/ title=czTang><span class=header-title-pre><i class='fa fa-coffee'>&nbsp</i></span><span class=header-title-text>czTang</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/blog/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 归档</a></li><li class=menu-item><a class=menu-link href=/blog/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/blog/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/blog/about/><i class="fa-solid fa-user fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=container><aside class="aside-collection animate__animated animate__fadeIn animate__faster" aria-label=合集><div class="details collection-details open"><div class="details-summary collection-summary"><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i>
<span class=collection-name title=合集>Game</span>
<span class=collection-count>3</span><i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class="details-content collection-content"><nav><ul class=collection-list><li class=collection-item><a href=/blog/posts/android/2024-tencent-gamesec-prelim/ title=2024腾讯游戏安全竞赛初赛>2024腾讯游戏安全竞赛初赛</a></li><li class=collection-item><a href=/blog/posts/android/2024-tencent-gamesec-final/ title=2024腾讯游戏安全竞赛决赛>2024腾讯游戏安全竞赛决赛</a></li><li class=collection-item><span class=active title="UE SDK分析">UE SDK分析</span></li></ul><div class=collection-nav-simple><a href=/blog/posts/android/2024-tencent-gamesec-final/ class=collection-nav-item rel=prev title=2024腾讯游戏安全竞赛决赛><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i></a><span class=text-secondary>3/3</span><i class="fa-solid fa-angle-right fa-fw collection-nav-item text-secondary" aria-hidden=true></i></div></nav></div></div></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>UE SDK分析</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/czTangt title=作者 target=_blank rel="external nofollow noopener noreferrer author" class=author><img loading=lazy src=/blog/images/avatar.jpg alt=czTang data-title=czTang width=20 height=20 class=avatar style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'>&nbsp;czTang</a></span><span class=post-included-in>&nbsp;收录于 <a href=/blog/categories/android/ class=post-category title="分类 - Android"><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> Android</a> 和 <a href=/blog/collections/game/ class=post-collection title="合集 - Game"><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i> Game</a></span></div><div class=post-meta-line><span title="发布于 2025-07-08 22:08:14"><i class="fa-solid fa-calendar-days fa-fw me-1" aria-hidden=true></i><time datetime=2025.7.8>2025.7.8</time></span>&nbsp;<span title="更新于 2025-07-13 13:35:57"><i class="fa-regular fa-calendar-check fa-fw me-1" aria-hidden=true></i><time datetime=2025.7.13>2025.7.13</time></span>&nbsp;<span title="3875 字"><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 3900 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 8 分钟</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#基本结构>基本结构</a></li><li><a href=#strings-获取>Strings 获取</a><ul><li><a href=#fnameentryallocator>FNameEntryAllocator</a></li><li><a href=#debugdump>DebugDump</a></li><li><a href=#debugdumpblock>DebugDumpBlock</a><ul><li><a href=#fnameentry>FNameEntry</a></li><li><a href=#函数解析>函数解析</a></li></ul></li><li><a href=#偏移补充>偏移补充</a></li></ul></li><li><a href=#actors-获取>Actors 获取</a></li></ul></nav></div></div><div class=content id=content><p>这里记录一下对于 UE4.27 SDK 的理解，同时补充完善 <a href=https://gss.tencent.com/competition/2024/race-pre.htm target=_blank rel="external nofollow noopener noreferrer">2024第九届腾讯游戏安全技术竞赛初赛安卓赛道</a> 中的分析。源码在 <a href=https://github.com/czTangt/SDKDumper target=_blank rel="external nofollow noopener noreferrer">SDKDumper</a>。</p><div class="details admonition abstract open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-clipboard-list" aria-hidden=true></i>注意事项</div><div class=details-content><div class=admonition-content><p>为了更好地理解 UE4.27 SDK 的获取，这里根据 <a href=https://bbs.kanxue.com/thread-282857.htm target=_blank rel="external nofollow noopener noreferrer">UE4.27SDK-Dump</a> 的内容对 UE4.27 源码进行分析，同时结合 <a href=https://github.com/hackcatml/frida-ue4dump target=_blank rel="external nofollow noopener noreferrer">frida-ue4dump</a> 和 <a href=https://github.com/revercc/UE4Dumper target=_blank rel="external nofollow noopener noreferrer">UE4Dumper</a> 的代码对 <a href=https://gss.tencent.com/competition/2024/race-pre.htm target=_blank rel="external nofollow noopener noreferrer">2024第九届腾讯游戏安全技术竞赛初赛安卓赛道</a> 的游戏样本进行分析。同时在分析的过程中穿插对于 libUE.so 内存布局的查看，以便应对魔改的情况。</p></div></div></div><h2 id=基本结构 class=heading-element><span>基本结构</span>
<a href=#%e5%9f%ba%e6%9c%ac%e7%bb%93%e6%9e%84 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>查看 <a href=https://github.com/revercc/UE4Dumper target=_blank rel="external nofollow noopener noreferrer">UE4Dumper</a> 的使用指南，可以发现 dump sdk 通常需要 libUE.so 中三个变量的地址 GWorld，GName 和 GUObjectArray（也被称为GUobject）。</p><ul><li><strong>GWorld</strong>：<code>GWorld</code> 是一个全局变量，其类型为 <code>UWorld**</code>。它存储着指向当前活动游戏世界实例（<code>UWorld*</code>）的指针的地址。<code>*GWorld</code> 提供了访问当前世界（<code>UWorld</code>）的直接指针。<code>UWorld</code> 对象包含了游戏运行时的核心状态，如关卡、Actor 列表、玩家控制器、游戏模式、游戏状态、物理和导航系统等。它是游戏逻辑和对象交互的中心枢纽，是逆向工程中定位游戏状态和对象的起点。</li><li><strong>GName</strong>：<code>GName</code> 是一个全局的 <code>FNamePool</code> 实例。<code>FNamePool</code> 管理着引擎中所有唯一字符串标识符（FName）的存储池。它采用大块内存分配策略，块内划分槽位存储字符串条目。<code>GName</code> 使得通过 <code>FName</code> 的索引或句柄快速查找和比较字符串成为可能，是解析对象类型名、函数名、属性名等字符串的关键。</li><li><strong>GUObjectArray</strong>：<code>GUObjectArray</code> 是一个全局的 <code>FUObjectArray</code> 类型的实例。它是 UE 垃圾回收系统的核心组成部分，是所有 <code>UObject</code> 及其派生类实例的全局容器和注册表。通过遍历 <code>GUObjectArray</code>，可以枚举、跟踪和管理引擎中存在的所有 <code>UObject</code> 实例。</li></ul><p>在获取这些变量的地址之后，就可以进行下一步了。这里三个变量的获取方法不再赘述，网上很多资料讲述如何获取。</p><h2 id=strings-获取 class=heading-element><span>Strings 获取</span>
<a href=#strings-%e8%8e%b7%e5%8f%96 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>Strings</div><div class=details-content><div class=admonition-content><p>UE 使用 <strong>FName</strong> 存储唯一且不可变的字符串标识符（如对象名称、属性名、资源路径等），它为每个字符串分配唯一数字 ID（如 123 对应 &ldquo;Player&rdquo;），将文本名称转化为高效标识符，并集中存储在全局池中，使得游戏对象（如 Actor）能通过 ID 快速检索名称。</p></div></div></div><p>这里字符串的存储依赖于 <strong>GName</strong>，上文说到 <strong>GName</strong> 是一个全局的 <code>FNamePool</code> 实例。那么可以在源码中查看 <code>FNamePool</code> 这个类，如下所示：<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313173020.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313173020.png?size=small" data-sub-html="<h2>20250313173020</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313173020.png alt=FNamePool srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313173020.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313173020.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313173020.png?size=large 2x" data-title=20250313173020 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>FNamePool</figcaption></figure>在这个类中，存在函数 <code>TArray&lt;const FNameEntry *> DebugDump() const</code>，它用于调试目的，负责收集名称池中所有字符串条目的指针。而有了这个指针，我们就可以获取所有的字符串了，因此这里可以通过实现这个函数来达成我们 dump Strings 的目的。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250712183818.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250712183818.png?size=small" data-sub-html="<h2>20250712183818</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250712183818.png alt="DebugDump() 函数" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250712183818.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250712183818.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250712183818.png?size=large 2x" data-title=20250712183818 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>DebugDump() 函数</figcaption></figure>查看这个函数的实现，可以发现它创建输出容器 <code>Out</code>，然后预分配内存，之后通过 <code>Entries.DebugDump(Out)</code> 委托给内部的成员进行处理来获取字符串条目的指针。这里根据函数的实现可以发现，获取字符串条目指针的函数就是 <code>Entries.DebugDump(Out)</code>，因此这里了解实现这个函数就可以达成我们的目标，因此首先就需要了解相关的数据 <code>Entries</code> 的结构。</p><h3 id=fnameentryallocator class=heading-element><span>FNameEntryAllocator</span>
<a href=#fnameentryallocator class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>这里翻阅 <code>FNamePool</code> 类的源码可以发现第一个成员变量就是 <code>Entries</code>，它的类型为 <code>FNameEntryAllocator</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>FNamePool</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>FNameEntryAllocator</span> <span class=n>Entries</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>......</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>得到了 <code>Entries</code>，那么就可以看同文件下的 <code>Entries.DebugDump(Out)</code> 函数了，这个函数就是 <code>FNameEntryAllocator</code> 类的一个成员函数。但是若要进行后续的探索，需要先知道 <code>FNameEntryAllocator</code> 这个类的结构。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313183511.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313183511.png?size=small" data-sub-html="<h2>20250313183511</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313183511.png alt=FNameEntryAllocator srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313183511.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313183511.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313183511.png?size=large 2x" data-title=20250313183511 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>FNameEntryAllocator</figcaption></figure>提取相关成员变量如下所示：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>static</span> <span class=k>constexpr</span> <span class=n>uint32</span> <span class=n>FNameMaxBlockBits</span> <span class=o>=</span> <span class=mi>13</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>constexpr</span> <span class=n>uint32</span> <span class=n>FNameBlockOffsetBits</span> <span class=o>=</span> <span class=mi>16</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>constexpr</span> <span class=n>uint32</span> <span class=n>FNameMaxBlocks</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>FNameMaxBlockBits</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>constexpr</span> <span class=n>uint32</span> <span class=n>FNameBlockOffsets</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>FNameBlockOffsetBits</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>FNameEntryAllocator</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=k>enum</span> <span class=p>{</span> <span class=n>Stride</span> <span class=o>=</span> <span class=k>alignof</span><span class=p>(</span><span class=n>FNameEntry</span><span class=p>)</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>	<span class=k>enum</span> <span class=p>{</span> <span class=n>BlockSizeBytes</span> <span class=o>=</span> <span class=n>Stride</span> <span class=o>*</span> <span class=n>FNameBlockOffsets</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>mutable</span> <span class=n>FRWLock</span> <span class=n>Lock</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>uint32</span> <span class=n>CurrentBlock</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>uint32</span> <span class=n>CurrentByteCursor</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>uint8</span><span class=o>*</span> <span class=n>Blocks</span><span class=p>[</span><span class=n>FNameMaxBlocks</span><span class=p>]</span> <span class=o>=</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>注意这个结构中存在成员变量 <code>Blocks</code>，它是 UE 中字符串存储的关键。<code>FNamePool</code> 由多个固定大小的内存块（<code>Blocks</code>）组成，每个块大小为 <code>BlockSize = FNameStride * 65536</code>。当当前块（<code>CurrentBlock</code>）用满后，会分配新块继续存储字符串。<code>CurrentByteCursor</code> 记录当前块已使用的字节数，最后一个块可能未完全使用。知道了这些就可以继续看 <code>FNameEntryAllocator</code> 的成员函数 <code>DebugDump()</code> 的代码。</p><h3 id=debugdump class=heading-element><span>DebugDump</span>
<a href=#debugdump class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>得到的 <code>DebugDump()</code> 函数实现如下：<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250712194213.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250712194213.png?size=small" data-sub-html="<h2>20250712194213</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250712194213.png alt="DebugDump() 实现" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250712194213.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250712194213.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250712194213.png?size=large 2x" data-title=20250712194213 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>DebugDump() 实现</figcaption></figure>忽略一开始加读锁的操作，这里的代码就是遍历所有的内存块，也就是 Blocks 数组，然后采用 <code>DebugDumpBlock()</code> 解析单个块中的字符串条目。for 循环内部使用完整快的固定大小 <code>BlockSizeBytes</code>，而 for 循环外对于最后一个块，因为可能没有用完，所以使用当前块的实际填充大小 <code>CurrentByteCursor</code>。</p><h3 id=debugdumpblock class=heading-element><span>DebugDumpBlock</span>
<a href=#debugdumpblock class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>然后找到 <code>DebugDumpBlock()</code> 函数进行分析：<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250713102617.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250713102617.png?size=small" data-sub-html="<h2>20250713102617</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250713102617.png alt="DebugDumpBlock() 实现" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250713102617.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250713102617.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250713102617.png?size=large 2x" data-title=20250713102617 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>DebugDumpBlock() 实现</figcaption></figure>这里 <code>End</code> 的获取就是从 <code>Block</code> 的开始加上 <code>BlockSize</code>，然后减去特定结构 <code>FNameEntry</code> 中的一个大小，因此这里要知道为什么要减去，需要知道 <code>FNameEntry</code> 的结构。</p><h4 id=fnameentry class=heading-element><span>FNameEntry</span>
<a href=#fnameentry class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p><figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313192458.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313192458.png?size=small" data-sub-html="<h2>20250313192458</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313192458.png alt=FNameEntry srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313192458.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313192458.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313192458.png?size=large 2x" data-title=20250313192458 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>FNameEntry</figcaption></figure>这里需要知道在 Block 中，字符串的存储其实就是 FNameEntry 的存储，在 Block 中紧邻的就是一个个 FNameEntry 结构，它负责对于字符串的封装处理。然后再看这个 FNameEntry 结构，它有一个在编译运行时才有效的宏，所以可以忽略不管。因此它的成员变量如下所示，只有一个 <code>FNameEntryHeader Header;</code> 和一个联合体，它们都会参与字符串的存储。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>enum</span> <span class=p>{</span> <span class=n>NAME_SIZE</span> <span class=o>=</span> <span class=mi>1024</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>FNameEntry</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>FNameEntryHeader</span> <span class=n>Header</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>union</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ANSICHAR</span> <span class=n>AnsiName</span><span class=p>[</span><span class=n>NAME_SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>WIDECHAR</span> <span class=n>WideName</span><span class=p>[</span><span class=n>NAME_SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>继续查看这里的 <code>FNameEntryHeader</code> 结构。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313192828.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313192828.png?size=small" data-sub-html="<h2>20250313192828</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313192828.png alt=FNameEntryHeader srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313192828.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313192828.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313192828.png?size=large 2x" data-title=20250313192828 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>FNameEntryHeader</figcaption></figure>然后看到同文件下的 <code>FNameEntryHeader</code> 结构，它同样存在一个编译运行时才有效的宏，忽略这个宏，它的成员变量如下所示：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>FNameEntryHeader</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>uint16</span> <span class=nl>bIsWide</span> <span class=p>:</span> <span class=mi>1</span><span class=p>;</span>                         <span class=c1>// 标记是否为宽字符（Unicode）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>static</span> <span class=k>constexpr</span> <span class=n>uint32</span> <span class=n>ProbeHashBits</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span>  <span class=c1>// 哈希值位数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>uint16</span> <span class=nl>LowercaseProbeHash</span> <span class=p>:</span> <span class=n>ProbeHashBits</span><span class=p>;</span>  <span class=c1>// 小写哈希值（5 位）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>uint16</span> <span class=nl>Len</span> <span class=p>:</span> <span class=mi>10</span><span class=p>;</span>                            <span class=c1>// 字符串长度（最大 1023）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><p>那么真实结构如下所示，这里展示的是小端序的结构。这个结构指示了该字符串是否为宽字符，同时保存了字符串哈希，字符串长度，总共使用 2 字节空间。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>| bIsWide (1 bit) | LowercaseProbeHash (5 bits) | Len (10 bits) |
</span></span><span class=line><span class=cl>| --------------- | --------------------------- | ------------- |</span></span></code></pre></td></tr></table></div></div><p>这里就知道 <code>FNameEntryHeader</code> 是一个两字节的数据，存储字符串的标识和长度等信息。后面就分析 <code>FNameEntry</code> 剩余的联合体，从代码中可以看出它根据 <code>FNameEntryHeader</code> 的 <code>bIsWide</code> 来存储普通单字节字符或宽字符。这里 <code>ANSICHAR</code> 就是 <code>char</code>，占据 8 bit 一个字节，而 <code>WIDECHAR</code> 就是 <code>wchar_t</code>，占据 16 bit 两个字节。</p><h4 id=函数解析 class=heading-element><span>函数解析</span>
<a href=#%e5%87%bd%e6%95%b0%e8%a7%a3%e6%9e%90 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>继续回到对 <code>DebugDumpBlock()</code> 的解析，可以看到 End 的获取需要 <code>FNameEntry::GetDataOffset()</code> 函数的值。找到的与这个函数相关的代码如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>int32</span> <span class=n>FNameEntry</span><span class=o>::</span><span class=n>GetDataOffset</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nf>STRUCT_OFFSET</span><span class=p>(</span><span class=n>FNameEntry</span><span class=p>,</span> <span class=n>AnsiName</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#define STRUCT_OFFSET( struc, member )	offsetof(struc, member)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define offsetof(s,m) ((::size_t)&amp;reinterpret_cast&lt;char const volatile&amp;&gt;((((s*)0)-&gt;m)))</span></span></span></code></pre></td></tr></table></div></div><p>这里最后就是调用 <code>offsetof</code> 宏，而它的本质就是计算结构体/类中成员变量相对于对象起始地址的字节偏移量。这样根据代码，这个函数的目的就是获取 <code>AnsiName</code> 变量在 <code>FNameEntry</code> 结构体中的偏移，而它的前面只有 <code>FNameEntryHeader</code> 结构体，因此这个函数返回 2。这里对于 End 需要再多减去这个 <code>FNameEntryHeader</code> 存在疑惑，不知道为什么需要减去这个 2 字节，然后找到了下面的 <code>Block</code> 分配算法。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250713112743.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250713112743.png?size=small" data-sub-html="<h2>20250713112743</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250713112743.png alt="Block 分配" srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250713112743.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250713112743.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250713112743.png?size=large 2x" data-title=20250713112743 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>Block 分配</figcaption></figure>这里可以看出分配 NewBlock 时就需要判断 <code>CurrentByteCursor + FNameEntry::GetDataOffset()</code> 的大小，因此这个 End 的计算也是根据分配算法来的。因此我觉得这里是把一个 <code>Block</code> 的最后两个字节视为无效内存区域，因为一个 <code>FNameEntry</code> 最少需要两个字节。所以这里就通过两个字节来判断 <code>Block</code> 的终止。</p><p>然后继续看 <code>DebugDumpBlock()</code> 的代码，它先是把 It 转化为 <code>FNameEntry</code> 结构体类型，然后判断其中 <code>FNameEntryHeader</code> 的长度是否为零，若不是，那么就进行记录。最后通过 <code>FNameEntry::GetSize(Len, !Entry->IsWide())</code> 寻找下一个 <code>FNameEntry</code> 结构。这里找到的相关代码如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>int32</span> <span class=n>FNameEntry</span><span class=o>::</span><span class=n>GetSize</span><span class=p>(</span><span class=n>int32</span> <span class=n>Length</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>bIsPureAnsi</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>int32</span> <span class=n>Bytes</span> <span class=o>=</span> <span class=n>GetDataOffset</span><span class=p>()</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>                <span class=n>Length</span> <span class=o>*</span> <span class=p>(</span><span class=n>bIsPureAnsi</span> <span class=o>?</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>ANSICHAR</span><span class=p>)</span> <span class=o>:</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>WIDECHAR</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nf>Align</span><span class=p>(</span><span class=n>Bytes</span><span class=p>,</span> <span class=k>alignof</span><span class=p>(</span><span class=n>FNameEntry</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Aligns a value to the nearest higher multiple of &#39;Alignment&#39;, which must be a power of two.
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * @param  Val        The value to align.
</span></span></span><span class=line><span class=cl><span class=cm> * @param  Alignment  The alignment value, must be a power of two.
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * @return The value aligned up to the specified alignment.
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>FORCEINLINE</span> <span class=k>constexpr</span> <span class=n>T</span> <span class=n>Align</span><span class=p>(</span><span class=n>T</span> <span class=n>Val</span><span class=p>,</span> <span class=n>uint64</span> <span class=n>Alignment</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>static_assert</span><span class=p>(</span><span class=n>TIsIntegral</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>Value</span> <span class=o>||</span> <span class=n>TIsPointer</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>Value</span><span class=p>,</span> <span class=s>&#34;Align expects an integer or pointer type&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=p>(</span><span class=n>T</span><span class=p>)(((</span><span class=n>uint64</span><span class=p>)</span><span class=n>Val</span> <span class=o>+</span> <span class=n>Alignment</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>&amp;</span> <span class=o>~</span><span class=p>(</span><span class=n>Alignment</span> <span class=o>-</span> <span class=mi>1</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>由这里的代码可以知道，<code>Bytes</code> 是根据是否为宽字符来计算字符的字节数，然后加上之前获取的 2 字节 <code>FNameEntryHeader</code> 而得到的，然后经过 <code>Align()</code> 函数进行内存对齐，这里是对齐到 2 字节的倍数。因为 <code>FNameEntry</code> 中存在 <code>FNameEntryHeader</code> 这个数据，它大小为 2 字节，同时 <code>Union</code> 中的 <code>ANSICHAR</code> 和 <code>WIDECHAR</code> 一个 1 字节，一个 2 字节，所以会满足最大对齐要求，对齐到 2 字节的倍数。</p><p>由此解析完函数可以知道 UE 中字符串的存储结构。首先字符串都是存储在 <code>GName</code>，也就是全局唯一的 <code>FNamePool</code> 中，它内部第一个成员变量 <code>FNameEntryAllocator</code> 中的 <code>Blocks</code> 数组就是实际存储字符串相关数据的地方。这里的结构是 <code>uint8* Blocks[]</code>，因此这个数组实际存储一个个 <code>Block</code> 的指针，然后通过解析指针可以知道每个 <code>Block</code> 的地址。而在实际的 <code>Block</code> 中，字符串按照 <code>FNameEntry</code> 的结构逐一排布，同时对齐到 2 字节的倍数，也就是若这个结构是奇数，后面就会添加一个字节的 <code>0x00</code> 进行内存对齐。而在 <code>FNameEntry</code> 中，分为两个字节的 <code>FNameEntryHeader</code> 和后面的字符串，前面的结构指明字符串是否为宽字符，字符串的长度和哈希值，这样就可以通过解析前面的结构获取字符串的信息，从而成功读取字符串。</p><h3 id=偏移补充 class=heading-element><span>偏移补充</span>
<a href=#%e5%81%8f%e7%a7%bb%e8%a1%a5%e5%85%85 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>这里主要补充一下某些变量的值和偏移。首先对于 <code>FNameEntryAllocator</code> 这个结构而言，它变量的大小很清楚了，唯一的问题就是 <code>mutable FRWLock Lock;</code> 变量大小还不知道。因为这里是 Android 的游戏分析，所以可以找到其相关的定义。这里先找到了 <code>FRWLock</code> 的定义。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313223325.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313223325.png?size=small" data-sub-html="<h2>20250313223325</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313223325.png alt=FRWLock srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313223325.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313223325.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313223325.png?size=large 2x" data-title=20250313223325 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>FRWLock</figcaption></figure>然后顺藤摸瓜可以找到 <code>FPThreadsRWLock</code> 类型的定义。<figure><a class=lightgallery href="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313223419.png?size=large" data-thumbnail="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313223419.png?size=small" data-sub-html="<h2>20250313223419</h2>"><img loading=lazy src=https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313223419.png alt=FPThreadsRWLock srcset="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313223419.png?size=small, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313223419.png?size=medium 1.5x, https://nuthecz.oss-cn-hangzhou.aliyuncs.com/img/20250313223419.png?size=large 2x" data-title=20250313223419 style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>FPThreadsRWLock</figcaption></figure>这个 <code>FPThreadsRWLock</code> 只有一个成员变量，如下所示：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>FPThreadsRWLock</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>pthread_rwlock_t</span> <span class=n>Mutex</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>因此可以知道，这个 <code>FRWLock</code> 的大小，就是 <code>pthread_rwlock_t</code> 的大小，而这个数据类型定义在 <strong>&lt;pthread.h></strong> 这个 Linux 库文件中，所以可以直接得到它的大小。在 在 32 位安卓平台上此成员大小为 0x28，在 64 位安卓平台上是 0x38。</p><p>然后就是 <code>FNameEntryAllocator</code> 中的 <code>Stride</code> 变量大小不知道。由上文知道 <code>Stride = alignof(FNameEntry)</code>，这里的 <code>alignof()</code> 用于 <code>FNameEntry</code> 的对齐要求。而根据上文对于 <code>Align()</code> 函数的解析可以知道，<code>FNameEntry</code> 的对齐要求是 2 字节，那么这里的 <code>Stride</code> 就是 2 了。</p><p>而其余的类和结构的成员变量偏移就很明了了，根据变量类型就可以看出变量大小，故这里不再赘述。</p><h2 id=actors-获取 class=heading-element><span>Actors 获取</span>
<a href=#actors-%e8%8e%b7%e5%8f%96 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><div class="details admonition info open disabled"><div class="details-summary admonition-title"><i class="icon fa-fw fa-solid fa-circle-info" aria-hidden=true></i>Actors</div><div class=details-content><div class=admonition-content><p>在 UE 中，每一个物体就是一个可交互对象，它们这些对象就是 Actor。所有首先需要知道这些对象（包括玩家）都是哪些 Actor，才能针对不同的 Actor 进行不同的操作。这里首先获取每个 Actor 的名称，而要获取名称，那么需要知道每个 Actor 的地址，然后再通过 Actor 的结构解析出它的地址。具体而言，这里首先通过 GWorld 获取 Actors 的地址，然后根据地址解析结构，获取 actorID，之后根据这个 actorID 从 GName 开始寻找，获取 Actor 的名称。这里可以查看源码知道具体的流程。</p></div></div></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2025-07-13 13:35:57">更新于 2025.7.13&nbsp;
<a class=git-hash href=https://github.com/czTangt/blog.git/commit/4c4e700b056b545f7251ca8fc05d415e65f964eb rel="external nofollow noopener noreferrer" target=_blank title="commit by czTangt(cz.tangt@gmail.com) 4c4e700b056b545f7251ca8fc05d415e65f964eb: add content of string dump"><i class="fa-solid fa-hashtag fa-fw" aria-hidden=true></i>4c4e700</a></span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href="https://github.com/czTangt/blog.git/blob/main/content/posts%5candroid%5cUE_SDK.md?plain=1" title=查看源码 target=_blank rel="external nofollow noopener noreferrer" class=link-to-source>查看源码</a></span><span><a href=https://github.com/czTangt/blog.git/edit/main/content/posts%5candroid%5cUE_SDK.md title=编辑此页 target=_blank rel="external nofollow noopener noreferrer" class=link-to-edit>编辑此页</a></span><span><a href="https://github.com/czTangt/blog.git/issues/new?title=[BUG]%20UE+SDK%E5%88%86%E6%9E%90&amp;body=%7cField%7cValue%7c%0A%7c-%7c-%7c%0A%7cTitle%7cUE+SDK%E5%88%86%E6%9E%90%7c%0A%7cURL%7chttps://czTangt.github.io/blog/posts/android/ue-sdk/%7c%0A%7cFilename%7chttps://github.com/czTangt/blog.git/blob/main/content/posts%5candroid%5cUE_SDK.md?plain=1%7c" title=报告问题 target=_blank rel="external nofollow noopener noreferrer" class=link-to-report>报告问题</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 X" data-sharer=twitter data-url=https://czTangt.github.io/blog/posts/android/ue-sdk/ data-title="UE SDK分析" data-hashtags=android,game><i class="fa-brands fa-x-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://czTangt.github.io/blog/posts/android/ue-sdk/ data-hashtag=android><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://czTangt.github.io/blog/posts/android/ue-sdk/ data-title="UE SDK分析"><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/blog/tags/android/ class=post-tag title="标签 - Android">Android</a><a href=/blog/tags/game/ class=post-tag title="标签 - Game">Game</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/blog/>主页</a></span></section></div><div class=post-nav><a href=/blog/posts/android/2024-tencent-gamesec-final/ class=post-nav-item rel=prev title=2024腾讯游戏安全竞赛决赛><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>2024腾讯游戏安全竞赛决赛</a></div></div></article><aside class=toc id=toc-auto aria-label=目录><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside></main><footer class=footer><div class=footer-container><div class="footer-line powered order-1">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.136.5"><img class=hugo-icon src=/blog/images/hugo.min.svg alt="Hugo logo"> Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.3.17-30a67c4b"><img class=fixit-icon src=/blog/images/fixit.min.svg alt="FixIt logo"> FixIt</a></div><div class="footer-line copyright order-2" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2024 - 2025</span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class="variant-numeric d-none">0%</span></div></div><a href=https://github.com/czTangt/blog title="View source on GitHub" target=_blank rel="external nofollow" class="github-corner left d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true" width="56" height="56"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><noscript><div class=noscript-warning>该网站在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/blog/lib/lightgallery/css/lightgallery-bundle.min.css><link rel=preload href=/blog/lib/katex/katex.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/blog/lib/katex/katex.min.css></noscript><link rel=stylesheet href=/blog/lib/cookieconsent/cookieconsent.min.css><script src=/blog/lib/autocomplete/autocomplete.min.js defer></script><script src=/blog/lib/fuse/fuse.min.js defer></script><script src=/blog/lib/lightgallery/lightgallery.min.js defer></script><script src=/blog/lib/lightgallery/plugins/thumbnail/lg-thumbnail.min.js defer></script><script src=/blog/lib/lightgallery/plugins/zoom/lg-zoom.min.js defer></script><script src=/blog/lib/sharer/sharer.min.js async defer></script><script src=/blog/lib/katex/katex.min.js defer></script><script src=/blog/lib/katex/auto-render.min.js defer></script><script src=/blog/lib/katex/mhchem.min.js defer></script><script src=/blog/lib/cookieconsent/cookieconsent.min.js defer></script><script src=/blog/js/codeblock.js defer></script><script src=https://libs.baidu.com/jquery/2.1.4/jquery.min.js defer></script><script>window.config={code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:10},comment:{enable:!1},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},lightgallery:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{distance:100,findAllMatches:!1,fuseIndexURL:"/blog/search.json",highlightTag:"em",ignoreFieldNorm:!1,ignoreLocation:!1,isCaseSensitive:!1,location:0,maxResultLength:10,minMatchCharLength:2,noResultsFound:"没有找到结果",snippetLength:30,threshold:.3,type:"fuse",useExtendedSearch:!1},version:"v0.3.17-30a67c4b"}</script><script src=/blog/js/theme.min.js defer></script></body></html>